/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8160:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"1.3.4"};

/***/ }),

/***/ 2775:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(5445);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 694:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(2775);
const file_command_1 = __nccwpck_require__(2909);
const utils_1 = __nccwpck_require__(5445);
const os = __importStar(__nccwpck_require__(2087));
const path = __importStar(__nccwpck_require__(5622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 */
function error(message) {
    command_1.issue('error', message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 */
function warning(message) {
    command_1.issue('warning', message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 2909:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(5747));
const os = __importStar(__nccwpck_require__(2087));
const utils_1 = __nccwpck_require__(5445);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 5445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 8048:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackoffTimeout = void 0;
const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;
/**
 * Get a number uniformly at random in the range [min, max)
 * @param min
 * @param max
 */
function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
}
class BackoffTimeout {
    constructor(callback, options) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        if (options) {
            if (options.initialDelay) {
                this.initialDelay = options.initialDelay;
            }
            if (options.multiplier) {
                this.multiplier = options.multiplier;
            }
            if (options.jitter) {
                this.jitter = options.jitter;
            }
            if (options.maxDelay) {
                this.maxDelay = options.maxDelay;
            }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => { }, 0);
        clearTimeout(this.timerId);
    }
    /**
     * Call the callback after the current amount of delay time
     */
    runOnce() {
        var _a, _b;
        this.running = true;
        this.timerId = setTimeout(() => {
            this.callback();
            this.running = false;
        }, this.nextDelay);
        if (!this.hasRef) {
            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay =
            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
    }
    /**
     * Stop the timer. The callback will not be called until `runOnce` is called
     * again.
     */
    stop() {
        clearTimeout(this.timerId);
        this.running = false;
    }
    /**
     * Reset the delay time to its initial value.
     */
    reset() {
        this.nextDelay = this.initialDelay;
    }
    isRunning() {
        return this.running;
    }
    ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
}
exports.BackoffTimeout = BackoffTimeout;
//# sourceMappingURL=backoff-timeout.js.map

/***/ }),

/***/ 332:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;
const filter_1 = __nccwpck_require__(5271);
const constants_1 = __nccwpck_require__(9329);
const uri_parser_1 = __nccwpck_require__(5562);
class CallCredentialsFilter extends filter_1.BaseFilter {
    constructor(channel, stream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.stream = stream;
        this.channel = channel;
        this.stream = stream;
        const splitPath = stream.getMethod().split('/');
        let serviceName = '';
        /* The standard path format is "/{serviceName}/{methodName}", so if we split
         * by '/', the first item should be empty and the second should be the
         * service name */
        if (splitPath.length >= 2) {
            serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';
        /* Currently, call credentials are only allowed on HTTPS connections, so we
         * can assume that the scheme is "https" */
        this.serviceUrl = `https://${hostname}/${serviceName}`;
    }
    async sendMetadata(metadata) {
        const credentials = this.stream.getCredentials();
        const credsMetadata = credentials.generateMetadata({
            service_url: this.serviceUrl,
        });
        const resultMetadata = await metadata;
        try {
            resultMetadata.merge(await credsMetadata);
        }
        catch (error) {
            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);
            return Promise.reject('Failed to retrieve auth metadata');
        }
        if (resultMetadata.get('authorization').length > 1) {
            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '"authorization" metadata cannot have multiple values');
            return Promise.reject('"authorization" metadata cannot have multiple values');
        }
        return resultMetadata;
    }
}
exports.CallCredentialsFilter = CallCredentialsFilter;
class CallCredentialsFilterFactory {
    constructor(channel) {
        this.channel = channel;
        this.channel = channel;
    }
    createFilter(callStream) {
        return new CallCredentialsFilter(this.channel, callStream);
    }
}
exports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;
//# sourceMappingURL=call-credentials-filter.js.map

/***/ }),

/***/ 1018:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallCredentials = void 0;
const metadata_1 = __nccwpck_require__(618);
function isCurrentOauth2Client(client) {
    return ('getRequestHeaders' in client &&
        typeof client.getRequestHeaders === 'function');
}
/**
 * A class that represents a generic method of adding authentication-related
 * metadata on a per-request basis.
 */
class CallCredentials {
    /**
     * Creates a new CallCredentials object from a given function that generates
     * Metadata objects.
     * @param metadataGenerator A function that accepts a set of options, and
     * generates a Metadata object based on these options, which is passed back
     * to the caller via a supplied (err, metadata) callback.
     */
    static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
    }
    /**
     * Create a gRPC credential from a Google credential object.
     * @param googleCredentials The authentication client to use.
     * @return The resulting CallCredentials object.
     */
    static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options, callback) => {
            let getHeaders;
            if (isCurrentOauth2Client(googleCredentials)) {
                getHeaders = googleCredentials.getRequestHeaders(options.service_url);
            }
            else {
                getHeaders = new Promise((resolve, reject) => {
                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(headers);
                    });
                });
            }
            getHeaders.then((headers) => {
                const metadata = new metadata_1.Metadata();
                for (const key of Object.keys(headers)) {
                    metadata.add(key, headers[key]);
                }
                callback(null, metadata);
            }, (err) => {
                callback(err);
            });
        });
    }
    static createEmpty() {
        return new EmptyCallCredentials();
    }
}
exports.CallCredentials = CallCredentials;
class ComposedCallCredentials extends CallCredentials {
    constructor(creds) {
        super();
        this.creds = creds;
    }
    async generateMetadata(options) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
        for (const gen of generated) {
            base.merge(gen);
        }
        return base;
    }
    compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedCallCredentials) {
            return this.creds.every((value, index) => value._equals(other.creds[index]));
        }
        else {
            return false;
        }
    }
}
class SingleCallCredentials extends CallCredentials {
    constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
    }
    generateMetadata(options) {
        return new Promise((resolve, reject) => {
            this.metadataGenerator(options, (err, metadata) => {
                if (metadata !== undefined) {
                    resolve(metadata);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    compose(other) {
        return new ComposedCallCredentials([this, other]);
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SingleCallCredentials) {
            return this.metadataGenerator === other.metadataGenerator;
        }
        else {
            return false;
        }
    }
}
class EmptyCallCredentials extends CallCredentials {
    generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
    }
    compose(other) {
        return other;
    }
    _equals(other) {
        return other instanceof EmptyCallCredentials;
    }
}
//# sourceMappingURL=call-credentials.js.map

/***/ }),

/***/ 4470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;
const http2 = __nccwpck_require__(7565);
const os = __nccwpck_require__(2087);
const constants_1 = __nccwpck_require__(9329);
const filter_stack_1 = __nccwpck_require__(8235);
const metadata_1 = __nccwpck_require__(618);
const stream_decoder_1 = __nccwpck_require__(5898);
const logging = __nccwpck_require__(8679);
const constants_2 = __nccwpck_require__(9329);
const TRACER_NAME = 'call_stream';
const { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL, } = http2.constants;
/**
 * Should do approximately the same thing as util.getSystemErrorName but the
 * TypeScript types don't have that function for some reason so I just made my
 * own.
 * @param errno
 */
function getSystemErrorName(errno) {
    for (const [name, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
            return name;
        }
    }
    return 'Unknown system error ' + errno;
}
function isInterceptingListener(listener) {
    return (listener.onReceiveMetadata !== undefined &&
        listener.onReceiveMetadata.length === 1);
}
exports.isInterceptingListener = isInterceptingListener;
class InterceptingListenerImpl {
    constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMessage = false;
        this.pendingStatus = null;
    }
    onReceiveMetadata(metadata) {
        this.listener.onReceiveMetadata(metadata, (metadata) => {
            this.nextListener.onReceiveMetadata(metadata);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    onReceiveMessage(message) {
        /* If this listener processes messages asynchronously, the last message may
         * be reordered with respect to the status */
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
            this.processingMessage = false;
            this.nextListener.onReceiveMessage(msg);
            if (this.pendingStatus) {
                this.nextListener.onReceiveStatus(this.pendingStatus);
            }
        });
    }
    onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
            if (this.processingMessage) {
                this.pendingStatus = processedStatus;
            }
            else {
                this.nextListener.onReceiveStatus(processedStatus);
            }
        });
    }
}
exports.InterceptingListenerImpl = InterceptingListenerImpl;
class Http2CallStream {
    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {
        this.methodName = methodName;
        this.channel = channel;
        this.options = options;
        this.channelCallCredentials = channelCallCredentials;
        this.callNumber = callNumber;
        this.http2Stream = null;
        this.pendingRead = false;
        this.isWriteFilterPending = false;
        this.pendingWrite = null;
        this.pendingWriteCallback = null;
        this.writesClosed = false;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.canPush = false;
        /**
         * Indicates that an 'end' event has come from the http2 stream, so there
         * will be no more data events.
         */
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.unfilteredReadMessages = [];
        // Status code mapped from :status. To be used if grpc-status is not received
        this.mappedStatusCode = constants_1.Status.UNKNOWN;
        // This is populated (non-null) if and only if the call has ended
        this.finalStatus = null;
        this.subchannel = null;
        this.listener = null;
        this.internalError = null;
        this.filterStack = filterStackFactory.createFilter(this);
        this.credentials = channelCallCredentials;
        this.disconnectListener = () => {
            this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: 'Connection dropped',
                metadata: new metadata_1.Metadata(),
            });
        };
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {
            this.options.parentCall.on('cancelled', () => {
                this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');
            });
        }
    }
    outputStatus() {
        /* Precondition: this.finalStatus !== null */
        if (!this.statusOutput) {
            this.statusOutput = true;
            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);
            /* We delay the actual action of bubbling up the status to insulate the
             * cleanup code in this class from any errors that may be thrown in the
             * upper layers as a result of bubbling up the status. In particular,
             * if the status is not OK, the "error" event may be emitted
             * synchronously at the top level, which will result in a thrown error if
             * the user does not handle that event. */
            process.nextTick(() => {
                var _a;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
            });
            if (this.subchannel) {
                this.subchannel.callUnref();
                this.subchannel.removeDisconnectListener(this.disconnectListener);
            }
        }
    }
    trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
    }
    /**
     * On first call, emits a 'status' event with the given StatusObject.
     * Subsequent calls are no-ops.
     * @param status The status of the call.
     */
    endCall(status) {
        /* If the status is OK and a new status comes in (e.g. from a
         * deserialization failure), that new status takes priority */
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
            this.trace('ended with status: code=' +
                status.code +
                ' details="' +
                status.details +
                '"');
            this.finalStatus = status;
            this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
    }
    maybeOutputStatus() {
        if (this.finalStatus !== null) {
            /* The combination check of readsClosed and that the two message buffer
             * arrays are empty checks that there all incoming data has been fully
             * processed */
            if (this.finalStatus.code !== constants_1.Status.OK ||
                (this.readsClosed &&
                    this.unpushedReadMessages.length === 0 &&
                    this.unfilteredReadMessages.length === 0 &&
                    !this.isReadFilterPending)) {
                this.outputStatus();
            }
        }
    }
    push(message) {
        this.trace('pushing to reader message of length ' +
            (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        process.nextTick(() => {
            var _a;
            /* If we have already output the status any later messages should be
             * ignored, and can cause out-of-order operation errors higher up in the
             * stack. Checking as late as possible here to avoid any race conditions.
             */
            if (this.statusOutput) {
                return;
            }
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);
            this.maybeOutputStatus();
        });
    }
    handleFilterError(error) {
        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);
    }
    handleFilteredRead(message) {
        /* If we the call has already ended with an error, we don't want to do
         * anything with this message. Dropping it on the floor is correct
         * behavior */
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
            this.maybeOutputStatus();
            return;
        }
        this.isReadFilterPending = false;
        if (this.canPush) {
            this.http2Stream.pause();
            this.push(message);
        }
        else {
            this.trace('unpushedReadMessages.push message of length ' + message.length);
            this.unpushedReadMessages.push(message);
        }
        if (this.unfilteredReadMessages.length > 0) {
            /* nextMessage is guaranteed not to be undefined because
               unfilteredReadMessages is non-empty */
            const nextMessage = this.unfilteredReadMessages.shift();
            this.filterReceivedMessage(nextMessage);
        }
    }
    filterReceivedMessage(framedMessage) {
        /* If we the call has already ended with an error, we don't want to do
         * anything with this message. Dropping it on the floor is correct
         * behavior */
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
            this.maybeOutputStatus();
            return;
        }
        this.trace('filterReceivedMessage of length ' + framedMessage.length);
        this.isReadFilterPending = true;
        this.filterStack
            .receiveMessage(Promise.resolve(framedMessage))
            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));
    }
    tryPush(messageBytes) {
        if (this.isReadFilterPending) {
            this.trace('unfilteredReadMessages.push message of length ' +
                (messageBytes && messageBytes.length));
            this.unfilteredReadMessages.push(messageBytes);
        }
        else {
            this.filterReceivedMessage(messageBytes);
        }
    }
    handleTrailers(headers) {
        let headersString = '';
        for (const header of Object.keys(headers)) {
            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
        }
        this.trace('Received server trailers:\n' + headersString);
        let metadata;
        try {
            metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        }
        catch (e) {
            metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1.Status.UNKNOWN &&
            typeof metadataMap['grpc-status'] === 'string') {
            const receivedStatus = Number(metadataMap['grpc-status']);
            if (receivedStatus in constants_1.Status) {
                code = receivedStatus;
                this.trace('received status code ' + receivedStatus + ' from server');
            }
            metadata.remove('grpc-status');
        }
        let details = '';
        if (typeof metadataMap['grpc-message'] === 'string') {
            details = decodeURI(metadataMap['grpc-message']);
            metadata.remove('grpc-message');
            this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        // This is a no-op if the call was already ended when handling headers.
        this.endCall(status);
    }
    attachHttp2Stream(stream, subchannel, extraFilterFactory) {
        if (extraFilterFactory !== undefined) {
            this.filterStack = new filter_stack_1.FilterStack([
                this.filterStack,
                extraFilterFactory.createFilter(this),
            ]);
        }
        if (this.finalStatus !== null) {
            stream.close(NGHTTP2_CANCEL);
        }
        else {
            this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());
            this.http2Stream = stream;
            this.subchannel = subchannel;
            subchannel.addDisconnectListener(this.disconnectListener);
            subchannel.callRef();
            stream.on('response', (headers, flags) => {
                var _a;
                let headersString = '';
                for (const header of Object.keys(headers)) {
                    headersString += '\t\t' + header + ': ' + headers[header] + '\n';
                }
                this.trace('Received server headers:\n' + headersString);
                switch (headers[':status']) {
                    // TODO(murgatroid99): handle 100 and 101
                    case 400:
                        this.mappedStatusCode = constants_1.Status.INTERNAL;
                        break;
                    case 401:
                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
                        break;
                    case 403:
                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
                        break;
                    case 404:
                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
                        break;
                    case 429:
                    case 502:
                    case 503:
                    case 504:
                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
                        break;
                    default:
                        this.mappedStatusCode = constants_1.Status.UNKNOWN;
                }
                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
                    this.handleTrailers(headers);
                }
                else {
                    let metadata;
                    try {
                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);
                    }
                    catch (error) {
                        this.endCall({
                            code: constants_1.Status.UNKNOWN,
                            details: error.message,
                            metadata: new metadata_1.Metadata(),
                        });
                        return;
                    }
                    try {
                        const finalMetadata = this.filterStack.receiveMetadata(metadata);
                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);
                    }
                    catch (error) {
                        this.endCall({
                            code: constants_1.Status.UNKNOWN,
                            details: error.message,
                            metadata: new metadata_1.Metadata(),
                        });
                    }
                }
            });
            stream.on('trailers', this.handleTrailers.bind(this));
            stream.on('data', (data) => {
                this.trace('receive HTTP/2 data frame of length ' + data.length);
                const messages = this.decoder.write(data);
                for (const message of messages) {
                    this.trace('parsed message of length ' + message.length);
                    this.tryPush(message);
                }
            });
            stream.on('end', () => {
                this.readsClosed = true;
                this.maybeOutputStatus();
            });
            stream.on('close', () => {
                /* Use process.next tick to ensure that this code happens after any
                 * "error" event that may be emitted at about the same time, so that
                 * we can bubble up the error message from that event. */
                process.nextTick(() => {
                    var _a;
                    this.trace('HTTP/2 stream closed with code ' + stream.rstCode);
                    /* If we have a final status with an OK status code, that means that
                     * we have received all of the messages and we have processed the
                     * trailers and the call completed successfully, so it doesn't matter
                     * how the stream ends after that */
                    if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                        return;
                    }
                    let code;
                    let details = '';
                    switch (stream.rstCode) {
                        case http2.constants.NGHTTP2_NO_ERROR:
                            /* If we get a NO_ERROR code and we already have a status, the
                             * stream completed properly and we just haven't fully processed
                             * it yet */
                            if (this.finalStatus !== null) {
                                return;
                            }
                            code = constants_1.Status.INTERNAL;
                            details = `Received RST_STREAM with code ${stream.rstCode}`;
                            break;
                        case http2.constants.NGHTTP2_REFUSED_STREAM:
                            code = constants_1.Status.UNAVAILABLE;
                            details = 'Stream refused by server';
                            break;
                        case http2.constants.NGHTTP2_CANCEL:
                            code = constants_1.Status.CANCELLED;
                            details = 'Call cancelled';
                            break;
                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                            code = constants_1.Status.RESOURCE_EXHAUSTED;
                            details = 'Bandwidth exhausted';
                            break;
                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                            code = constants_1.Status.PERMISSION_DENIED;
                            details = 'Protocol not secure enough';
                            break;
                        case http2.constants.NGHTTP2_INTERNAL_ERROR:
                            code = constants_1.Status.INTERNAL;
                            if (this.internalError === null) {
                                /* This error code was previously handled in the default case, and
                                 * there are several instances of it online, so I wanted to
                                 * preserve the original error message so that people find existing
                                 * information in searches, but also include the more recognizable
                                 * "Internal server error" message. */
                                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;
                            }
                            else {
                                if (this.internalError.code === 'ECONNRESET') {
                                    code = constants_1.Status.UNAVAILABLE;
                                    details = this.internalError.message;
                                }
                                else {
                                    /* The "Received RST_STREAM with code ..." error is preserved
                                     * here for continuity with errors reported online, but the
                                     * error message at the end will probably be more relevant in
                                     * most cases. */
                                    details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                                }
                            }
                            break;
                        default:
                            code = constants_1.Status.INTERNAL;
                            details = `Received RST_STREAM with code ${stream.rstCode}`;
                    }
                    // This is a no-op if trailers were received at all.
                    // This is OK, because status codes emitted here correspond to more
                    // catastrophic issues that prevent us from receiving trailers in the
                    // first place.
                    this.endCall({ code, details, metadata: new metadata_1.Metadata() });
                });
            });
            stream.on('error', (err) => {
                /* We need an error handler here to stop "Uncaught Error" exceptions
                 * from bubbling up. However, errors here should all correspond to
                 * "close" events, where we will handle the error more granularly */
                /* Specifically looking for stream errors that were *not* constructed
                 * from a RST_STREAM response here:
                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
                 */
                if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
                    this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);
                    this.internalError = err;
                }
            });
            if (!this.pendingRead) {
                stream.pause();
            }
            if (this.pendingWrite) {
                if (!this.pendingWriteCallback) {
                    throw new Error('Invalid state in write handling code');
                }
                this.trace('sending data chunk of length ' +
                    this.pendingWrite.length +
                    ' (deferred)');
                stream.write(this.pendingWrite, this.pendingWriteCallback);
            }
            this.maybeCloseWrites();
        }
    }
    start(metadata, listener) {
        this.trace('Sending metadata');
        this.listener = listener;
        this.channel._startCallStream(this, metadata);
    }
    destroyHttp2Stream() {
        var _a;
        // The http2 stream could already have been destroyed if cancelWithStatus
        // is called in response to an internal http2 error.
        if (this.http2Stream !== null && !this.http2Stream.destroyed) {
            /* If the call has ended with an OK status, communicate that when closing
             * the stream, partly to avoid a situation in which we detect an error
             * RST_STREAM as a result after we have the status */
            let code;
            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                code = http2.constants.NGHTTP2_NO_ERROR;
            }
            else {
                code = http2.constants.NGHTTP2_CANCEL;
            }
            this.trace('close http2 stream with code ' + code);
            this.http2Stream.close(code);
        }
    }
    cancelWithStatus(status, details) {
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
    }
    getDeadline() {
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {
            const parentDeadline = this.options.parentCall.getDeadline();
            const selfDeadline = this.options.deadline;
            const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;
            const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;
            return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);
        }
        else {
            return this.options.deadline;
        }
    }
    getCredentials() {
        return this.credentials;
    }
    setCredentials(credentials) {
        this.credentials = this.channelCallCredentials.compose(credentials);
    }
    getStatus() {
        return this.finalStatus;
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    getMethod() {
        return this.methodName;
    }
    getHost() {
        return this.options.host;
    }
    startRead() {
        /* If the stream has ended with an error, we should not emit any more
         * messages and we should communicate that the stream has ended */
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
            this.readsClosed = true;
            this.maybeOutputStatus();
            return;
        }
        this.canPush = true;
        if (this.http2Stream === null) {
            this.pendingRead = true;
        }
        else {
            if (this.unpushedReadMessages.length > 0) {
                const nextMessage = this.unpushedReadMessages.shift();
                this.push(nextMessage);
                return;
            }
            /* Only resume reading from the http2Stream if we don't have any pending
             * messages to emit */
            this.http2Stream.resume();
        }
    }
    maybeCloseWrites() {
        if (this.writesClosed &&
            !this.isWriteFilterPending &&
            this.http2Stream !== null) {
            this.trace('calling end() on HTTP/2 stream');
            this.http2Stream.end();
        }
    }
    sendMessageWithContext(context, message) {
        var _a;
        this.trace('write() called with message of length ' + message.length);
        const writeObj = {
            message,
            flags: context.flags,
        };
        const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : (() => { });
        this.isWriteFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => {
            this.isWriteFilterPending = false;
            if (this.http2Stream === null) {
                this.trace('deferring writing data chunk of length ' + message.message.length);
                this.pendingWrite = message.message;
                this.pendingWriteCallback = cb;
            }
            else {
                this.trace('sending data chunk of length ' + message.message.length);
                this.http2Stream.write(message.message, cb);
                this.maybeCloseWrites();
            }
        }, this.handleFilterError.bind(this));
    }
    halfClose() {
        this.trace('end() called');
        this.writesClosed = true;
        this.maybeCloseWrites();
    }
}
exports.Http2CallStream = Http2CallStream;
//# sourceMappingURL=call-stream.js.map

/***/ }),

/***/ 5251:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;
const events_1 = __nccwpck_require__(8614);
const stream_1 = __nccwpck_require__(5794);
const constants_1 = __nccwpck_require__(9329);
/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
function callErrorFromStatus(status) {
    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
    return Object.assign(new Error(message), status);
}
exports.callErrorFromStatus = callErrorFromStatus;
class ClientUnaryCallImpl extends events_1.EventEmitter {
    constructor() {
        super();
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
}
exports.ClientUnaryCallImpl = ClientUnaryCallImpl;
class ClientReadableStreamImpl extends stream_1.Readable {
    constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
}
exports.ClientReadableStreamImpl = ClientReadableStreamImpl;
class ClientWritableStreamImpl extends stream_1.Writable {
    constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
exports.ClientWritableStreamImpl = ClientWritableStreamImpl;
class ClientDuplexStreamImpl extends stream_1.Duplex {
    constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
exports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
//# sourceMappingURL=call.js.map

/***/ }),

/***/ 2258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelCredentials = void 0;
const tls_1 = __nccwpck_require__(4016);
const call_credentials_1 = __nccwpck_require__(1018);
const tls_helpers_1 = __nccwpck_require__(3570);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function verifyIsBufferOrNull(obj, friendlyName) {
    if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
    }
}
function bufferOrNullEqual(buf1, buf2) {
    if (buf1 === null && buf2 === null) {
        return true;
    }
    else {
        return buf1 !== null && buf2 !== null && buf1.equals(buf2);
    }
}
/**
 * A class that contains credentials for communicating over a channel, as well
 * as a set of per-call credentials, which are applied to every method call made
 * over a channel initialized with an instance of this class.
 */
class ChannelCredentials {
    constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
    }
    /**
     * Gets the set of per-call credentials associated with this instance.
     */
    _getCallCredentials() {
        return this.callCredentials;
    }
    /**
     * Return a new ChannelCredentials instance with a given set of credentials.
     * The resulting instance can be used to construct a Channel that communicates
     * over TLS.
     * @param rootCerts The root certificate data.
     * @param privateKey The client certificate private key, if available.
     * @param certChain The client certificate key chain, if available.
     */
    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        verifyIsBufferOrNull(rootCerts, 'Root certificate');
        verifyIsBufferOrNull(privateKey, 'Private key');
        verifyIsBufferOrNull(certChain, 'Certificate chain');
        if (privateKey && !certChain) {
            throw new Error('Private key must be given with accompanying certificate chain');
        }
        if (!privateKey && certChain) {
            throw new Error('Certificate chain must be given with accompanying private key');
        }
        return new SecureChannelCredentialsImpl(rootCerts || tls_helpers_1.getDefaultRootsData(), privateKey || null, certChain || null, verifyOptions || {});
    }
    /**
     * Return a new ChannelCredentials instance with no credentials.
     */
    static createInsecure() {
        return new InsecureChannelCredentialsImpl();
    }
}
exports.ChannelCredentials = ChannelCredentials;
class InsecureChannelCredentialsImpl extends ChannelCredentials {
    constructor(callCredentials) {
        super(callCredentials);
    }
    compose(callCredentials) {
        throw new Error('Cannot compose insecure credentials');
    }
    _getConnectionOptions() {
        return null;
    }
    _isSecure() {
        return false;
    }
    _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
    }
}
class SecureChannelCredentialsImpl extends ChannelCredentials {
    constructor(rootCerts, privateKey, certChain, verifyOptions) {
        super();
        this.rootCerts = rootCerts;
        this.privateKey = privateKey;
        this.certChain = certChain;
        this.verifyOptions = verifyOptions;
        const secureContext = tls_1.createSecureContext({
            ca: rootCerts || undefined,
            key: privateKey || undefined,
            cert: certChain || undefined,
            ciphers: tls_helpers_1.CIPHER_SUITES,
        });
        this.connectionOptions = { secureContext };
        if (verifyOptions && verifyOptions.checkServerIdentity) {
            this.connectionOptions.checkServerIdentity = (host, cert) => {
                return verifyOptions.checkServerIdentity(host, { raw: cert.raw });
            };
        }
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
    }
    _getConnectionOptions() {
        // Copy to prevent callers from mutating this.connectionOptions
        return Object.assign({}, this.connectionOptions);
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
            if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {
                return false;
            }
            if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {
                return false;
            }
            if (!bufferOrNullEqual(this.certChain, other.certChain)) {
                return false;
            }
            return (this.verifyOptions.checkServerIdentity ===
                other.verifyOptions.checkServerIdentity);
        }
        else {
            return false;
        }
    }
}
class ComposedChannelCredentialsImpl extends ChannelCredentials {
    constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
    }
    _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
            return (this.channelCredentials._equals(other.channelCredentials) &&
                this.callCredentials._equals(other.callCredentials));
        }
        else {
            return false;
        }
    }
}
//# sourceMappingURL=channel-credentials.js.map

/***/ }),

/***/ 8282:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.channelOptionsEqual = exports.recognizedOptions = void 0;
/**
 * This is for checking provided options at runtime. This is an object for
 * easier membership checking.
 */
exports.recognizedOptions = {
    'grpc.ssl_target_name_override': true,
    'grpc.primary_user_agent': true,
    'grpc.secondary_user_agent': true,
    'grpc.default_authority': true,
    'grpc.keepalive_time_ms': true,
    'grpc.keepalive_timeout_ms': true,
    'grpc.keepalive_permit_without_calls': true,
    'grpc.service_config': true,
    'grpc.max_concurrent_streams': true,
    'grpc.initial_reconnect_backoff_ms': true,
    'grpc.max_reconnect_backoff_ms': true,
    'grpc.use_local_subchannel_pool': true,
    'grpc.max_send_message_length': true,
    'grpc.max_receive_message_length': true,
    'grpc.enable_http_proxy': true,
    'grpc-node.max_session_memory': true,
};
function channelOptionsEqual(options1, options2) {
    const keys1 = Object.keys(options1).sort();
    const keys2 = Object.keys(options2).sort();
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
            return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
            return false;
        }
    }
    return true;
}
exports.channelOptionsEqual = channelOptionsEqual;
//# sourceMappingURL=channel-options.js.map

/***/ }),

/***/ 5855:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelImplementation = exports.ConnectivityState = void 0;
const call_stream_1 = __nccwpck_require__(4470);
const channel_credentials_1 = __nccwpck_require__(2258);
const resolving_load_balancer_1 = __nccwpck_require__(5294);
const subchannel_pool_1 = __nccwpck_require__(9905);
const picker_1 = __nccwpck_require__(3860);
const constants_1 = __nccwpck_require__(9329);
const filter_stack_1 = __nccwpck_require__(8235);
const call_credentials_filter_1 = __nccwpck_require__(332);
const deadline_filter_1 = __nccwpck_require__(6179);
const compression_filter_1 = __nccwpck_require__(8560);
const resolver_1 = __nccwpck_require__(8234);
const logging_1 = __nccwpck_require__(8679);
const max_message_size_filter_1 = __nccwpck_require__(1340);
const http_proxy_1 = __nccwpck_require__(3974);
const uri_parser_1 = __nccwpck_require__(5562);
var ConnectivityState;
(function (ConnectivityState) {
    ConnectivityState[ConnectivityState["IDLE"] = 0] = "IDLE";
    ConnectivityState[ConnectivityState["CONNECTING"] = 1] = "CONNECTING";
    ConnectivityState[ConnectivityState["READY"] = 2] = "READY";
    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));
/**
 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
 */
const MAX_TIMEOUT_TIME = 2147483647;
let nextCallNumber = 0;
function getNewCallNumber() {
    const callNumber = nextCallNumber;
    nextCallNumber += 1;
    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
        nextCallNumber = 0;
    }
    return callNumber;
}
class ChannelImplementation {
    constructor(target, credentials, options) {
        var _a, _b, _c;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        /**
         * Calls queued up to get a call config. Should only be populated before the
         * first time the resolver returns a result, which includes the ConfigSelector.
         */
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        if (typeof target !== 'string') {
            throw new TypeError('Channel target must be a string');
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
            throw new TypeError('Channel credentials must be a ChannelCredentials object');
        }
        if (options) {
            if (typeof options !== 'object' ||
                !Object.values(options).every((value) => typeof value === 'string' ||
                    typeof value === 'number' ||
                    typeof value === 'undefined')) {
                throw new TypeError('Channel options must be an object with string or number values');
            }
        }
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) {
            throw new Error(`Could not parse target name "${target}"`);
        }
        /* This ensures that the target has a scheme that is registered with the
         * resolver */
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) {
            throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options['grpc.default_authority']) {
            this.defaultAuthority = this.options['grpc.default_authority'];
        }
        else {
            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
        }
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
         * the grpc.use_local_subchannel_pool channel option means. */
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);
        const channelControlHelper = {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
            },
            updateState: (connectivityState, picker) => {
                this.currentPicker = picker;
                const queueCopy = this.pickQueue.slice();
                this.pickQueue = [];
                this.callRefTimerUnref();
                for (const { callStream, callMetadata, callConfig } of queueCopy) {
                    this.tryPick(callStream, callMetadata, callConfig);
                }
                this.updateState(connectivityState);
            },
            requestReresolution: () => {
                // This should never be called.
                throw new Error('Resolving load balancer should never call requestReresolution');
            },
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {
            this.configSelector = configSelector;
            /* We process the queue asynchronously to ensure that the corresponding
             * load balancer update has completed. */
            process.nextTick(() => {
                const localQueue = this.configSelectionQueue;
                this.configSelectionQueue = [];
                this.callRefTimerUnref();
                for (const { callStream, callMetadata } of localQueue) {
                    this.tryGetConfig(callStream, callMetadata);
                }
                this.configSelectionQueue = [];
            });
        }, (status) => {
            if (this.configSelectionQueue.length > 0) {
                logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Name resolution failed for target ' + uri_parser_1.uriToString(this.target) + ' with calls queued for config selection');
            }
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata } of localQueue) {
                if (callMetadata.getOptions().waitForReady) {
                    this.callRefTimerRef();
                    this.configSelectionQueue.push({ callStream, callMetadata });
                }
                else {
                    callStream.cancelWithStatus(status.code, status.details);
                }
            }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
            new call_credentials_filter_1.CallCredentialsFilterFactory(this),
            new deadline_filter_1.DeadlineFilterFactory(this),
            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
            new compression_filter_1.CompressionFilterFactory(this),
        ]);
    }
    callRefTimerRef() {
        var _a, _b, _c, _d;
        // If the hasRef function does not exist, always run the code
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);
            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    callRefTimerUnref() {
        var _a, _b;
        // If the hasRef function does not exist, always run the code
        if ((!this.callRefTimer.hasRef) || (this.callRefTimer.hasRef())) {
            logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);
            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    pushPick(callStream, callMetadata, callConfig) {
        this.pickQueue.push({ callStream, callMetadata, callConfig });
        this.callRefTimerRef();
    }
    /**
     * Check the picker output for the given call and corresponding metadata,
     * and take any relevant actions. Should not be called while iterating
     * over pickQueue.
     * @param callStream
     * @param callMetadata
     */
    tryPick(callStream, callMetadata, callConfig) {
        var _a, _b, _c;
        const pickResult = this.currentPicker.pick({ metadata: callMetadata, extraPickInfo: callConfig.pickInformation });
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' +
            picker_1.PickResultType[pickResult.pickResultType] +
            ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) +
            ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) +
            ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));
        switch (pickResult.pickResultType) {
            case picker_1.PickResultType.COMPLETE:
                if (pickResult.subchannel === null) {
                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');
                    // End the call with an error
                }
                else {
                    /* If the subchannel is not in the READY state, that indicates a bug
                     * somewhere in the load balancer or picker. So, we log an error and
                     * queue the pick to be tried again later. */
                    if (pickResult.subchannel.getConnectivityState() !==
                        ConnectivityState.READY) {
                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +
                            pickResult.subchannel.getAddress() +
                            ' has state ' +
                            ConnectivityState[pickResult.subchannel.getConnectivityState()]);
                        this.pushPick(callStream, callMetadata, callConfig);
                        break;
                    }
                    /* We need to clone the callMetadata here because the transparent
                     * retry code in the promise resolution handler use the same
                     * callMetadata object, so it needs to stay unmodified */
                    callStream.filterStack
                        .sendMetadata(Promise.resolve(callMetadata.clone()))
                        .then((finalMetadata) => {
                        var _a, _b, _c;
                        const subchannelState = pickResult.subchannel.getConnectivityState();
                        if (subchannelState === ConnectivityState.READY) {
                            try {
                                pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);
                                /* If we reach this point, the call stream has started
                                 * successfully */
                                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);
                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
                            }
                            catch (error) {
                                if (error.code ===
                                    'ERR_HTTP2_GOAWAY_SESSION') {
                                    /* An error here indicates that something went wrong with
                                     * the picked subchannel's http2 stream right before we
                                     * tried to start the stream. We are handling a promise
                                     * result here, so this is asynchronous with respect to the
                                     * original tryPick call, so calling it again is not
                                     * recursive. We call tryPick immediately instead of
                                     * queueing this pick again because handling the queue is
                                     * triggered by state changes, and we want to immediately
                                     * check if the state has already changed since the
                                     * previous tryPick call. We do this instead of cancelling
                                     * the stream because the correct behavior may be
                                     * re-queueing instead, based on the logic in the rest of
                                     * tryPick */
                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' +
                                        pickResult.subchannel.getAddress() +
                                        ' with error ' +
                                        error.message +
                                        '. Retrying pick');
                                    this.tryPick(callStream, callMetadata, callConfig);
                                }
                                else {
                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' +
                                        pickResult.subchannel.getAddress() +
                                        ' with error ' +
                                        error.message +
                                        '. Ending call');
                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);
                                }
                            }
                        }
                        else {
                            /* The logic for doing this here is the same as in the catch
                             * block above */
                            logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' +
                                pickResult.subchannel.getAddress() +
                                ' has state ' +
                                ConnectivityState[subchannelState] +
                                ' after metadata filters. Retrying pick');
                            this.tryPick(callStream, callMetadata, callConfig);
                        }
                    }, (error) => {
                        // We assume the error code isn't 0 (Status.OK)
                        callStream.cancelWithStatus((typeof error.code === 'number') ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
                    });
                }
                break;
            case picker_1.PickResultType.QUEUE:
                this.pushPick(callStream, callMetadata, callConfig);
                break;
            case picker_1.PickResultType.TRANSIENT_FAILURE:
                if (callMetadata.getOptions().waitForReady) {
                    this.pushPick(callStream, callMetadata, callConfig);
                }
                else {
                    callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
                }
                break;
            case picker_1.PickResultType.DROP:
                callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
                break;
            default:
                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
        }
    }
    removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
            this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
    }
    updateState(newState) {
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) +
            ' ' +
            ConnectivityState[this.connectivityState] +
            ' -> ' +
            ConnectivityState[newState]);
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
            if (newState !== watcherObject.currentState) {
                if (watcherObject.timer) {
                    clearTimeout(watcherObject.timer);
                }
                this.removeConnectivityStateWatcher(watcherObject);
                watcherObject.callback();
            }
        }
    }
    tryGetConfig(stream, metadata) {
        if (this.configSelector === null) {
            /* This branch will only be taken at the beginning of the channel's life,
             * before the resolver ever returns a result. So, the
             * ResolvingLoadBalancer may be idle and if so it needs to be kicked
             * because it now has a pending request. */
            this.resolvingLoadBalancer.exitIdle();
            this.configSelectionQueue.push({
                callStream: stream,
                callMetadata: metadata
            });
            this.callRefTimerRef();
        }
        else {
            const callConfig = this.configSelector(stream.getMethod(), metadata);
            if (callConfig.status === constants_1.Status.OK) {
                this.tryPick(stream, metadata, callConfig);
            }
            else {
                stream.cancelWithStatus(callConfig.status, "Failed to route call to method " + stream.getMethod());
            }
        }
    }
    _startCallStream(stream, metadata) {
        this.tryGetConfig(stream, metadata.clone());
    }
    close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        this.subchannelPool.unrefUnusedSubchannels();
    }
    getTarget() {
        return uri_parser_1.uriToString(this.target);
    }
    getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
            this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        let timer = null;
        if (deadline !== Infinity) {
            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
            const now = new Date();
            if (deadline === -Infinity || deadlineDate <= now) {
                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
                return;
            }
            timer = setTimeout(() => {
                this.removeConnectivityStateWatcher(watcherObject);
                callback(new Error('Deadline passed without connectivity state change'));
            }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
            currentState,
            callback,
            timer
        };
        this.connectivityStateWatchers.push(watcherObject);
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== 'string') {
            throw new TypeError('Channel#createCall: method must be a string');
        }
        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
            throw new TypeError('Channel#createCall: deadline must be a number or Date');
        }
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        const callNumber = getNewCallNumber();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) +
            ' createCall [' +
            callNumber +
            '] method="' +
            method +
            '", deadline=' +
            deadline);
        const finalOptions = {
            deadline: deadline,
            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
            host: host !== null && host !== void 0 ? host : this.defaultAuthority,
            parentCall: parentCall,
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        return stream;
    }
}
exports.ChannelImplementation = ChannelImplementation;
//# sourceMappingURL=channel.js.map

/***/ }),

/***/ 9221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;
const metadata_1 = __nccwpck_require__(618);
const call_stream_1 = __nccwpck_require__(4470);
const constants_1 = __nccwpck_require__(9329);
/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
class InterceptorConfigurationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InterceptorConfigurationError';
        Error.captureStackTrace(this, InterceptorConfigurationError);
    }
}
exports.InterceptorConfigurationError = InterceptorConfigurationError;
class ListenerBuilder {
    constructor() {
        this.metadata = undefined;
        this.message = undefined;
        this.status = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
    }
    withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
    }
    build() {
        return {
            onReceiveMetadata: this.metadata,
            onReceiveMessage: this.message,
            onReceiveStatus: this.status,
        };
    }
}
exports.ListenerBuilder = ListenerBuilder;
class RequesterBuilder {
    constructor() {
        this.start = undefined;
        this.message = undefined;
        this.halfClose = undefined;
        this.cancel = undefined;
    }
    withStart(start) {
        this.start = start;
        return this;
    }
    withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
    }
    withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
    }
    withCancel(cancel) {
        this.cancel = cancel;
        return this;
    }
    build() {
        return {
            start: this.start,
            sendMessage: this.message,
            halfClose: this.halfClose,
            cancel: this.cancel,
        };
    }
}
exports.RequesterBuilder = RequesterBuilder;
/**
 * A Listener with a default pass-through implementation of each method. Used
 * for filling out Listeners with some methods omitted.
 */
const defaultListener = {
    onReceiveMetadata: (metadata, next) => {
        next(metadata);
    },
    onReceiveMessage: (message, next) => {
        next(message);
    },
    onReceiveStatus: (status, next) => {
        next(status);
    },
};
/**
 * A Requester with a default pass-through implementation of each method. Used
 * for filling out Requesters with some methods omitted.
 */
const defaultRequester = {
    start: (metadata, listener, next) => {
        next(metadata, listener);
    },
    sendMessage: (message, next) => {
        next(message);
    },
    halfClose: (next) => {
        next();
    },
    cancel: (next) => {
        next();
    },
};
class InterceptingCall {
    constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        /**
         * Indicates that a message has been passed to the listener's onReceiveMessage
         * method it has not been passed to the corresponding next callback
         */
        this.processingMessage = false;
        /**
         * Indicates that a status was received but could not be propagated because
         * a message was still being processed.
         */
        this.pendingHalfClose = false;
        if (requester) {
            this.requester = {
                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,
            };
        }
        else {
            this.requester = defaultRequester;
        }
    }
    cancelWithStatus(status, details) {
        this.requester.cancel(() => {
            this.nextCall.cancelWithStatus(status, details);
        });
    }
    getPeer() {
        return this.nextCall.getPeer();
    }
    start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),
            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : ((message) => { }),
            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : ((status) => { }),
        };
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
            var _a, _b, _c;
            let finalInterceptingListener;
            if (call_stream_1.isInterceptingListener(listener)) {
                finalInterceptingListener = listener;
            }
            else {
                const fullListener = {
                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,
                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,
                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,
                };
                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
            }
            this.nextCall.start(md, finalInterceptingListener);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
            this.processingMessage = false;
            this.nextCall.sendMessageWithContext(context, finalMessage);
            if (this.pendingHalfClose) {
                this.nextCall.halfClose();
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) {
        this.sendMessageWithContext({}, message);
    }
    startRead() {
        this.nextCall.startRead();
    }
    halfClose() {
        this.requester.halfClose(() => {
            if (this.processingMessage) {
                this.pendingHalfClose = true;
            }
            else {
                this.nextCall.halfClose();
            }
        });
    }
    setCredentials(credentials) {
        this.nextCall.setCredentials(credentials);
    }
}
exports.InterceptingCall = InterceptingCall;
function getCall(channel, path, options) {
    var _a, _b;
    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
    const host = options.host;
    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
    const propagateFlags = options.propagate_flags;
    const credentials = options.credentials;
    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
    if (credentials) {
        call.setCredentials(credentials);
    }
    return call;
}
/**
 * InterceptingCall implementation that directly owns the underlying Call
 * object and handles serialization and deseraizliation.
 */
class BaseInterceptingCall {
    constructor(call, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
    }
    cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
    }
    getPeer() {
        return this.call.getPeer();
    }
    setCredentials(credentials) {
        this.call.setCredentials(credentials);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) {
        let serialized;
        try {
            serialized = this.methodDefinition.requestSerialize(message);
        }
        catch (e) {
            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);
            return;
        }
        this.call.sendMessageWithContext(context, serialized);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) {
        this.sendMessageWithContext({}, message);
    }
    start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
            onReceiveMetadata: (metadata) => {
                var _a;
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);
            },
            onReceiveMessage: (message) => {
                var _a;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let deserialized;
                try {
                    deserialized = this.methodDefinition.responseDeserialize(message);
                }
                catch (e) {
                    readError = {
                        code: constants_1.Status.INTERNAL,
                        details: `Response message parsing error: ${e.message}`,
                        metadata: new metadata_1.Metadata(),
                    };
                    this.call.cancelWithStatus(readError.code, readError.details);
                    return;
                }
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
            },
            onReceiveStatus: (status) => {
                var _a, _b;
                if (readError) {
                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
                }
                else {
                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
                }
            },
        });
    }
    startRead() {
        this.call.startRead();
    }
    halfClose() {
        this.call.halfClose();
    }
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with unary
 * responses.
 */
class BaseUnaryInterceptingCall extends BaseInterceptingCall {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(call, methodDefinition) {
        super(call, methodDefinition);
    }
    start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage: (message) => {
                var _a;
                receivedMessage = true;
                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);
            },
            onReceiveStatus: (status) => {
                var _a, _b;
                if (!receivedMessage) {
                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);
                }
                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);
            },
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
    }
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with streaming
 * responses.
 */
class BaseStreamingInterceptingCall extends BaseInterceptingCall {
}
function getBottomInterceptingCall(channel, options, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition) {
    const call = getCall(channel, methodDefinition.path, options);
    if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
    }
    else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
    }
}
function getInterceptingCall(interceptorArgs, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition, options, channel) {
    if (interceptorArgs.clientInterceptors.length > 0 &&
        interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
            'to the client constructor. Only one of these is allowed.');
    }
    if (interceptorArgs.callInterceptors.length > 0 &&
        interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
            'options. Only one of these is allowed.');
    }
    let interceptors = [];
    // Interceptors passed to the call override interceptors passed to the client constructor
    if (interceptorArgs.callInterceptors.length > 0 ||
        interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = []
            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition)))
            .filter((interceptor) => interceptor);
        // Filter out falsy values when providers return nothing
    }
    else {
        interceptors = []
            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition)))
            .filter((interceptor) => interceptor);
        // Filter out falsy values when providers return nothing
    }
    const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition,
    });
    /* For each interceptor in the list, the nextCall function passed to it is
     * based on the next interceptor in the list, using a nextCall function
     * constructed with the following interceptor in the list, and so on. The
     * initialValue, which is effectively at the end of the list, is a nextCall
     * function that invokes getBottomInterceptingCall, the result of which
     * handles (de)serialization and also gets the underlying call from the
     * channel. */
    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
    return getCall(interceptorOptions);
}
exports.getInterceptingCall = getInterceptingCall;
//# sourceMappingURL=client-interceptors.js.map

/***/ }),

/***/ 7650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const call_1 = __nccwpck_require__(5251);
const channel_1 = __nccwpck_require__(5855);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const client_interceptors_1 = __nccwpck_require__(9221);
const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
function isFunction(arg) {
    return typeof arg === 'function';
}
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
class Client {
    constructor(address, credentials, options = {}) {
        var _a, _b;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
                'to the client constructor. Only one of these is allowed.');
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
            options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
            this[CHANNEL_SYMBOL] = options.channelOverride;
        }
        else if (options.channelFactoryOverride) {
            const channelFactoryOverride = options.channelFactoryOverride;
            delete options.channelFactoryOverride;
            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
        }
        else {
            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
        }
    }
    close() {
        this[CHANNEL_SYMBOL].close();
    }
    getChannel() {
        return this[CHANNEL_SYMBOL];
    }
    waitForReady(deadline, callback) {
        const checkState = (err) => {
            if (err) {
                callback(new Error('Failed to connect before the deadline'));
                return;
            }
            let newState;
            try {
                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
            }
            catch (e) {
                callback(new Error('The channel has been closed'));
                return;
            }
            if (newState === channel_1.ConnectivityState.READY) {
                callback();
            }
            else {
                try {
                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
                }
                catch (e) {
                    callback(new Error('The channel has been closed'));
                }
            }
        };
        setImmediate(checkState);
    }
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        }
        else if (isFunction(arg2)) {
            if (arg1 instanceof metadata_1.Metadata) {
                return { metadata: arg1, options: {}, callback: arg2 };
            }
            else {
                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
            }
        }
        else {
            if (!(arg1 instanceof metadata_1.Metadata &&
                arg2 instanceof Object &&
                isFunction(arg3))) {
                throw new Error('Incorrect arguments passed');
            }
            return { metadata: arg1, options: arg2, callback: arg3 };
        }
    }
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientUnaryCallImpl(),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
            call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
            onReceiveMetadata: (metadata) => {
                emitter.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                if (responseMessage !== null) {
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
                }
                responseMessage = message;
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    callProperties.callback(null, responseMessage);
                }
                else {
                    callProperties.callback(call_1.callErrorFromStatus(status));
                }
                emitter.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
    }
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            metadata: checkedArguments.metadata,
            call: new call_1.ClientWritableStreamImpl(serialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
            call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
            onReceiveMetadata: (metadata) => {
                emitter.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                if (responseMessage !== null) {
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
                }
                responseMessage = message;
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    callProperties.callback(null, responseMessage);
                }
                else {
                    callProperties.callback(call_1.callErrorFromStatus(status));
                }
                emitter.emit('status', status);
            },
        });
        return emitter;
    }
    checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
            metadata = arg1;
            if (arg2) {
                options = arg2;
            }
            else {
                options = {};
            }
        }
        else {
            if (arg1) {
                options = arg1;
            }
            else {
                options = {};
            }
            metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
    }
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientReadableStreamImpl(deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        if (callProperties.callOptions.credentials) {
            call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                stream.push(message);
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    stream.emit('error', call_1.callErrorFromStatus(status));
                }
                stream.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
    }
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            metadata: checkedArguments.metadata,
            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        if (callProperties.callOptions.credentials) {
            call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            onReceiveMessage(message) {
                stream.push(message);
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    stream.emit('error', call_1.callErrorFromStatus(status));
                }
                stream.emit('status', status);
            },
        });
        return stream;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ 8560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompressionFilterFactory = exports.CompressionFilter = void 0;
const zlib = __nccwpck_require__(8761);
const filter_1 = __nccwpck_require__(5271);
class CompressionHandler {
    /**
     * @param message Raw uncompressed message bytes
     * @param compress Indicates whether the message should be compressed
     * @return Framed message, compressed if applicable
     */
    async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
            messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    /**
     * @param data Framed message, possibly compressed
     * @return Uncompressed message
     */
    async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
            messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
    }
}
class IdentityHandler extends CompressionHandler {
    async compressMessage(message) {
        return message;
    }
    async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        /* With "identity" compression, messages should always be marked as
         * uncompressed */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
    }
    decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
}
class DeflateHandler extends CompressionHandler {
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.deflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.inflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
}
class GzipHandler extends CompressionHandler {
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.gzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.unzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
}
class UnknownHandler extends CompressionHandler {
    constructor(compressionName) {
        super();
        this.compressionName = compressionName;
    }
    compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
        // This should be unreachable
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
}
function getCompressionHandler(compressionName) {
    switch (compressionName) {
        case 'identity':
            return new IdentityHandler();
        case 'deflate':
            return new DeflateHandler();
        case 'gzip':
            return new GzipHandler();
        default:
            return new UnknownHandler(compressionName);
    }
}
class CompressionFilter extends filter_1.BaseFilter {
    constructor() {
        super(...arguments);
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
    }
    async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
        headers.set('accept-encoding', 'identity');
        return headers;
    }
    receiveMetadata(metadata) {
        const receiveEncoding = metadata.get('grpc-encoding');
        if (receiveEncoding.length > 0) {
            const encoding = receiveEncoding[0];
            if (typeof encoding === 'string') {
                this.receiveCompression = getCompressionHandler(encoding);
            }
        }
        metadata.remove('grpc-encoding');
        metadata.remove('grpc-accept-encoding');
        return metadata;
    }
    async sendMessage(message) {
        /* This filter is special. The input message is the bare message bytes,
         * and the output is a framed and possibly compressed message. For this
         * reason, this filter should be at the bottom of the filter stack */
        const resolvedMessage = await message;
        const compress = resolvedMessage.flags === undefined
            ? false
            : (resolvedMessage.flags & 2 /* NoCompress */) === 0;
        return {
            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
            flags: resolvedMessage.flags,
        };
    }
    async receiveMessage(message) {
        /* This filter is also special. The input message is framed and possibly
         * compressed, and the output message is deframed and uncompressed. So
         * this is another reason that this filter should be at the bottom of the
         * filter stack. */
        return this.receiveCompression.readMessage(await message);
    }
}
exports.CompressionFilter = CompressionFilter;
class CompressionFilterFactory {
    constructor(channel) {
        this.channel = channel;
    }
    createFilter(callStream) {
        return new CompressionFilter();
    }
}
exports.CompressionFilterFactory = CompressionFilterFactory;
//# sourceMappingURL=compression-filter.js.map

/***/ }),

/***/ 9329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;
var Status;
(function (Status) {
    Status[Status["OK"] = 0] = "OK";
    Status[Status["CANCELLED"] = 1] = "CANCELLED";
    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status[Status["ABORTED"] = 10] = "ABORTED";
    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status[Status["INTERNAL"] = 13] = "INTERNAL";
    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(Status = exports.Status || (exports.Status = {}));
var LogVerbosity;
(function (LogVerbosity) {
    LogVerbosity[LogVerbosity["DEBUG"] = 0] = "DEBUG";
    LogVerbosity[LogVerbosity["INFO"] = 1] = "INFO";
    LogVerbosity[LogVerbosity["ERROR"] = 2] = "ERROR";
    LogVerbosity[LogVerbosity["NONE"] = 3] = "NONE";
})(LogVerbosity = exports.LogVerbosity || (exports.LogVerbosity = {}));
/**
 * NOTE: This enum is not currently used in any implemented API in this
 * library. It is included only for type parity with the other implementation.
 */
var Propagate;
(function (Propagate) {
    Propagate[Propagate["DEADLINE"] = 1] = "DEADLINE";
    Propagate[Propagate["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
    Propagate[Propagate["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
    Propagate[Propagate["CANCELLATION"] = 8] = "CANCELLATION";
    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
    Propagate[Propagate["DEFAULTS"] = 65535] = "DEFAULTS";
})(Propagate = exports.Propagate || (exports.Propagate = {}));
// -1 means unlimited
exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
// 4 MB default
exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 6179:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;
const constants_1 = __nccwpck_require__(9329);
const filter_1 = __nccwpck_require__(5271);
const units = [
    ['m', 1],
    ['S', 1000],
    ['M', 60 * 1000],
    ['H', 60 * 60 * 1000],
];
function getDeadline(deadline) {
    const now = new Date().getTime();
    const timeoutMs = Math.max(deadline - now, 0);
    for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
            return String(Math.ceil(amount)) + unit;
        }
    }
    throw new Error('Deadline is too far in the future');
}
class DeadlineFilter extends filter_1.BaseFilter {
    constructor(channel, callStream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.callStream = callStream;
        this.timer = null;
        const callDeadline = callStream.getDeadline();
        if (callDeadline instanceof Date) {
            this.deadline = callDeadline.getTime();
        }
        else {
            this.deadline = callDeadline;
        }
        const now = new Date().getTime();
        let timeout = this.deadline - now;
        if (timeout <= 0) {
            process.nextTick(() => {
                callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
            });
        }
        else if (this.deadline !== Infinity) {
            this.timer = setTimeout(() => {
                callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
            }, timeout);
            (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    async sendMetadata(metadata) {
        if (this.deadline === Infinity) {
            return metadata;
        }
        /* The input metadata promise depends on the original channel.connect()
         * promise, so when it is complete that implies that the channel is
         * connected */
        const finalMetadata = await metadata;
        const timeoutString = getDeadline(this.deadline);
        finalMetadata.set('grpc-timeout', timeoutString);
        return finalMetadata;
    }
    receiveTrailers(status) {
        if (this.timer) {
            clearTimeout(this.timer);
        }
        return status;
    }
}
exports.DeadlineFilter = DeadlineFilter;
class DeadlineFilterFactory {
    constructor(channel) {
        this.channel = channel;
    }
    createFilter(callStream) {
        return new DeadlineFilter(this.channel, callStream);
    }
}
exports.DeadlineFilterFactory = DeadlineFilterFactory;
//# sourceMappingURL=deadline-filter.js.map

/***/ }),

/***/ 158:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var logging_1 = __nccwpck_require__(8679);
Object.defineProperty(exports, "trace", ({ enumerable: true, get: function () { return logging_1.trace; } }));
var resolver_1 = __nccwpck_require__(8234);
Object.defineProperty(exports, "registerResolver", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));
var uri_parser_1 = __nccwpck_require__(5562);
Object.defineProperty(exports, "uriToString", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));
var backoff_timeout_1 = __nccwpck_require__(8048);
Object.defineProperty(exports, "BackoffTimeout", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));
var load_balancer_1 = __nccwpck_require__(2456);
Object.defineProperty(exports, "registerLoadBalancerType", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));
Object.defineProperty(exports, "getFirstUsableConfig", ({ enumerable: true, get: function () { return load_balancer_1.getFirstUsableConfig; } }));
Object.defineProperty(exports, "validateLoadBalancingConfig", ({ enumerable: true, get: function () { return load_balancer_1.validateLoadBalancingConfig; } }));
var subchannel_1 = __nccwpck_require__(3985);
Object.defineProperty(exports, "subchannelAddressToString", ({ enumerable: true, get: function () { return subchannel_1.subchannelAddressToString; } }));
var load_balancer_child_handler_1 = __nccwpck_require__(5762);
Object.defineProperty(exports, "ChildLoadBalancerHandler", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));
var picker_1 = __nccwpck_require__(3860);
Object.defineProperty(exports, "UnavailablePicker", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));
Object.defineProperty(exports, "QueuePicker", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));
Object.defineProperty(exports, "PickResultType", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));
var filter_1 = __nccwpck_require__(5271);
Object.defineProperty(exports, "BaseFilter", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));
var filter_stack_1 = __nccwpck_require__(8235);
Object.defineProperty(exports, "FilterStackFactory", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));
//# sourceMappingURL=experimental.js.map

/***/ }),

/***/ 8235:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterStackFactory = exports.FilterStack = void 0;
class FilterStack {
    constructor(filters) {
        this.filters = filters;
    }
    sendMetadata(metadata) {
        let result = metadata;
        for (let i = 0; i < this.filters.length; i++) {
            result = this.filters[i].sendMetadata(result);
        }
        return result;
    }
    receiveMetadata(metadata) {
        let result = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveMetadata(result);
        }
        return result;
    }
    sendMessage(message) {
        let result = message;
        for (let i = 0; i < this.filters.length; i++) {
            result = this.filters[i].sendMessage(result);
        }
        return result;
    }
    receiveMessage(message) {
        let result = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveMessage(result);
        }
        return result;
    }
    receiveTrailers(status) {
        let result = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveTrailers(result);
        }
        return result;
    }
}
exports.FilterStack = FilterStack;
class FilterStackFactory {
    constructor(factories) {
        this.factories = factories;
    }
    createFilter(callStream) {
        return new FilterStack(this.factories.map((factory) => factory.createFilter(callStream)));
    }
}
exports.FilterStackFactory = FilterStackFactory;
//# sourceMappingURL=filter-stack.js.map

/***/ }),

/***/ 5271:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseFilter = void 0;
class BaseFilter {
    async sendMetadata(metadata) {
        return metadata;
    }
    receiveMetadata(metadata) {
        return metadata;
    }
    async sendMessage(message) {
        return message;
    }
    async receiveMessage(message) {
        return message;
    }
    receiveTrailers(status) {
        return status;
    }
}
exports.BaseFilter = BaseFilter;
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ 3974:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProxiedConnection = exports.mapProxyName = void 0;
const logging_1 = __nccwpck_require__(8679);
const constants_1 = __nccwpck_require__(9329);
const resolver_1 = __nccwpck_require__(8234);
const http = __nccwpck_require__(8605);
const tls = __nccwpck_require__(4016);
const logging = __nccwpck_require__(8679);
const subchannel_1 = __nccwpck_require__(3985);
const uri_parser_1 = __nccwpck_require__(5562);
const url_1 = __nccwpck_require__(8835);
const TRACER_NAME = 'proxy';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
function getProxyInfo() {
    let proxyEnv = '';
    let envVar = '';
    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
     * fallback behavior can be removed if there's a demand for it.
     */
    if (process.env.grpc_proxy) {
        envVar = 'grpc_proxy';
        proxyEnv = process.env.grpc_proxy;
    }
    else if (process.env.https_proxy) {
        envVar = 'https_proxy';
        proxyEnv = process.env.https_proxy;
    }
    else if (process.env.http_proxy) {
        envVar = 'http_proxy';
        proxyEnv = process.env.http_proxy;
    }
    else {
        return {};
    }
    let proxyUrl;
    try {
        proxyUrl = new url_1.URL(proxyEnv);
    }
    catch (e) {
        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
    }
    if (proxyUrl.protocol !== 'http:') {
        logging_1.log(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
    }
    let userCred = null;
    if (proxyUrl.username) {
        if (proxyUrl.password) {
            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');
            userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        }
        else {
            userCred = proxyUrl.username;
        }
    }
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    /* The proxy URL uses the scheme "http:", which has a default port number of
     * 80. We need to set that explicitly here if it is omitted because otherwise
     * it will use gRPC's default port 443. */
    if (port === '') {
        port = '80';
    }
    const result = {
        address: `${hostname}:${port}`
    };
    if (userCred) {
        result.creds = userCred;
    }
    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
    return result;
}
function getNoProxyHostList() {
    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = 'no_grpc_proxy';
    if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = 'no_proxy';
    }
    if (noProxyStr) {
        trace('No proxy server list set by environment variable ' + envVar);
        return noProxyStr.split(',');
    }
    else {
        return [];
    }
}
function mapProxyName(target, options) {
    var _a;
    const noProxyResult = {
        target: target,
        extraOptions: {},
    };
    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
    }
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) {
        return noProxyResult;
    }
    const hostPort = uri_parser_1.splitHostPort(target.path);
    if (!hostPort) {
        return noProxyResult;
    }
    const serverHost = hostPort.host;
    for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
            trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));
            return noProxyResult;
        }
    }
    const extraOptions = {
        'grpc.http_connect_target': uri_parser_1.uriToString(target),
    };
    if (proxyInfo.creds) {
        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
    }
    return {
        target: {
            scheme: 'dns',
            path: proxyInfo.address,
        },
        extraOptions: extraOptions,
    };
}
exports.mapProxyName = mapProxyName;
function getProxiedConnection(address, channelOptions, connectionOptions) {
    if (!('grpc.http_connect_target' in channelOptions)) {
        return Promise.resolve({});
    }
    const realTarget = channelOptions['grpc.http_connect_target'];
    const parsedTarget = uri_parser_1.parseUri(realTarget);
    if (parsedTarget === null) {
        return Promise.resolve({});
    }
    const options = {
        method: 'CONNECT',
        path: parsedTarget.path,
    };
    // Connect to the subchannel address as a proxy
    if (subchannel_1.isTcpSubchannelAddress(address)) {
        options.host = address.host;
        options.port = address.port;
    }
    else {
        options.socketPath = address.path;
    }
    if ('grpc.http_connect_creds' in channelOptions) {
        options.headers = {
            'Proxy-Authorization': 'Basic ' +
                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64'),
        };
    }
    const proxyAddressString = subchannel_1.subchannelAddressToString(address);
    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
    return new Promise((resolve, reject) => {
        const request = http.request(options);
        request.once('connect', (res, socket, head) => {
            var _a;
            request.removeAllListeners();
            socket.removeAllListeners();
            if (res.statusCode === 200) {
                trace('Successfully connected to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString);
                if ('secureContext' in connectionOptions) {
                    /* The proxy is connecting to a TLS server, so upgrade this socket
                     * connection to a TLS connection.
                     * This is a workaround for https://github.com/nodejs/node/issues/32922
                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
                    const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
                    const hostPort = uri_parser_1.splitHostPort(targetPath);
                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {
                        trace('Successfully established a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString);
                        resolve({ socket: cts, realTarget: parsedTarget });
                    });
                    cts.on('error', () => {
                        reject();
                    });
                }
                else {
                    resolve({
                        socket,
                        realTarget: parsedTarget,
                    });
                }
            }
            else {
                logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString +
                    ' with status ' +
                    res.statusCode);
                reject();
            }
        });
        request.once('error', (err) => {
            request.removeAllListeners();
            logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
                proxyAddressString +
                ' with error ' +
                err.message);
            reject();
        });
        request.end();
    });
}
exports.getProxiedConnection = getProxiedConnection;
//# sourceMappingURL=http_proxy.js.map

/***/ }),

/***/ 3291:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.experimental = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;
const call_credentials_1 = __nccwpck_require__(1018);
Object.defineProperty(exports, "CallCredentials", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));
const channel_1 = __nccwpck_require__(5855);
Object.defineProperty(exports, "connectivityState", ({ enumerable: true, get: function () { return channel_1.ConnectivityState; } }));
Object.defineProperty(exports, "Channel", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));
const channel_credentials_1 = __nccwpck_require__(2258);
Object.defineProperty(exports, "ChannelCredentials", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));
const client_1 = __nccwpck_require__(7650);
Object.defineProperty(exports, "Client", ({ enumerable: true, get: function () { return client_1.Client; } }));
const constants_1 = __nccwpck_require__(9329);
Object.defineProperty(exports, "logVerbosity", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));
Object.defineProperty(exports, "status", ({ enumerable: true, get: function () { return constants_1.Status; } }));
Object.defineProperty(exports, "propagate", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));
const logging = __nccwpck_require__(8679);
const make_client_1 = __nccwpck_require__(4402);
Object.defineProperty(exports, "loadPackageDefinition", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));
Object.defineProperty(exports, "makeClientConstructor", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));
Object.defineProperty(exports, "makeGenericClientConstructor", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));
const metadata_1 = __nccwpck_require__(618);
Object.defineProperty(exports, "Metadata", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));
const server_1 = __nccwpck_require__(7153);
Object.defineProperty(exports, "Server", ({ enumerable: true, get: function () { return server_1.Server; } }));
const server_credentials_1 = __nccwpck_require__(445);
Object.defineProperty(exports, "ServerCredentials", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));
const status_builder_1 = __nccwpck_require__(3053);
Object.defineProperty(exports, "StatusBuilder", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));
/**** Client Credentials ****/
// Using assign only copies enumerable properties, which is what we want
exports.credentials = {
    /**
     * Combine a ChannelCredentials with any number of CallCredentials into a
     * single ChannelCredentials object.
     * @param channelCredentials The ChannelCredentials object.
     * @param callCredentials Any number of CallCredentials objects.
     * @return The resulting ChannelCredentials object.
     */
    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
    },
    /**
     * Combine any number of CallCredentials into a single CallCredentials
     * object.
     * @param first The first CallCredentials object.
     * @param additional Any number of additional CallCredentials objects.
     * @return The resulting CallCredentials object.
     */
    combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
    },
    // from channel-credentials.ts
    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
    // from call-credentials.ts
    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
    createEmpty: call_credentials_1.CallCredentials.createEmpty,
};
/**
 * Close a Client object.
 * @param client The client to close.
 */
exports.closeClient = (client) => client.close();
exports.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
/* eslint-enable @typescript-eslint/no-explicit-any */
/**** Unimplemented function stubs ****/
/* eslint-disable @typescript-eslint/no-explicit-any */
exports.loadObject = (value, options) => {
    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
};
exports.load = (filename, format, options) => {
    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
};
exports.setLogger = (logger) => {
    logging.setLogger(logger);
};
exports.setLogVerbosity = (verbosity) => {
    logging.setLoggerVerbosity(verbosity);
};
exports.getClientChannel = (client) => {
    return client_1.Client.prototype.getChannel.call(client);
};
var client_interceptors_1 = __nccwpck_require__(9221);
Object.defineProperty(exports, "ListenerBuilder", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));
Object.defineProperty(exports, "RequesterBuilder", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));
Object.defineProperty(exports, "InterceptingCall", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));
Object.defineProperty(exports, "InterceptorConfigurationError", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));
const experimental = __nccwpck_require__(158);
exports.experimental = experimental;
const resolver = __nccwpck_require__(8234);
const load_balancer = __nccwpck_require__(2456);
(() => {
    resolver.registerAll();
    load_balancer.registerAll();
})();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5762:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChildLoadBalancerHandler = void 0;
const load_balancer_1 = __nccwpck_require__(2456);
const channel_1 = __nccwpck_require__(5855);
const TYPE_NAME = 'child_load_balancer_helper';
class ChildLoadBalancerHandler {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class {
            constructor(parent) {
                this.parent = parent;
                this.child = null;
            }
            createSubchannel(subchannelAddress, subchannelArgs) {
                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
            }
            updateState(connectivityState, picker) {
                var _a;
                if (this.calledByPendingChild()) {
                    if (connectivityState !== channel_1.ConnectivityState.READY) {
                        return;
                    }
                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.parent.currentChild = this.parent.pendingChild;
                    this.parent.pendingChild = null;
                }
                else if (!this.calledByCurrentChild()) {
                    return;
                }
                this.parent.channelControlHelper.updateState(connectivityState, picker);
            }
            requestReresolution() {
                var _a;
                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
                if (this.child === latestChild) {
                    this.parent.channelControlHelper.requestReresolution();
                }
            }
            setChild(newChild) {
                this.child = newChild;
            }
            calledByPendingChild() {
                return this.child === this.parent.pendingChild;
            }
            calledByCurrentChild() {
                return this.child === this.parent.currentChild;
            }
        };
    }
    /**
     * Prerequisites: lbConfig !== null and lbConfig.name is registered
     * @param addressList
     * @param lbConfig
     * @param attributes
     */
    updateAddressList(addressList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null ||
            this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
            const newHelper = new this.ChildPolicyHelper(this);
            const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
            newHelper.setChild(newChild);
            if (this.currentChild === null) {
                this.currentChild = newChild;
                childToUpdate = this.currentChild;
            }
            else {
                if (this.pendingChild) {
                    this.pendingChild.destroy();
                }
                this.pendingChild = newChild;
                childToUpdate = this.pendingChild;
            }
        }
        else {
            if (this.pendingChild === null) {
                childToUpdate = this.currentChild;
            }
            else {
                childToUpdate = this.pendingChild;
            }
        }
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
    }
    exitIdle() {
        if (this.currentChild) {
            this.currentChild.resetBackoff();
            if (this.pendingChild) {
                this.pendingChild.resetBackoff();
            }
        }
    }
    resetBackoff() {
        if (this.currentChild) {
            this.currentChild.resetBackoff();
            if (this.pendingChild) {
                this.pendingChild.resetBackoff();
            }
        }
    }
    destroy() {
        if (this.currentChild) {
            this.currentChild.destroy();
            this.currentChild = null;
        }
        if (this.pendingChild) {
            this.pendingChild.destroy();
            this.pendingChild = null;
        }
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
//# sourceMappingURL=load-balancer-child-handler.js.map

/***/ }),

/***/ 927:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;
const load_balancer_1 = __nccwpck_require__(2456);
const channel_1 = __nccwpck_require__(5855);
const picker_1 = __nccwpck_require__(3860);
const subchannel_1 = __nccwpck_require__(3985);
const logging = __nccwpck_require__(8679);
const constants_1 = __nccwpck_require__(9329);
const TRACER_NAME = 'pick_first';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'pick_first';
/**
 * Delay after starting a connection on a subchannel before starting a
 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
 */
const CONNECTION_DELAY_INTERVAL_MS = 250;
class PickFirstLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    constructor() { }
    toJsonObject() {
        return {
            [TYPE_NAME]: {}
        };
    }
    static createFromJson(obj) {
        return new PickFirstLoadBalancingConfig();
    }
}
exports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
/**
 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
 * picked subchannel.
 */
class PickFirstPicker {
    constructor(subchannel) {
        this.subchannel = subchannel;
    }
    pick(pickArgs) {
        return {
            pickResultType: picker_1.PickResultType.COMPLETE,
            subchannel: this.subchannel,
            status: null,
            extraFilterFactory: null,
            onCallStarted: null,
        };
    }
}
class PickFirstLoadBalancer {
    /**
     * Load balancer that attempts to connect to each backend in the address list
     * in order, and picks the first one that connects, using it for every
     * request.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     */
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        /**
         * The list of backend addresses most recently passed to `updateAddressList`.
         */
        this.latestAddressList = [];
        /**
         * The list of subchannels this load balancer is currently attempting to
         * connect to.
         */
        this.subchannels = [];
        /**
         * The current connectivity state of the load balancer.
         */
        this.currentState = channel_1.ConnectivityState.IDLE;
        /**
         * The index within the `subchannels` array of the subchannel with the most
         * recently started connection attempt.
         */
        this.currentSubchannelIndex = 0;
        /**
         * The currently picked subchannel used for making calls. Populated if
         * and only if the load balancer's current state is READY. In that case,
         * the subchannel's current state is also READY.
         */
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = {
            [channel_1.ConnectivityState.CONNECTING]: 0,
            [channel_1.ConnectivityState.IDLE]: 0,
            [channel_1.ConnectivityState.READY]: 0,
            [channel_1.ConnectivityState.SHUTDOWN]: 0,
            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
            this.subchannelStateCounts[previousState] -= 1;
            this.subchannelStateCounts[newState] += 1;
            /* If the subchannel we most recently attempted to start connecting
             * to goes into TRANSIENT_FAILURE, immediately try to start
             * connecting to the next one instead of waiting for the connection
             * delay timer. */
            if (subchannel === this.subchannels[this.currentSubchannelIndex] &&
                newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                this.startNextSubchannelConnecting();
            }
            if (newState === channel_1.ConnectivityState.READY) {
                this.pickSubchannel(subchannel);
                return;
            }
            else {
                if (this.triedAllSubchannels &&
                    this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] ===
                        this.subchannels.length) {
                    /* If all of the subchannels are IDLE we should go back to a
                     * basic IDLE state where there is no subchannel list to avoid
                     * holding unused resources */
                    this.resetSubchannelList();
                    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
                    return;
                }
                if (this.currentPick === null) {
                    if (this.triedAllSubchannels) {
                        let newLBState;
                        if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                            newLBState = channel_1.ConnectivityState.CONNECTING;
                        }
                        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] >
                            0) {
                            newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                        }
                        else {
                            newLBState = channel_1.ConnectivityState.IDLE;
                        }
                        if (newLBState !== this.currentState) {
                            if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                                this.updateState(newLBState, new picker_1.UnavailablePicker());
                            }
                            else {
                                this.updateState(newLBState, new picker_1.QueuePicker(this));
                            }
                        }
                    }
                    else {
                        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
                    }
                }
            }
        };
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
            if (newState !== channel_1.ConnectivityState.READY) {
                this.currentPick = null;
                subchannel.unref();
                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
                if (this.subchannels.length > 0) {
                    if (this.triedAllSubchannels) {
                        let newLBState;
                        if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                            newLBState = channel_1.ConnectivityState.CONNECTING;
                        }
                        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] >
                            0) {
                            newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                        }
                        else {
                            newLBState = channel_1.ConnectivityState.IDLE;
                        }
                        if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                            this.updateState(newLBState, new picker_1.UnavailablePicker());
                        }
                        else {
                            this.updateState(newLBState, new picker_1.QueuePicker(this));
                        }
                    }
                    else {
                        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
                    }
                }
                else {
                    /* We don't need to backoff here because this only happens if a
                     * subchannel successfully connects then disconnects, so it will not
                     * create a loop of attempting to connect to an unreachable backend
                     */
                    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
                }
            }
        };
        this.connectionDelayTimeout = setTimeout(() => { }, 0);
        clearTimeout(this.connectionDelayTimeout);
    }
    startNextSubchannelConnecting() {
        if (this.triedAllSubchannels) {
            return;
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
            if (index > this.currentSubchannelIndex) {
                const subchannelState = subchannel.getConnectivityState();
                if (subchannelState === channel_1.ConnectivityState.IDLE ||
                    subchannelState === channel_1.ConnectivityState.CONNECTING) {
                    this.startConnecting(index);
                    return;
                }
            }
        }
        this.triedAllSubchannels = true;
    }
    /**
     * Have a single subchannel in the `subchannels` list start connecting.
     * @param subchannelIndex The index into the `subchannels` list.
     */
    startConnecting(subchannelIndex) {
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() ===
            channel_1.ConnectivityState.IDLE) {
            trace('Start connecting to subchannel with address ' +
                this.subchannels[subchannelIndex].getAddress());
            process.nextTick(() => {
                this.subchannels[subchannelIndex].startConnecting();
            });
        }
        this.connectionDelayTimeout = setTimeout(() => {
            this.startNextSubchannelConnecting();
        }, CONNECTION_DELAY_INTERVAL_MS);
    }
    pickSubchannel(subchannel) {
        trace('Pick subchannel with address ' + subchannel.getAddress());
        if (this.currentPick !== null) {
            this.currentPick.unref();
            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
        this.currentPick = subchannel;
        this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
    }
    updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] +
            ' -> ' +
            channel_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
        for (const subchannel of this.subchannels) {
            subchannel.removeConnectivityStateListener(this.subchannelStateListener);
            subchannel.unref();
        }
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = {
            [channel_1.ConnectivityState.CONNECTING]: 0,
            [channel_1.ConnectivityState.IDLE]: 0,
            [channel_1.ConnectivityState.READY]: 0,
            [channel_1.ConnectivityState.SHUTDOWN]: 0,
            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
        };
        this.subchannels = [];
        this.triedAllSubchannels = false;
    }
    /**
     * Start connecting to the address list most recently passed to
     * `updateAddressList`.
     */
    connectToAddressList() {
        this.resetSubchannelList();
        trace('Connect to address list ' +
            this.latestAddressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
            subchannel.ref();
        }
        for (const subchannel of this.subchannels) {
            subchannel.addConnectivityStateListener(this.subchannelStateListener);
            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
            if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {
                this.pickSubchannel(subchannel);
                this.resetSubchannelList();
                return;
            }
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === channel_1.ConnectivityState.IDLE ||
                subchannelState === channel_1.ConnectivityState.CONNECTING) {
                this.startConnecting(index);
                if (this.currentPick === null) {
                    this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
                }
                return;
            }
        }
        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE
        if (this.currentPick === null) {
            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
    }
    updateAddressList(addressList, lbConfig) {
        // lbConfig has no useful information for pick first load balancing
        /* To avoid unnecessary churn, we only do something with this address list
         * if we're not currently trying to establish a connection, or if the new
         * address list is different from the existing one */
        if (this.subchannels.length === 0 ||
            !this.latestAddressList.every((value, index) => addressList[index] === value)) {
            this.latestAddressList = addressList;
            this.connectToAddressList();
        }
    }
    exitIdle() {
        for (const subchannel of this.subchannels) {
            subchannel.startConnecting();
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
            if (this.latestAddressList.length > 0) {
                this.connectToAddressList();
            }
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE ||
            this.triedAllSubchannels) {
            this.channelControlHelper.requestReresolution();
        }
    }
    resetBackoff() {
        /* The pick first load balancer does not have a connection backoff, so this
         * does nothing */
    }
    destroy() {
        this.resetSubchannelList();
        if (this.currentPick !== null) {
            this.currentPick.unref();
            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.PickFirstLoadBalancer = PickFirstLoadBalancer;
function setup() {
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-pick-first.js.map

/***/ }),

/***/ 2099:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setup = exports.RoundRobinLoadBalancer = void 0;
const load_balancer_1 = __nccwpck_require__(2456);
const channel_1 = __nccwpck_require__(5855);
const picker_1 = __nccwpck_require__(3860);
const subchannel_1 = __nccwpck_require__(3985);
const logging = __nccwpck_require__(8679);
const constants_1 = __nccwpck_require__(9329);
const TRACER_NAME = 'round_robin';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'round_robin';
class RoundRobinLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    constructor() { }
    toJsonObject() {
        return {
            [TYPE_NAME]: {}
        };
    }
    static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
    }
}
class RoundRobinPicker {
    constructor(subchannelList, nextIndex = 0) {
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
    }
    pick(pickArgs) {
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return {
            pickResultType: picker_1.PickResultType.COMPLETE,
            subchannel: pickedSubchannel,
            status: null,
            extraFilterFactory: null,
            onCallStarted: null,
        };
    }
    /**
     * Check what the next subchannel returned would be. Used by the load
     * balancer implementation to preserve this part of the picker state if
     * possible when a subchannel connects or disconnects.
     */
    peekNextSubchannel() {
        return this.subchannelList[this.nextIndex];
    }
}
class RoundRobinLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = {
            [channel_1.ConnectivityState.CONNECTING]: 0,
            [channel_1.ConnectivityState.IDLE]: 0,
            [channel_1.ConnectivityState.READY]: 0,
            [channel_1.ConnectivityState.SHUTDOWN]: 0,
            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
            this.subchannelStateCounts[previousState] -= 1;
            this.subchannelStateCounts[newState] += 1;
            this.calculateAndUpdateState();
            if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE ||
                newState === channel_1.ConnectivityState.IDLE) {
                this.channelControlHelper.requestReresolution();
                subchannel.startConnecting();
            }
        };
    }
    calculateAndUpdateState() {
        if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {
            const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);
            let index = 0;
            if (this.currentReadyPicker !== null) {
                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
                if (index < 0) {
                    index = 0;
                }
            }
            this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));
        }
        else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
        else {
            this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
    }
    updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] +
            ' -> ' +
            channel_1.ConnectivityState[newState]);
        if (newState === channel_1.ConnectivityState.READY) {
            this.currentReadyPicker = picker;
        }
        else {
            this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
        for (const subchannel of this.subchannels) {
            subchannel.removeConnectivityStateListener(this.subchannelStateListener);
            subchannel.unref();
        }
        this.subchannelStateCounts = {
            [channel_1.ConnectivityState.CONNECTING]: 0,
            [channel_1.ConnectivityState.IDLE]: 0,
            [channel_1.ConnectivityState.READY]: 0,
            [channel_1.ConnectivityState.SHUTDOWN]: 0,
            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
        };
        this.subchannels = [];
    }
    updateAddressList(addressList, lbConfig) {
        this.resetSubchannelList();
        trace('Connect to address list ' +
            addressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
            subchannel.ref();
            subchannel.addConnectivityStateListener(this.subchannelStateListener);
            const subchannelState = subchannel.getConnectivityState();
            this.subchannelStateCounts[subchannelState] += 1;
            if (subchannelState === channel_1.ConnectivityState.IDLE ||
                subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                subchannel.startConnecting();
            }
        }
        this.calculateAndUpdateState();
    }
    exitIdle() {
        for (const subchannel of this.subchannels) {
            subchannel.startConnecting();
        }
    }
    resetBackoff() {
        /* The pick first load balancer does not have a connection backoff, so this
         * does nothing */
    }
    destroy() {
        this.resetSubchannelList();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
function setup() {
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-round-robin.js.map

/***/ }),

/***/ 2456:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerAll = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerLoadBalancerType = void 0;
const load_balancer_pick_first = __nccwpck_require__(927);
const load_balancer_round_robin = __nccwpck_require__(2099);
const registeredLoadBalancerTypes = {};
function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
    registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
    };
}
exports.registerLoadBalancerType = registerLoadBalancerType;
function createLoadBalancer(config, channelControlHelper) {
    const typeName = config.getLoadBalancerName();
    if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
    }
    else {
        return null;
    }
}
exports.createLoadBalancer = createLoadBalancer;
function isLoadBalancerNameRegistered(typeName) {
    return typeName in registeredLoadBalancerTypes;
}
exports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
function getFirstUsableConfig(configs, defaultPickFirst = false) {
    for (const config of configs) {
        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {
            return config;
        }
    }
    if (defaultPickFirst) {
        return new load_balancer_pick_first.PickFirstLoadBalancingConfig();
    }
    else {
        return null;
    }
}
exports.getFirstUsableConfig = getFirstUsableConfig;
function validateLoadBalancingConfig(obj) {
    if (!(obj !== null && (typeof obj === 'object'))) {
        throw new Error('Load balancing config must be an object');
    }
    const keys = Object.keys(obj);
    if (keys.length !== 1) {
        throw new Error('Provided load balancing config has multiple conflicting entries');
    }
    const typeName = keys[0];
    if (typeName in registeredLoadBalancerTypes) {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
    }
    else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
    }
}
exports.validateLoadBalancingConfig = validateLoadBalancingConfig;
function registerAll() {
    load_balancer_pick_first.setup();
    load_balancer_round_robin.setup();
}
exports.registerAll = registerAll;
//# sourceMappingURL=load-balancer.js.map

/***/ }),

/***/ 8679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;
const constants_1 = __nccwpck_require__(9329);
let _logger = console;
let _logVerbosity = constants_1.LogVerbosity.ERROR;
const verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';
switch (verbosityString.toUpperCase()) {
    case 'DEBUG':
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
    case 'INFO':
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
    case 'ERROR':
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
    case 'NONE':
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
    default:
    // Ignore any other values
}
exports.getLogger = () => {
    return _logger;
};
exports.setLogger = (logger) => {
    _logger = logger;
};
exports.setLoggerVerbosity = (verbosity) => {
    _logVerbosity = verbosity;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.log = (severity, ...args) => {
    if (severity >= _logVerbosity && typeof _logger.error === 'function') {
        _logger.error(...args);
    }
};
const tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';
const enabledTracers = new Set();
const disabledTracers = new Set();
for (const tracerName of tracersString.split(',')) {
    if (tracerName.startsWith('-')) {
        disabledTracers.add(tracerName.substring(1));
    }
    else {
        enabledTracers.add(tracerName);
    }
}
const allEnabled = enabledTracers.has('all');
function trace(severity, tracer, text) {
    if (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer))) {
        exports.log(severity, new Date().toISOString() + ' | ' + tracer + ' | ' + text);
    }
}
exports.trace = trace;
//# sourceMappingURL=logging.js.map

/***/ }),

/***/ 4402:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPackageDefinition = exports.makeClientConstructor = void 0;
const client_1 = __nccwpck_require__(7650);
/**
 * Map with short names for each of the requester maker functions. Used in
 * makeClientConstructor
 * @private
 */
const requesterFuncs = {
    unary: client_1.Client.prototype.makeUnaryRequest,
    server_stream: client_1.Client.prototype.makeServerStreamRequest,
    client_stream: client_1.Client.prototype.makeClientStreamRequest,
    bidi: client_1.Client.prototype.makeBidiStreamRequest,
};
/**
 * Returns true, if given key is included in the blacklisted
 * keys.
 * @param key key for check, string.
 */
function isPrototypePolluted(key) {
    return ['__proto__', 'prototype', 'constructor'].includes(key);
}
/**
 * Creates a constructor for a client with the given methods, as specified in
 * the methods argument. The resulting class will have an instance method for
 * each method in the service, which is a partial application of one of the
 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
 * arguments predefined.
 * @param methods An object mapping method names to
 *     method attributes
 * @param serviceName The fully qualified name of the service
 * @param classOptions An options object.
 * @return New client constructor, which is a subclass of
 *     {@link grpc.Client}, and has the same arguments as that constructor.
 */
function makeClientConstructor(methods, serviceName, classOptions) {
    if (!classOptions) {
        classOptions = {};
    }
    class ServiceClientImpl extends client_1.Client {
    }
    Object.keys(methods).forEach((name) => {
        if (isPrototypePolluted(name)) {
            return;
        }
        const attrs = methods[name];
        let methodType;
        // TODO(murgatroid99): Verify that we don't need this anymore
        if (typeof name === 'string' && name.charAt(0) === '$') {
            throw new Error('Method names cannot start with $');
        }
        if (attrs.requestStream) {
            if (attrs.responseStream) {
                methodType = 'bidi';
            }
            else {
                methodType = 'client_stream';
            }
        }
        else {
            if (attrs.responseStream) {
                methodType = 'server_stream';
            }
            else {
                methodType = 'unary';
            }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        // Associate all provided attributes with the method
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
            ServiceClientImpl.prototype[attrs.originalName] =
                ServiceClientImpl.prototype[name];
        }
    });
    ServiceClientImpl.service = methods;
    return ServiceClientImpl;
}
exports.makeClientConstructor = makeClientConstructor;
function partial(fn, path, serialize, deserialize) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function (...args) {
        return fn.call(this, path, serialize, deserialize, ...args);
    };
}
function isProtobufTypeDefinition(obj) {
    return 'format' in obj;
}
/**
 * Load a gRPC package definition as a gRPC object hierarchy.
 * @param packageDef The package definition object.
 * @return The resulting gRPC object.
 */
function loadPackageDefinition(packageDef) {
    const result = {};
    for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
            const service = packageDef[serviceFqn];
            const nameComponents = serviceFqn.split('.');
            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
                continue;
            }
            const serviceName = nameComponents[nameComponents.length - 1];
            let current = result;
            for (const packageName of nameComponents.slice(0, -1)) {
                if (!current[packageName]) {
                    current[packageName] = {};
                }
                current = current[packageName];
            }
            if (isProtobufTypeDefinition(service)) {
                current[serviceName] = service;
            }
            else {
                current[serviceName] = makeClientConstructor(service, serviceName, {});
            }
        }
    }
    return result;
}
exports.loadPackageDefinition = loadPackageDefinition;
//# sourceMappingURL=make-client.js.map

/***/ }),

/***/ 1340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;
const filter_1 = __nccwpck_require__(5271);
const constants_1 = __nccwpck_require__(9329);
class MaxMessageSizeFilter extends filter_1.BaseFilter {
    constructor(options, callStream) {
        super();
        this.options = options;
        this.callStream = callStream;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ('grpc.max_send_message_length' in options) {
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
        }
        if ('grpc.max_receive_message_length' in options) {
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
        }
    }
    async sendMessage(message) {
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxSendMessageSize === -1) {
            return message;
        }
        else {
            const concreteMessage = await message;
            if (concreteMessage.message.length > this.maxSendMessageSize) {
                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);
                return Promise.reject('Message too large');
            }
            else {
                return concreteMessage;
            }
        }
    }
    async receiveMessage(message) {
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxReceiveMessageSize === -1) {
            return message;
        }
        else {
            const concreteMessage = await message;
            if (concreteMessage.length > this.maxReceiveMessageSize) {
                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);
                return Promise.reject('Message too large');
            }
            else {
                return concreteMessage;
            }
        }
    }
}
exports.MaxMessageSizeFilter = MaxMessageSizeFilter;
class MaxMessageSizeFilterFactory {
    constructor(options) {
        this.options = options;
    }
    createFilter(callStream) {
        return new MaxMessageSizeFilter(this.options, callStream);
    }
}
exports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
//# sourceMappingURL=max-message-size-filter.js.map

/***/ }),

/***/ 618:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Metadata = void 0;
const logging_1 = __nccwpck_require__(8679);
const constants_1 = __nccwpck_require__(9329);
const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
function isLegalKey(key) {
    return LEGAL_KEY_REGEX.test(key);
}
function isLegalNonBinaryValue(value) {
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
}
function isBinaryKey(key) {
    return key.endsWith('-bin');
}
function isCustomMetadata(key) {
    return !key.startsWith('grpc-');
}
function normalizeKey(key) {
    return key.toLowerCase();
}
function validate(key, value) {
    if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
    }
    if (value !== null && value !== undefined) {
        if (isBinaryKey(key)) {
            if (!(value instanceof Buffer)) {
                throw new Error("keys that end with '-bin' must have Buffer values");
            }
        }
        else {
            if (value instanceof Buffer) {
                throw new Error("keys that don't end with '-bin' must have String values");
            }
            if (!isLegalNonBinaryValue(value)) {
                throw new Error('Metadata string value "' + value + '" contains illegal characters');
            }
        }
    }
}
/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
class Metadata {
    constructor(options) {
        this.internalRepr = new Map();
        if (options === undefined) {
            this.options = {};
        }
        else {
            this.options = options;
        }
    }
    /**
     * Sets the given value for the given key by replacing any other values
     * associated with that key. Normalizes the key.
     * @param key The key to whose value should be set.
     * @param value The value to set. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
    }
    /**
     * Adds the given value for the given key by appending to a list of previous
     * values associated with that key. Normalizes the key.
     * @param key The key for which a new value should be appended.
     * @param value The value to add. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === undefined) {
            this.internalRepr.set(key, [value]);
        }
        else {
            existingValue.push(value);
        }
    }
    /**
     * Removes the given key and any associated values. Normalizes the key.
     * @param key The key whose values should be removed.
     */
    remove(key) {
        key = normalizeKey(key);
        validate(key);
        this.internalRepr.delete(key);
    }
    /**
     * Gets a list of all values associated with the key. Normalizes the key.
     * @param key The key whose value should be retrieved.
     * @return A list of values associated with the given key.
     */
    get(key) {
        key = normalizeKey(key);
        validate(key);
        return this.internalRepr.get(key) || [];
    }
    /**
     * Gets a plain object mapping each key to the first value associated with it.
     * This reflects the most common way that people will want to see metadata.
     * @return A key/value mapping of the metadata.
     */
    getMap() {
        const result = {};
        this.internalRepr.forEach((values, key) => {
            if (values.length > 0) {
                const v = values[0];
                result[key] = v instanceof Buffer ? v.slice() : v;
            }
        });
        return result;
    }
    /**
     * Clones the metadata object.
     * @return The newly cloned object.
     */
    clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        this.internalRepr.forEach((value, key) => {
            const clonedValue = value.map((v) => {
                if (v instanceof Buffer) {
                    return Buffer.from(v);
                }
                else {
                    return v;
                }
            });
            newInternalRepr.set(key, clonedValue);
        });
        return newMetadata;
    }
    /**
     * Merges all key-value pairs from a given Metadata object into this one.
     * If both this object and the given object have values in the same key,
     * values from the other Metadata object will be appended to this object's
     * values.
     * @param other A Metadata object.
     */
    merge(other) {
        other.internalRepr.forEach((values, key) => {
            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
            this.internalRepr.set(key, mergedValue);
        });
    }
    setOptions(options) {
        this.options = options;
    }
    getOptions() {
        return this.options;
    }
    /**
     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
     */
    toHttp2Headers() {
        // NOTE: Node <8.9 formats http2 headers incorrectly.
        const result = {};
        this.internalRepr.forEach((values, key) => {
            // We assume that the user's interaction with this object is limited to
            // through its public API (i.e. keys and values are already validated).
            result[key] = values.map((value) => {
                if (value instanceof Buffer) {
                    return value.toString('base64');
                }
                else {
                    return value;
                }
            });
        });
        return result;
    }
    // For compatibility with the other Metadata implementation
    _getCoreRepresentation() {
        return this.internalRepr;
    }
    /**
     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
     * object.
     * @param headers An IncomingHttpHeaders object.
     */
    static fromHttp2Headers(headers) {
        const result = new Metadata();
        Object.keys(headers).forEach((key) => {
            // Reserved headers (beginning with `:`) are not valid keys.
            if (key.charAt(0) === ':') {
                return;
            }
            const values = headers[key];
            try {
                if (isBinaryKey(key)) {
                    if (Array.isArray(values)) {
                        values.forEach((value) => {
                            result.add(key, Buffer.from(value, 'base64'));
                        });
                    }
                    else if (values !== undefined) {
                        if (isCustomMetadata(key)) {
                            values.split(',').forEach((v) => {
                                result.add(key, Buffer.from(v.trim(), 'base64'));
                            });
                        }
                        else {
                            result.add(key, Buffer.from(values, 'base64'));
                        }
                    }
                }
                else {
                    if (Array.isArray(values)) {
                        values.forEach((value) => {
                            result.add(key, value);
                        });
                    }
                    else if (values !== undefined) {
                        result.add(key, values);
                    }
                }
            }
            catch (error) {
                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
                logging_1.log(constants_1.LogVerbosity.ERROR, message);
            }
        });
        return result;
    }
}
exports.Metadata = Metadata;
//# sourceMappingURL=metadata.js.map

/***/ }),

/***/ 3860:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;
const metadata_1 = __nccwpck_require__(618);
const constants_1 = __nccwpck_require__(9329);
var PickResultType;
(function (PickResultType) {
    PickResultType[PickResultType["COMPLETE"] = 0] = "COMPLETE";
    PickResultType[PickResultType["QUEUE"] = 1] = "QUEUE";
    PickResultType[PickResultType["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
    PickResultType[PickResultType["DROP"] = 3] = "DROP";
})(PickResultType = exports.PickResultType || (exports.PickResultType = {}));
/**
 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
 * state. Always responds to every pick request with an UNAVAILABLE status.
 */
class UnavailablePicker {
    constructor(status) {
        if (status !== undefined) {
            this.status = status;
        }
        else {
            this.status = {
                code: constants_1.Status.UNAVAILABLE,
                details: 'No connection established',
                metadata: new metadata_1.Metadata(),
            };
        }
    }
    pick(pickArgs) {
        return {
            pickResultType: PickResultType.TRANSIENT_FAILURE,
            subchannel: null,
            status: this.status,
            extraFilterFactory: null,
            onCallStarted: null,
        };
    }
}
exports.UnavailablePicker = UnavailablePicker;
/**
 * A standard picker representing a load balancer in the IDLE or CONNECTING
 * state. Always responds to every pick request with a QUEUE pick result
 * indicating that the pick should be tried again with the next `Picker`. Also
 * reports back to the load balancer that a connection should be established
 * once any pick is attempted.
 */
class QueuePicker {
    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
    constructor(loadBalancer) {
        this.loadBalancer = loadBalancer;
        this.calledExitIdle = false;
    }
    pick(pickArgs) {
        if (!this.calledExitIdle) {
            process.nextTick(() => {
                this.loadBalancer.exitIdle();
            });
            this.calledExitIdle = true;
        }
        return {
            pickResultType: PickResultType.QUEUE,
            subchannel: null,
            status: null,
            extraFilterFactory: null,
            onCallStarted: null,
        };
    }
}
exports.QueuePicker = QueuePicker;
//# sourceMappingURL=picker.js.map

/***/ }),

/***/ 1287:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setup = void 0;
const resolver_1 = __nccwpck_require__(8234);
const dns = __nccwpck_require__(881);
const util = __nccwpck_require__(1669);
const service_config_1 = __nccwpck_require__(9634);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const logging = __nccwpck_require__(8679);
const constants_2 = __nccwpck_require__(9329);
const uri_parser_1 = __nccwpck_require__(5562);
const net_1 = __nccwpck_require__(1631);
const TRACER_NAME = 'dns_resolver';
function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
}
/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
const DEFAULT_PORT = 443;
const resolveTxtPromise = util.promisify(dns.resolveTxt);
const dnsLookupPromise = util.promisify(dns.lookup);
/**
 * Merge any number of arrays into a single alternating array
 * @param arrays
 */
function mergeArrays(...arrays) {
    const result = [];
    for (let i = 0; i <
        Math.max.apply(null, arrays.map((array) => array.length)); i++) {
        for (const array of arrays) {
            if (i < array.length) {
                result.push(array[i]);
            }
        }
    }
    return result;
}
/**
 * Resolver implementation that handles DNS names and IP addresses.
 */
class DnsResolver {
    constructor(target, listener, channelOptions) {
        var _a, _b;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));
        const hostPort = uri_parser_1.splitHostPort(target.path);
        if (hostPort === null) {
            this.ipResult = null;
            this.dnsHostname = null;
            this.port = null;
        }
        else {
            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {
                this.ipResult = [
                    {
                        host: hostPort.host,
                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,
                    },
                ];
                this.dnsHostname = null;
                this.port = null;
            }
            else {
                this.ipResult = null;
                this.dnsHostname = hostPort.host;
                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
            }
        }
        this.percentage = Math.random() * 100;
        this.defaultResolutionError = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,
            metadata: new metadata_1.Metadata(),
        };
    }
    /**
     * If the target is an IP address, just provide that address as a result.
     * Otherwise, initiate A, AAAA, and TXT lookups
     */
    startResolution() {
        if (this.ipResult !== null) {
            trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));
            setImmediate(() => {
                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
            });
            return;
        }
        if (this.dnsHostname === null) {
            setImmediate(() => {
                this.listener.onError({
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,
                    metadata: new metadata_1.Metadata(),
                });
            });
        }
        else {
            /* We clear out latestLookupResult here to ensure that it contains the
             * latest result since the last time we started resolving. That way, the
             * TXT resolution handler can use it, but only if it finishes second. We
             * don't clear out any previous service config results because it's
             * better to use a service config that's slightly out of date than to
             * revert to an effectively blank one. */
            this.latestLookupResult = null;
            const hostname = this.dnsHostname;
            /* We lookup both address families here and then split them up later
             * because when looking up a single family, dns.lookup outputs an error
             * if the name exists but there are no records for that family, and that
             * error is indistinguishable from other kinds of errors */
            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
            this.pendingLookupPromise.then((addressList) => {
                this.pendingLookupPromise = null;
                const ip4Addresses = addressList.filter((addr) => addr.family === 4);
                const ip6Addresses = addressList.filter((addr) => addr.family === 6);
                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));
                const allAddressesString = '[' +
                    this.latestLookupResult
                        .map((addr) => addr.host + ':' + addr.port)
                        .join(',') +
                    ']';
                trace('Resolved addresses for target ' +
                    uri_parser_1.uriToString(this.target) +
                    ': ' +
                    allAddressesString);
                if (this.latestLookupResult.length === 0) {
                    this.listener.onError(this.defaultResolutionError);
                    return;
                }
                /* If the TXT lookup has not yet finished, both of the last two
                 * arguments will be null, which is the equivalent of getting an
                 * empty TXT response. When the TXT lookup does finish, its handler
                 * can update the service config by using the same address list */
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
            }, (err) => {
                trace('Resolution error for target ' +
                    uri_parser_1.uriToString(this.target) +
                    ': ' +
                    err.message);
                this.pendingLookupPromise = null;
                this.listener.onError(this.defaultResolutionError);
            });
            /* If there already is a still-pending TXT resolution, we can just use
             * that result when it comes in */
            if (this.pendingTxtPromise === null) {
                /* We handle the TXT query promise differently than the others because
                 * the name resolution attempt as a whole is a success even if the TXT
                 * lookup fails */
                this.pendingTxtPromise = resolveTxtPromise(hostname);
                this.pendingTxtPromise.then((txtRecord) => {
                    this.pendingTxtPromise = null;
                    try {
                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);
                    }
                    catch (err) {
                        this.latestServiceConfigError = {
                            code: constants_1.Status.UNAVAILABLE,
                            details: 'Parsing service config failed',
                            metadata: new metadata_1.Metadata(),
                        };
                    }
                    if (this.latestLookupResult !== null) {
                        /* We rely here on the assumption that calling this function with
                         * identical parameters will be essentialy idempotent, and calling
                         * it with the same address list and a different service config
                         * should result in a fast and seamless switchover. */
                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
                    }
                }, (err) => {
                    /* If TXT lookup fails we should do nothing, which means that we
                     * continue to use the result of the most recent successful lookup,
                     * or the default null config object if there has never been a
                     * successful lookup. We do not set the latestServiceConfigError
                     * here because that is specifically used for response validation
                     * errors. We still need to handle this error so that it does not
                     * bubble up as an unhandled promise rejection. */
                });
            }
        }
    }
    updateResolution() {
        trace('Resolution update requested for target ' + uri_parser_1.uriToString(this.target));
        if (this.pendingLookupPromise === null) {
            this.startResolution();
        }
    }
    destroy() {
        /* Do nothing. There is not a practical way to cancel in-flight DNS
         * requests, and after this function is called we can expect that
         * updateResolution will not be called again. */
    }
    /**
     * Get the default authority for the given target. For IP targets, that is
     * the IP address. For DNS targets, it is the hostname.
     * @param target
     */
    static getDefaultAuthority(target) {
        return target.path;
    }
}
/**
 * Set up the DNS resolver class by registering it as the handler for the
 * "dns:" prefix and as the default resolver.
 */
function setup() {
    resolver_1.registerResolver('dns', DnsResolver);
    resolver_1.registerDefaultScheme('dns');
}
exports.setup = setup;
//# sourceMappingURL=resolver-dns.js.map

/***/ }),

/***/ 6786:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setup = void 0;
const net_1 = __nccwpck_require__(1631);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const resolver_1 = __nccwpck_require__(8234);
const uri_parser_1 = __nccwpck_require__(5562);
const logging = __nccwpck_require__(8679);
const TRACER_NAME = 'ip_resolver';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const IPV4_SCHEME = 'ipv4';
const IPV6_SCHEME = 'ipv6';
/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
const DEFAULT_PORT = 443;
class IpResolver {
    constructor(target, listener, channelOptions) {
        var _a;
        this.target = target;
        this.listener = listener;
        this.addresses = [];
        this.error = null;
        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
            this.error = {
                code: constants_1.Status.UNAVAILABLE,
                details: `Unrecognized scheme ${target.scheme} in IP resolver`,
                metadata: new metadata_1.Metadata()
            };
            return;
        }
        const pathList = target.path.split(',');
        for (const path of pathList) {
            const hostPort = uri_parser_1.splitHostPort(path);
            if (hostPort === null) {
                this.error = {
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse ${target.scheme} address ${path}`,
                    metadata: new metadata_1.Metadata()
                };
                return;
            }
            if ((target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host)) || (target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host))) {
                this.error = {
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse ${target.scheme} address ${path}`,
                    metadata: new metadata_1.Metadata()
                };
                return;
            }
            addresses.push({
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
            });
        }
        this.addresses = addresses;
        trace('Parsed ' + target.scheme + ' address list ' + this.addresses);
    }
    updateResolution() {
        process.nextTick(() => {
            if (this.error) {
                this.listener.onError(this.error);
            }
            else {
                this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});
            }
        });
    }
    destroy() {
        // This resolver owns no resources, so we do nothing here.
    }
    static getDefaultAuthority(target) {
        return target.path.split(',')[0];
    }
}
function setup() {
    resolver_1.registerResolver(IPV4_SCHEME, IpResolver);
    resolver_1.registerResolver(IPV6_SCHEME, IpResolver);
}
exports.setup = setup;
//# sourceMappingURL=resolver-ip.js.map

/***/ }),

/***/ 6565:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setup = void 0;
const resolver_1 = __nccwpck_require__(8234);
class UdsResolver {
    constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.addresses = [];
        let path;
        if (target.authority === '') {
            path = '/' + target.path;
        }
        else {
            path = target.path;
        }
        this.addresses = [{ path }];
    }
    updateResolution() {
        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});
    }
    destroy() {
        // This resolver owns no resources, so we do nothing here.
    }
    static getDefaultAuthority(target) {
        return 'localhost';
    }
}
function setup() {
    resolver_1.registerResolver('unix', UdsResolver);
}
exports.setup = setup;
//# sourceMappingURL=resolver-uds.js.map

/***/ }),

/***/ 8234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerAll = exports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;
const resolver_dns = __nccwpck_require__(1287);
const resolver_uds = __nccwpck_require__(6565);
const resolver_ip = __nccwpck_require__(6786);
const uri_parser_1 = __nccwpck_require__(5562);
const registeredResolvers = {};
let defaultScheme = null;
/**
 * Register a resolver class to handle target names prefixed with the `prefix`
 * string. This prefix should correspond to a URI scheme name listed in the
 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 * @param prefix
 * @param resolverClass
 */
function registerResolver(scheme, resolverClass) {
    registeredResolvers[scheme] = resolverClass;
}
exports.registerResolver = registerResolver;
/**
 * Register a default resolver to handle target names that do not start with
 * any registered prefix.
 * @param resolverClass
 */
function registerDefaultScheme(scheme) {
    defaultScheme = scheme;
}
exports.registerDefaultScheme = registerDefaultScheme;
/**
 * Create a name resolver for the specified target, if possible. Throws an
 * error if no such name resolver can be created.
 * @param target
 * @param listener
 */
function createResolver(target, listener, options) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
    }
    else {
        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);
    }
}
exports.createResolver = createResolver;
/**
 * Get the default authority for the specified target, if possible. Throws an
 * error if no registered name resolver can parse that target string.
 * @param target
 */
function getDefaultAuthority(target) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
    }
    else {
        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);
    }
}
exports.getDefaultAuthority = getDefaultAuthority;
function mapUriDefaultScheme(target) {
    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
            return {
                scheme: defaultScheme,
                authority: undefined,
                path: uri_parser_1.uriToString(target),
            };
        }
        else {
            return null;
        }
    }
    return target;
}
exports.mapUriDefaultScheme = mapUriDefaultScheme;
function registerAll() {
    resolver_dns.setup();
    resolver_uds.setup();
    resolver_ip.setup();
}
exports.registerAll = registerAll;
//# sourceMappingURL=resolver.js.map

/***/ }),

/***/ 5294:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResolvingLoadBalancer = void 0;
const load_balancer_1 = __nccwpck_require__(2456);
const service_config_1 = __nccwpck_require__(9634);
const channel_1 = __nccwpck_require__(5855);
const resolver_1 = __nccwpck_require__(8234);
const picker_1 = __nccwpck_require__(3860);
const backoff_timeout_1 = __nccwpck_require__(8048);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const logging = __nccwpck_require__(8679);
const constants_2 = __nccwpck_require__(9329);
const uri_parser_1 = __nccwpck_require__(5562);
const load_balancer_child_handler_1 = __nccwpck_require__(5762);
const TRACER_NAME = 'resolving_load_balancer';
function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const DEFAULT_LOAD_BALANCER_NAME = 'pick_first';
function getDefaultConfigSelector(serviceConfig) {
    return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split('/').filter(x => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';
        if (serviceConfig && serviceConfig.methodConfig) {
            for (const methodConfig of serviceConfig.methodConfig) {
                for (const name of methodConfig.name) {
                    if (name.service === service && (name.method === undefined || name.method === method)) {
                        return {
                            methodConfig: methodConfig,
                            pickInformation: {},
                            status: constants_1.Status.OK
                        };
                    }
                }
            }
        }
        return {
            methodConfig: { name: [] },
            pickInformation: {},
            status: constants_1.Status.OK
        };
    };
}
class ResolvingLoadBalancer {
    /**
     * Wrapper class that behaves like a `LoadBalancer` and also handles name
     * resolution internally.
     * @param target The address of the backend to connect to.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     * @param defaultServiceConfig The default service configuration to be used
     *     if none is provided by the name resolver. A `null` value indicates
     *     that the default behavior should be the default unconfigured behavior.
     *     In practice, that means using the "pick first" load balancer
     *     implmentation
     */
    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.channelOptions = channelOptions;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = channel_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        /**
         * This resolving load balancer's current connectivity state.
         */
        this.currentState = channel_1.ConnectivityState.IDLE;
        /**
         * The service config object from the last successful resolution, if
         * available. A value of null indicates that we have not yet received a valid
         * service config from the resolver.
         */
        this.previousServiceConfig = null;
        /**
         * Indicates whether we should attempt to resolve again after the backoff
         * timer runs out.
         */
        this.continueResolving = false;
        if (channelOptions['grpc.service_config']) {
            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));
        }
        else {
            this.defaultServiceConfig = {
                loadBalancingConfig: [],
                methodConfig: [],
            };
        }
        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
            requestReresolution: () => {
                /* If the backoffTimeout is running, we're still backing off from
                 * making resolve requests, so we shouldn't make another one here.
                 * In that case, the backoff timer callback will call
                 * updateResolution */
                if (this.backoffTimeout.isRunning()) {
                    this.continueResolving = true;
                }
                else {
                    this.updateResolution();
                }
            },
            updateState: (newState, picker) => {
                this.latestChildState = newState;
                this.latestChildPicker = picker;
                this.updateState(newState, picker);
            },
        });
        this.innerResolver = resolver_1.createResolver(target, {
            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {
                var _a;
                let workingServiceConfig = null;
                /* This first group of conditionals implements the algorithm described
                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
                 * in the section called "Behavior on receiving a new gRPC Config".
                 */
                if (serviceConfig === null) {
                    // Step 4 and 5
                    if (serviceConfigError === null) {
                        // Step 5
                        this.previousServiceConfig = null;
                        workingServiceConfig = this.defaultServiceConfig;
                    }
                    else {
                        // Step 4
                        if (this.previousServiceConfig === null) {
                            // Step 4.ii
                            this.handleResolutionFailure(serviceConfigError);
                        }
                        else {
                            // Step 4.i
                            workingServiceConfig = this.previousServiceConfig;
                        }
                    }
                }
                else {
                    // Step 3
                    workingServiceConfig = serviceConfig;
                    this.previousServiceConfig = serviceConfig;
                }
                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);
                if (loadBalancingConfig === null) {
                    // There were load balancing configs but none are supported. This counts as a resolution failure
                    this.handleResolutionFailure({
                        code: constants_1.Status.UNAVAILABLE,
                        details: 'All load balancer options in service config are not compatible',
                        metadata: new metadata_1.Metadata(),
                    });
                    return;
                }
                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
            },
            onError: (error) => {
                this.handleResolutionFailure(error);
            },
        }, channelOptions);
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
            if (this.continueResolving) {
                this.updateResolution();
                this.continueResolving = false;
            }
            else {
                this.updateState(this.latestChildState, this.latestChildPicker);
            }
        });
        this.backoffTimeout.unref();
    }
    updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
    }
    updateState(connectivityState, picker) {
        trace(uri_parser_1.uriToString(this.target) +
            ' ' +
            channel_1.ConnectivityState[this.currentState] +
            ' -> ' +
            channel_1.ConnectivityState[connectivityState]);
        // Ensure that this.exitIdle() is called by the picker
        if (connectivityState === channel_1.ConnectivityState.IDLE) {
            picker = new picker_1.QueuePicker(this);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
    }
    handleResolutionFailure(error) {
        if (this.latestChildState === channel_1.ConnectivityState.IDLE) {
            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
            this.onFailedResolution(error);
        }
        this.backoffTimeout.runOnce();
    }
    exitIdle() {
        this.childLoadBalancer.exitIdle();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
            if (this.backoffTimeout.isRunning()) {
                this.continueResolving = true;
            }
            else {
                this.updateResolution();
            }
            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
    }
    updateAddressList(addressList, lbConfig) {
        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
    }
    resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
    }
    destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
    }
    getTypeName() {
        return 'resolving_load_balancer';
    }
}
exports.ResolvingLoadBalancer = ResolvingLoadBalancer;
//# sourceMappingURL=resolving-load-balancer.js.map

/***/ }),

/***/ 7218:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;
const events_1 = __nccwpck_require__(8614);
const http2 = __nccwpck_require__(7565);
const stream_1 = __nccwpck_require__(5794);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const stream_decoder_1 = __nccwpck_require__(5898);
const logging = __nccwpck_require__(8679);
const TRACER_NAME = 'server_call';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
const GRPC_ENCODING_HEADER = 'grpc-encoding';
const GRPC_MESSAGE_HEADER = 'grpc-message';
const GRPC_STATUS_HEADER = 'grpc-status';
const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
const deadlineUnitsToMs = {
    H: 3600000,
    M: 60000,
    S: 1000,
    m: 1,
    u: 0.001,
    n: 0.000001,
};
const defaultResponseHeaders = {
    // TODO(cjihrig): Remove these encoding headers from the default response
    // once compression is integrated.
    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity',
    [GRPC_ENCODING_HEADER]: 'identity',
    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
};
const defaultResponseOptions = {
    waitForTrailers: true,
};
class ServerUnaryCallImpl extends events_1.EventEmitter {
    constructor(call, metadata, request) {
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
}
exports.ServerUnaryCallImpl = ServerUnaryCallImpl;
class ServerReadableStreamImpl extends stream_1.Readable {
    constructor(call, metadata, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
    }
    _read(size) {
        if (!this.call.consumeUnpushedMessages(this)) {
            return;
        }
        this.call.resume();
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
}
exports.ServerReadableStreamImpl = ServerReadableStreamImpl;
class ServerWritableStreamImpl extends stream_1.Writable {
    constructor(call, metadata, serialize, request) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on('error', (err) => {
            this.call.sendError(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        try {
            const response = this.call.serializeMessage(chunk);
            if (!this.call.write(response)) {
                this.call.once('drain', callback);
                return;
            }
        }
        catch (err) {
            err.code = constants_1.Status.INTERNAL;
            this.emit('error', err);
        }
        callback();
    }
    _final(callback) {
        this.call.sendStatus({
            code: constants_1.Status.OK,
            details: 'OK',
            metadata: this.trailingMetadata,
        });
        callback(null);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        super.end();
    }
}
exports.ServerWritableStreamImpl = ServerWritableStreamImpl;
class ServerDuplexStreamImpl extends stream_1.Duplex {
    constructor(call, metadata, serialize, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
        this.on('error', (err) => {
            this.call.sendError(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        super.end();
    }
}
exports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
ServerDuplexStreamImpl.prototype._read =
    ServerReadableStreamImpl.prototype._read;
ServerDuplexStreamImpl.prototype._write =
    ServerWritableStreamImpl.prototype._write;
ServerDuplexStreamImpl.prototype._final =
    ServerWritableStreamImpl.prototype._final;
ServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;
// Internal class that wraps the HTTP2 request.
class Http2ServerCallStream extends events_1.EventEmitter {
    constructor(stream, handler, options) {
        super();
        this.stream = stream;
        this.handler = handler;
        this.options = options;
        this.cancelled = false;
        this.deadlineTimer = setTimeout(() => { }, 0);
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once('error', (err) => {
            /* We need an error handler to avoid uncaught error event exceptions, but
             * there is nothing we can reasonably do here. Any error event should
             * have a corresponding close event, which handles emitting the cancelled
             * event. And the stream is now in a bad state, so we can't reasonably
             * expect to be able to send an error over it. */
        });
        this.stream.once('close', () => {
            var _a;
            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
                ' stream closed with rstCode ' +
                this.stream.rstCode);
            this.cancelled = true;
            this.emit('cancelled', 'cancelled');
        });
        this.stream.on('drain', () => {
            this.emit('drain');
        });
        if ('grpc.max_send_message_length' in options) {
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
        }
        if ('grpc.max_receive_message_length' in options) {
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
        }
        // Clear noop timer
        clearTimeout(this.deadlineTimer);
    }
    checkCancelled() {
        /* In some cases the stream can become destroyed before the close event
         * fires. That creates a race condition that this check works around */
        if (this.stream.destroyed) {
            this.cancelled = true;
        }
        return this.cancelled;
    }
    sendMetadata(customMetadata) {
        if (this.checkCancelled()) {
            return;
        }
        if (this.metadataSent) {
            return;
        }
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        // TODO(cjihrig): Include compression headers.
        const headers = Object.assign({}, defaultResponseHeaders, custom);
        this.stream.respond(headers, defaultResponseOptions);
    }
    receiveMetadata(headers) {
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        // TODO(cjihrig): Receive compression metadata.
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
            if (match === null) {
                const err = new Error('Invalid deadline');
                err.code = constants_1.Status.OUT_OF_RANGE;
                this.sendError(err);
                return;
            }
            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
            const now = new Date();
            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
            metadata.remove(GRPC_TIMEOUT_HEADER);
        }
        // Remove several headers that should not be propagated to the application
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove('grpc-encoding');
        metadata.remove('grpc-accept-encoding');
        return metadata;
    }
    receiveUnaryMessage() {
        return new Promise((resolve, reject) => {
            const stream = this.stream;
            const chunks = [];
            let totalLength = 0;
            stream.on('data', (data) => {
                chunks.push(data);
                totalLength += data.byteLength;
            });
            stream.once('end', async () => {
                try {
                    const requestBytes = Buffer.concat(chunks, totalLength);
                    if (this.maxReceiveMessageSize !== -1 &&
                        requestBytes.length > this.maxReceiveMessageSize) {
                        this.sendError({
                            code: constants_1.Status.RESOURCE_EXHAUSTED,
                            details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`,
                        });
                        resolve();
                    }
                    resolve(this.deserializeMessage(requestBytes));
                }
                catch (err) {
                    err.code = constants_1.Status.INTERNAL;
                    this.sendError(err);
                    resolve();
                }
            });
        });
    }
    serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        // TODO(cjihrig): Call compression aware serializeMessage().
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    deserializeMessage(bytes) {
        // TODO(cjihrig): Call compression aware deserializeMessage().
        const receivedMessage = bytes.slice(5);
        return this.handler.deserialize(receivedMessage);
    }
    async sendUnaryMessage(err, value, metadata, flags) {
        if (this.checkCancelled()) {
            return;
        }
        if (!metadata) {
            metadata = new metadata_1.Metadata();
        }
        if (err) {
            if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {
                err.metadata = metadata;
            }
            this.sendError(err);
            return;
        }
        try {
            const response = this.serializeMessage(value);
            this.write(response);
            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });
        }
        catch (err) {
            err.code = constants_1.Status.INTERNAL;
            this.sendError(err);
        }
    }
    sendStatus(statusObj) {
        var _a;
        if (this.checkCancelled()) {
            return;
        }
        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
            ' ended with status code: ' +
            constants_1.Status[statusObj.code] +
            ' details: ' +
            statusObj.details);
        clearTimeout(this.deadlineTimer);
        if (!this.wantTrailers) {
            this.wantTrailers = true;
            this.stream.once('wantTrailers', () => {
                const trailersToSend = Object.assign({
                    [GRPC_STATUS_HEADER]: statusObj.code,
                    [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),
                }, statusObj.metadata.toHttp2Headers());
                this.stream.sendTrailers(trailersToSend);
            });
            this.sendMetadata();
            this.stream.end();
        }
    }
    sendError(error) {
        if (this.checkCancelled()) {
            return;
        }
        const status = {
            code: constants_1.Status.UNKNOWN,
            details: 'message' in error ? error.message : 'Unknown Error',
            metadata: 'metadata' in error && error.metadata !== undefined
                ? error.metadata
                : new metadata_1.Metadata(),
        };
        if ('code' in error &&
            typeof error.code === 'number' &&
            Number.isInteger(error.code)) {
            status.code = error.code;
            if ('details' in error && typeof error.details === 'string') {
                status.details = error.details;
            }
        }
        this.sendStatus(status);
    }
    write(chunk) {
        if (this.checkCancelled()) {
            return;
        }
        if (this.maxSendMessageSize !== -1 &&
            chunk.length > this.maxSendMessageSize) {
            this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,
            });
            return;
        }
        this.sendMetadata();
        return this.stream.write(chunk);
    }
    resume() {
        this.stream.resume();
    }
    setupSurfaceCall(call) {
        this.once('cancelled', (reason) => {
            call.cancelled = true;
            call.emit('cancelled', reason);
        });
    }
    setupReadable(readable) {
        const decoder = new stream_decoder_1.StreamDecoder();
        this.stream.on('data', async (data) => {
            const messages = decoder.write(data);
            for (const message of messages) {
                if (this.maxReceiveMessageSize !== -1 &&
                    message.length > this.maxReceiveMessageSize) {
                    this.sendError({
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,
                    });
                    return;
                }
                this.pushOrBufferMessage(readable, message);
            }
        });
        this.stream.once('end', () => {
            this.pushOrBufferMessage(readable, null);
        });
    }
    consumeUnpushedMessages(readable) {
        this.canPush = true;
        while (this.messagesToPush.length > 0) {
            const nextMessage = this.messagesToPush.shift();
            const canPush = readable.push(nextMessage);
            if (nextMessage === null || canPush === false) {
                this.canPush = false;
                break;
            }
        }
        return this.canPush;
    }
    pushOrBufferMessage(readable, messageBytes) {
        if (this.isPushPending) {
            this.bufferedMessages.push(messageBytes);
        }
        else {
            this.pushMessage(readable, messageBytes);
        }
    }
    async pushMessage(readable, messageBytes) {
        if (messageBytes === null) {
            if (this.canPush) {
                readable.push(null);
            }
            else {
                this.messagesToPush.push(null);
            }
            return;
        }
        this.isPushPending = true;
        try {
            const deserialized = await this.deserializeMessage(messageBytes);
            if (this.canPush) {
                if (!readable.push(deserialized)) {
                    this.canPush = false;
                    this.stream.pause();
                }
            }
            else {
                this.messagesToPush.push(deserialized);
            }
        }
        catch (error) {
            // Ignore any remaining messages when errors occur.
            this.bufferedMessages.length = 0;
            if (!('code' in error &&
                typeof error.code === 'number' &&
                Number.isInteger(error.code) &&
                error.code >= constants_1.Status.OK &&
                error.code <= constants_1.Status.UNAUTHENTICATED)) {
                // The error code is not a valid gRPC code so its being overwritten.
                error.code = constants_1.Status.INTERNAL;
            }
            readable.emit('error', error);
        }
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) {
            this.pushMessage(readable, this.bufferedMessages.shift());
        }
    }
    getPeer() {
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) {
            if (socket.remotePort) {
                return `${socket.remoteAddress}:${socket.remotePort}`;
            }
            else {
                return socket.remoteAddress;
            }
        }
        else {
            return 'unknown';
        }
    }
    getDeadline() {
        return this.deadline;
    }
}
exports.Http2ServerCallStream = Http2ServerCallStream;
function handleExpiredDeadline(call) {
    const err = new Error('Deadline exceeded');
    err.code = constants_1.Status.DEADLINE_EXCEEDED;
    call.sendError(err);
    call.cancelled = true;
    call.emit('cancelled', 'deadline');
}
//# sourceMappingURL=server-call.js.map

/***/ }),

/***/ 445:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerCredentials = void 0;
const tls_helpers_1 = __nccwpck_require__(3570);
class ServerCredentials {
    static createInsecure() {
        return new InsecureServerCredentials();
    }
    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
            throw new TypeError('rootCerts must be null or a Buffer');
        }
        if (!Array.isArray(keyCertPairs)) {
            throw new TypeError('keyCertPairs must be an array');
        }
        if (typeof checkClientCertificate !== 'boolean') {
            throw new TypeError('checkClientCertificate must be a boolean');
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
            const pair = keyCertPairs[i];
            if (pair === null || typeof pair !== 'object') {
                throw new TypeError(`keyCertPair[${i}] must be an object`);
            }
            if (!Buffer.isBuffer(pair.private_key)) {
                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
            }
            if (!Buffer.isBuffer(pair.cert_chain)) {
                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
            }
            cert.push(pair.cert_chain);
            key.push(pair.private_key);
        }
        return new SecureServerCredentials({
            ca: rootCerts || tls_helpers_1.getDefaultRootsData() || undefined,
            cert,
            key,
            requestCert: checkClientCertificate,
            ciphers: tls_helpers_1.CIPHER_SUITES,
        });
    }
}
exports.ServerCredentials = ServerCredentials;
class InsecureServerCredentials extends ServerCredentials {
    _isSecure() {
        return false;
    }
    _getSettings() {
        return null;
    }
}
class SecureServerCredentials extends ServerCredentials {
    constructor(options) {
        super();
        this.options = options;
    }
    _isSecure() {
        return true;
    }
    _getSettings() {
        return this.options;
    }
}
//# sourceMappingURL=server-credentials.js.map

/***/ }),

/***/ 7153:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Server = void 0;
const http2 = __nccwpck_require__(7565);
const constants_1 = __nccwpck_require__(9329);
const metadata_1 = __nccwpck_require__(618);
const server_call_1 = __nccwpck_require__(7218);
const resolver_1 = __nccwpck_require__(8234);
const logging = __nccwpck_require__(8679);
const subchannel_1 = __nccwpck_require__(3985);
const uri_parser_1 = __nccwpck_require__(5562);
const TRACER_NAME = 'server';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
function noop() { }
function getUnimplementedStatusResponse(methodName) {
    return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
        metadata: new metadata_1.Metadata(),
    };
}
function getDefaultHandler(handlerType, methodName) {
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) {
        case 'unary':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'clientStream':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'serverStream':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        case 'bidi':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        default:
            throw new Error(`Invalid handlerType ${handlerType}`);
    }
}
class Server {
    constructor(options) {
        this.http2ServerList = [];
        this.handlers = new Map();
        this.sessions = new Set();
        this.started = false;
        this.options = options !== null && options !== void 0 ? options : {};
    }
    addProtoService() {
        throw new Error('Not implemented. Use addService() instead');
    }
    addService(service, implementation) {
        if (service === null ||
            typeof service !== 'object' ||
            implementation === null ||
            typeof implementation !== 'object') {
            throw new Error('addService() requires two objects as arguments');
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
            throw new Error('Cannot add an empty service to a server');
        }
        serviceKeys.forEach((name) => {
            const attrs = service[name];
            let methodType;
            if (attrs.requestStream) {
                if (attrs.responseStream) {
                    methodType = 'bidi';
                }
                else {
                    methodType = 'clientStream';
                }
            }
            else {
                if (attrs.responseStream) {
                    methodType = 'serverStream';
                }
                else {
                    methodType = 'unary';
                }
            }
            let implFn = implementation[name];
            let impl;
            if (implFn === undefined && typeof attrs.originalName === 'string') {
                implFn = implementation[attrs.originalName];
            }
            if (implFn !== undefined) {
                impl = implFn.bind(implementation);
            }
            else {
                impl = getDefaultHandler(methodType, name);
            }
            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
            if (success === false) {
                throw new Error(`Method handler for ${attrs.path} already provided.`);
            }
        });
    }
    removeService(service) {
        if (service === null ||
            typeof service !== 'object') {
            throw new Error('removeService() requires object as argument');
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name) => {
            const attrs = service[name];
            this.unregister(attrs.path);
        });
    }
    bind(port, creds) {
        throw new Error('Not implemented. Use bindAsync() instead');
    }
    bindAsync(port, creds, callback) {
        if (this.started === true) {
            throw new Error('server is already started');
        }
        if (typeof port !== 'string') {
            throw new TypeError('port must be a string');
        }
        if (creds === null || typeof creds !== 'object') {
            throw new TypeError('creds must be an object');
        }
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
        }
        const initialPortUri = uri_parser_1.parseUri(port);
        if (initialPortUri === null) {
            throw new Error(`Could not parse port "${port}"`);
        }
        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
        if (portUri === null) {
            throw new Error(`Could not get a default scheme for port "${port}"`);
        }
        const serverOptions = {
            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ('grpc-node.max_session_memory' in this.options) {
            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];
        }
        if ('grpc.max_concurrent_streams' in this.options) {
            serverOptions.settings = {
                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
            };
        }
        const setupServer = () => {
            let http2Server;
            if (creds._isSecure()) {
                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
                http2Server = http2.createSecureServer(secureServerOptions);
            }
            else {
                http2Server = http2.createServer(serverOptions);
            }
            http2Server.setTimeout(0, noop);
            this._setupHandlers(http2Server);
            return http2Server;
        };
        const bindSpecificPort = (addressList, portNum, previousCount) => {
            if (addressList.length === 0) {
                return Promise.resolve({ port: portNum, count: previousCount });
            }
            return Promise.all(addressList.map((address) => {
                trace('Attempting to bind ' + subchannel_1.subchannelAddressToString(address));
                let addr;
                if (subchannel_1.isTcpSubchannelAddress(address)) {
                    addr = {
                        host: address.host,
                        port: portNum,
                    };
                }
                else {
                    addr = address;
                }
                const http2Server = setupServer();
                return new Promise((resolve, reject) => {
                    function onError(err) {
                        resolve(err);
                    }
                    http2Server.once('error', onError);
                    http2Server.listen(addr, () => {
                        trace('Successfully bound ' + subchannel_1.subchannelAddressToString(address));
                        this.http2ServerList.push(http2Server);
                        const boundAddress = http2Server.address();
                        if (typeof boundAddress === 'string') {
                            resolve(portNum);
                        }
                        else {
                            resolve(boundAddress.port);
                        }
                        http2Server.removeListener('error', onError);
                    });
                });
            })).then((results) => {
                let count = 0;
                for (const result of results) {
                    if (typeof result === 'number') {
                        count += 1;
                        if (result !== portNum) {
                            throw new Error('Invalid state: multiple port numbers added from single address');
                        }
                    }
                }
                return {
                    port: portNum,
                    count: count + previousCount,
                };
            });
        };
        const bindWildcardPort = (addressList) => {
            if (addressList.length === 0) {
                return Promise.resolve({ port: 0, count: 0 });
            }
            const address = addressList[0];
            const http2Server = setupServer();
            return new Promise((resolve, reject) => {
                function onError(err) {
                    resolve(bindWildcardPort(addressList.slice(1)));
                }
                http2Server.once('error', onError);
                http2Server.listen(address, () => {
                    this.http2ServerList.push(http2Server);
                    resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));
                    http2Server.removeListener('error', onError);
                });
            });
        };
        const resolverListener = {
            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
                // We only want one resolution result. Discard all future results
                resolverListener.onSuccessfulResolution = () => { };
                if (addressList.length === 0) {
                    callback(new Error(`No addresses resolved for port ${port}`), 0);
                    return;
                }
                let bindResultPromise;
                if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {
                    if (addressList[0].port === 0) {
                        bindResultPromise = bindWildcardPort(addressList);
                    }
                    else {
                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
                    }
                }
                else {
                    // Use an arbitrary non-zero port for non-TCP addresses
                    bindResultPromise = bindSpecificPort(addressList, 1, 0);
                }
                bindResultPromise.then((bindResult) => {
                    if (bindResult.count === 0) {
                        const errorString = `No address added out of total ${addressList.length} resolved`;
                        logging.log(constants_1.LogVerbosity.ERROR, errorString);
                        callback(new Error(errorString), 0);
                    }
                    else {
                        if (bindResult.count < addressList.length) {
                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                        }
                        callback(null, bindResult.port);
                    }
                }, (error) => {
                    const errorString = `No address added out of total ${addressList.length} resolved`;
                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
                    callback(new Error(errorString), 0);
                });
            },
            onError: (error) => {
                callback(new Error(error.details), 0);
            },
        };
        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
        resolver.updateResolution();
    }
    forceShutdown() {
        // Close the server if it is still running.
        for (const http2Server of this.http2ServerList) {
            if (http2Server.listening) {
                http2Server.close();
            }
        }
        this.started = false;
        // Always destroy any available sessions. It's possible that one or more
        // tryShutdown() calls are in progress. Don't wait on them to finish.
        this.sessions.forEach((session) => {
            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
            // recognize destroy(code) as a valid signature.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            session.destroy(http2.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
    }
    register(name, handler, serialize, deserialize, type) {
        if (this.handlers.has(name)) {
            return false;
        }
        this.handlers.set(name, {
            func: handler,
            serialize,
            deserialize,
            type,
            path: name,
        });
        return true;
    }
    unregister(name) {
        return this.handlers.delete(name);
    }
    start() {
        if (this.http2ServerList.length === 0 ||
            this.http2ServerList.every((http2Server) => http2Server.listening !== true)) {
            throw new Error('server must be bound in order to start');
        }
        if (this.started === true) {
            throw new Error('server is already started');
        }
        this.started = true;
    }
    tryShutdown(callback) {
        let pendingChecks = 0;
        function maybeCallback() {
            pendingChecks--;
            if (pendingChecks === 0) {
                callback();
            }
        }
        // Close the server if necessary.
        this.started = false;
        for (const http2Server of this.http2ServerList) {
            if (http2Server.listening) {
                pendingChecks++;
                http2Server.close(maybeCallback);
            }
        }
        this.sessions.forEach((session) => {
            if (!session.closed) {
                pendingChecks += 1;
                session.close(maybeCallback);
            }
        });
        if (pendingChecks === 0) {
            callback();
        }
    }
    addHttp2Port() {
        throw new Error('Not yet implemented');
    }
    _setupHandlers(http2Server) {
        if (http2Server === null) {
            return;
        }
        http2Server.on('stream', (stream, headers) => {
            const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
            if (typeof contentType !== 'string' ||
                !contentType.startsWith('application/grpc')) {
                stream.respond({
                    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
                }, { endStream: true });
                return;
            }
            try {
                const path = headers[http2.constants.HTTP2_HEADER_PATH];
                const serverAddress = http2Server.address();
                let serverAddressString = 'null';
                if (serverAddress) {
                    if (typeof serverAddress === 'string') {
                        serverAddressString = serverAddress;
                    }
                    else {
                        serverAddressString =
                            serverAddress.address + ':' + serverAddress.port;
                    }
                }
                trace('Received call to method ' +
                    path +
                    ' at address ' +
                    serverAddressString);
                const handler = this.handlers.get(path);
                if (handler === undefined) {
                    trace('No handler registered for method ' +
                        path +
                        '. Sending UNIMPLEMENTED status.');
                    throw getUnimplementedStatusResponse(path);
                }
                const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);
                const metadata = call.receiveMetadata(headers);
                switch (handler.type) {
                    case 'unary':
                        handleUnary(call, handler, metadata);
                        break;
                    case 'clientStream':
                        handleClientStreaming(call, handler, metadata);
                        break;
                    case 'serverStream':
                        handleServerStreaming(call, handler, metadata);
                        break;
                    case 'bidi':
                        handleBidiStreaming(call, handler, metadata);
                        break;
                    default:
                        throw new Error(`Unknown handler type: ${handler.type}`);
                }
            }
            catch (err) {
                const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
                if (err.code === undefined) {
                    err.code = constants_1.Status.INTERNAL;
                }
                call.sendError(err);
            }
        });
        http2Server.on('session', (session) => {
            if (!this.started) {
                session.destroy();
                return;
            }
            this.sessions.add(session);
            session.on('close', () => {
                this.sessions.delete(session);
            });
        });
    }
}
exports.Server = Server;
async function handleUnary(call, handler, metadata) {
    const request = await call.receiveUnaryMessage();
    if (request === undefined || call.cancelled) {
        return;
    }
    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
    handler.func(emitter, (err, value, trailer, flags) => {
        call.sendUnaryMessage(err, value, trailer, flags);
    });
}
function handleClientStreaming(call, handler, metadata) {
    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);
    function respond(err, value, trailer, flags) {
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
    }
    if (call.cancelled) {
        return;
    }
    stream.on('error', respond);
    handler.func(stream, respond);
}
async function handleServerStreaming(call, handler, metadata) {
    const request = await call.receiveUnaryMessage();
    if (request === undefined || call.cancelled) {
        return;
    }
    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);
    handler.func(stream);
}
function handleBidiStreaming(call, handler, metadata) {
    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);
    if (call.cancelled) {
        return;
    }
    handler.func(stream);
}
//# sourceMappingURL=server.js.map

/***/ }),

/***/ 9634:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;
/* This file implements gRFC A2 and the service config spec:
 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
 * function here takes an object with unknown structure and returns its
 * specific object type if the input has the right structure, and throws an
 * error otherwise. */
/* The any type is purposely used here. All functions validate their input at
 * runtime */
/* eslint-disable @typescript-eslint/no-explicit-any */
const os = __nccwpck_require__(2087);
const load_balancer_1 = __nccwpck_require__(2456);
/**
 * Recognizes a number with up to 9 digits after the decimal point, followed by
 * an "s", representing a number of seconds.
 */
const TIMEOUT_REGEX = /^\d+(\.\d{1,9})?s$/;
/**
 * Client language name used for determining whether this client matches a
 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
 */
const CLIENT_LANGUAGE_STRING = 'node';
function validateName(obj) {
    if (!('service' in obj) || typeof obj.service !== 'string') {
        throw new Error('Invalid method config name: invalid service');
    }
    const result = {
        service: obj.service,
    };
    if ('method' in obj) {
        if (typeof obj.method === 'string') {
            result.method = obj.method;
        }
        else {
            throw new Error('Invalid method config name: invalid method');
        }
    }
    return result;
}
function validateMethodConfig(obj) {
    const result = {
        name: [],
    };
    if (!('name' in obj) || !Array.isArray(obj.name)) {
        throw new Error('Invalid method config: invalid name array');
    }
    for (const name of obj.name) {
        result.name.push(validateName(name));
    }
    if ('waitForReady' in obj) {
        if (typeof obj.waitForReady !== 'boolean') {
            throw new Error('Invalid method config: invalid waitForReady');
        }
        result.waitForReady = obj.waitForReady;
    }
    if ('timeout' in obj) {
        if (!(typeof obj.timeout === 'string') ||
            !TIMEOUT_REGEX.test(obj.timeout)) {
            throw new Error('Invalid method config: invalid timeout');
        }
        result.timeout = obj.timeout;
    }
    if ('maxRequestBytes' in obj) {
        if (typeof obj.maxRequestBytes !== 'number') {
            throw new Error('Invalid method config: invalid maxRequestBytes');
        }
        result.maxRequestBytes = obj.maxRequestBytes;
    }
    if ('maxResponseBytes' in obj) {
        if (typeof obj.maxResponseBytes !== 'number') {
            throw new Error('Invalid method config: invalid maxRequestBytes');
        }
        result.maxResponseBytes = obj.maxResponseBytes;
    }
    return result;
}
function validateServiceConfig(obj) {
    const result = {
        loadBalancingConfig: [],
        methodConfig: [],
    };
    if ('loadBalancingPolicy' in obj) {
        if (typeof obj.loadBalancingPolicy === 'string') {
            result.loadBalancingPolicy = obj.loadBalancingPolicy;
        }
        else {
            throw new Error('Invalid service config: invalid loadBalancingPolicy');
        }
    }
    if ('loadBalancingConfig' in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
            for (const config of obj.loadBalancingConfig) {
                result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));
            }
        }
        else {
            throw new Error('Invalid service config: invalid loadBalancingConfig');
        }
    }
    if ('methodConfig' in obj) {
        if (Array.isArray(obj.methodConfig)) {
            for (const methodConfig of obj.methodConfig) {
                result.methodConfig.push(validateMethodConfig(methodConfig));
            }
        }
    }
    // Validate method name uniqueness
    const seenMethodNames = [];
    for (const methodConfig of result.methodConfig) {
        for (const name of methodConfig.name) {
            for (const seenName of seenMethodNames) {
                if (name.service === seenName.service &&
                    name.method === seenName.method) {
                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
                }
            }
            seenMethodNames.push(name);
        }
    }
    return result;
}
exports.validateServiceConfig = validateServiceConfig;
function validateCanaryConfig(obj) {
    if (!('serviceConfig' in obj)) {
        throw new Error('Invalid service config choice: missing service config');
    }
    const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig),
    };
    if ('clientLanguage' in obj) {
        if (Array.isArray(obj.clientLanguage)) {
            result.clientLanguage = [];
            for (const lang of obj.clientLanguage) {
                if (typeof lang === 'string') {
                    result.clientLanguage.push(lang);
                }
                else {
                    throw new Error('Invalid service config choice: invalid clientLanguage');
                }
            }
        }
        else {
            throw new Error('Invalid service config choice: invalid clientLanguage');
        }
    }
    if ('clientHostname' in obj) {
        if (Array.isArray(obj.clientHostname)) {
            result.clientHostname = [];
            for (const lang of obj.clientHostname) {
                if (typeof lang === 'string') {
                    result.clientHostname.push(lang);
                }
                else {
                    throw new Error('Invalid service config choice: invalid clientHostname');
                }
            }
        }
        else {
            throw new Error('Invalid service config choice: invalid clientHostname');
        }
    }
    if ('percentage' in obj) {
        if (typeof obj.percentage === 'number' &&
            0 <= obj.percentage &&
            obj.percentage <= 100) {
            result.percentage = obj.percentage;
        }
        else {
            throw new Error('Invalid service config choice: invalid percentage');
        }
    }
    // Validate that no unexpected fields are present
    const allowedFields = [
        'clientLanguage',
        'percentage',
        'clientHostname',
        'serviceConfig',
    ];
    for (const field in obj) {
        if (!allowedFields.includes(field)) {
            throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
    }
    return result;
}
function validateAndSelectCanaryConfig(obj, percentage) {
    if (!Array.isArray(obj)) {
        throw new Error('Invalid service config list');
    }
    for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        /* For each field, we check if it is present, then only discard the
         * config if the field value does not match the current client */
        if (typeof validatedConfig.percentage === 'number' &&
            percentage > validatedConfig.percentage) {
            continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
            let hostnameMatched = false;
            for (const hostname of validatedConfig.clientHostname) {
                if (hostname === os.hostname()) {
                    hostnameMatched = true;
                }
            }
            if (!hostnameMatched) {
                continue;
            }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
            let languageMatched = false;
            for (const language of validatedConfig.clientLanguage) {
                if (language === CLIENT_LANGUAGE_STRING) {
                    languageMatched = true;
                }
            }
            if (!languageMatched) {
                continue;
            }
        }
        return validatedConfig.serviceConfig;
    }
    throw new Error('No matching service config found');
}
/**
 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
 * and select a service config with selection fields that all match this client. Most of these steps
 * can fail with an error; the caller must handle any errors thrown this way.
 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
 * @return The service configuration to use, given the percentage value, or null if the service config
 *     data has a valid format but none of the options match the current client.
 */
function extractAndSelectServiceConfig(txtRecord, percentage) {
    for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith('grpc_config=')) {
            /* Treat the list of strings in this record as a single string and remove
             * "grpc_config=" from the beginning. The rest should be a JSON string */
            const recordString = record.join('').substring('grpc_config='.length);
            const recordJson = JSON.parse(recordString);
            return validateAndSelectCanaryConfig(recordJson, percentage);
        }
    }
    return null;
}
exports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
//# sourceMappingURL=service-config.js.map

/***/ }),

/***/ 3053:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBuilder = void 0;
/**
 * A builder for gRPC status objects.
 */
class StatusBuilder {
    constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
    }
    /**
     * Adds a status code to the builder.
     */
    withCode(code) {
        this.code = code;
        return this;
    }
    /**
     * Adds details to the builder.
     */
    withDetails(details) {
        this.details = details;
        return this;
    }
    /**
     * Adds metadata to the builder.
     */
    withMetadata(metadata) {
        this.metadata = metadata;
        return this;
    }
    /**
     * Builds the status object.
     */
    build() {
        const status = {};
        if (this.code !== null) {
            status.code = this.code;
        }
        if (this.details !== null) {
            status.details = this.details;
        }
        if (this.metadata !== null) {
            status.metadata = this.metadata;
        }
        return status;
    }
}
exports.StatusBuilder = StatusBuilder;
//# sourceMappingURL=status-builder.js.map

/***/ }),

/***/ 5898:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamDecoder = void 0;
var ReadState;
(function (ReadState) {
    ReadState[ReadState["NO_DATA"] = 0] = "NO_DATA";
    ReadState[ReadState["READING_SIZE"] = 1] = "READING_SIZE";
    ReadState[ReadState["READING_MESSAGE"] = 2] = "READING_MESSAGE";
})(ReadState || (ReadState = {}));
class StreamDecoder {
    constructor() {
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
    }
    write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
            switch (this.readState) {
                case ReadState.NO_DATA:
                    this.readCompressFlag = data.slice(readHead, readHead + 1);
                    readHead += 1;
                    this.readState = ReadState.READING_SIZE;
                    this.readPartialSize.fill(0);
                    this.readSizeRemaining = 4;
                    this.readMessageSize = 0;
                    this.readMessageRemaining = 0;
                    this.readPartialMessage = [];
                    break;
                case ReadState.READING_SIZE:
                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);
                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
                    this.readSizeRemaining -= toRead;
                    readHead += toRead;
                    // readSizeRemaining >=0 here
                    if (this.readSizeRemaining === 0) {
                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                        this.readMessageRemaining = this.readMessageSize;
                        if (this.readMessageRemaining > 0) {
                            this.readState = ReadState.READING_MESSAGE;
                        }
                        else {
                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                            this.readState = ReadState.NO_DATA;
                            result.push(message);
                        }
                    }
                    break;
                case ReadState.READING_MESSAGE:
                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);
                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
                    this.readMessageRemaining -= toRead;
                    readHead += toRead;
                    // readMessageRemaining >=0 here
                    if (this.readMessageRemaining === 0) {
                        // At this point, we have read a full message
                        const framedMessageBuffers = [
                            this.readCompressFlag,
                            this.readPartialSize,
                        ].concat(this.readPartialMessage);
                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                        this.readState = ReadState.NO_DATA;
                        result.push(framedMessage);
                    }
                    break;
                default:
                    throw new Error('Unexpected read state');
            }
        }
        return result;
    }
}
exports.StreamDecoder = StreamDecoder;
//# sourceMappingURL=stream-decoder.js.map

/***/ }),

/***/ 9905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSubchannelPool = exports.SubchannelPool = void 0;
const channel_options_1 = __nccwpck_require__(8282);
const subchannel_1 = __nccwpck_require__(3985);
const uri_parser_1 = __nccwpck_require__(5562);
// 10 seconds in milliseconds. This value is arbitrary.
/**
 * The amount of time in between checks for dropping subchannels that have no
 * other references
 */
const REF_CHECK_INTERVAL = 10000;
class SubchannelPool {
    /**
     * A pool of subchannels use for making connections. Subchannels with the
     * exact same parameters will be reused.
     * @param global If true, this is the global subchannel pool. Otherwise, it
     * is the pool for a single channel.
     */
    constructor(global) {
        this.global = global;
        this.pool = Object.create(null);
        /**
         * A timer of a task performing a periodic subchannel cleanup.
         */
        this.cleanupTimer = null;
    }
    /**
     * Unrefs all unused subchannels and cancels the cleanup task if all
     * subchannels have been unrefed.
     */
    unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        /* These objects are created with Object.create(null), so they do not
         * have a prototype, which means that for (... in ...) loops over them
         * do not need to be filtered */
        // eslint-disable-disable-next-line:forin
        for (const channelTarget in this.pool) {
            const subchannelObjArray = this.pool[channelTarget];
            const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
            if (refedSubchannels.length > 0) {
                allSubchannelsUnrefed = false;
            }
            /* For each subchannel in the pool, try to unref it if it has
             * exactly one ref (which is the ref from the pool itself). If that
             * does happen, remove the subchannel from the pool */
            this.pool[channelTarget] = refedSubchannels;
        }
        /* Currently we do not delete keys with empty values. If that results
         * in significant memory usage we should change it. */
        // Cancel the cleanup task if all subchannels have been unrefed.
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = null;
        }
    }
    /**
     * Ensures that the cleanup task is spawned.
     */
    ensureCleanupTask() {
        var _a, _b;
        if (this.global && this.cleanupTimer === null) {
            this.cleanupTimer = setInterval(() => {
                this.unrefUnusedSubchannels();
            }, REF_CHECK_INTERVAL);
            // Unref because this timer should not keep the event loop running.
            // Call unref only if it exists to address electron/electron#21162
            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    /**
     * Get a subchannel if one already exists with exactly matching parameters.
     * Otherwise, create and save a subchannel with those parameters.
     * @param channelTarget
     * @param subchannelTarget
     * @param channelArguments
     * @param channelCredentials
     */
    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = uri_parser_1.uriToString(channelTargetUri);
        if (channelTarget in this.pool) {
            const subchannelObjArray = this.pool[channelTarget];
            for (const subchannelObj of subchannelObjArray) {
                if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) &&
                    channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) &&
                    channelCredentials._equals(subchannelObj.channelCredentials)) {
                    return subchannelObj.subchannel;
                }
            }
        }
        // If we get here, no matching subchannel was found
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);
        if (!(channelTarget in this.pool)) {
            this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
            subchannelAddress: subchannelTarget,
            channelArguments,
            channelCredentials,
            subchannel,
        });
        if (this.global) {
            subchannel.ref();
        }
        return subchannel;
    }
}
exports.SubchannelPool = SubchannelPool;
const globalSubchannelPool = new SubchannelPool(true);
/**
 * Get either the global subchannel pool, or a new subchannel pool.
 * @param global
 */
function getSubchannelPool(global) {
    if (global) {
        return globalSubchannelPool;
    }
    else {
        return new SubchannelPool(false);
    }
}
exports.getSubchannelPool = getSubchannelPool;
//# sourceMappingURL=subchannel-pool.js.map

/***/ }),

/***/ 3985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subchannel = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;
const http2 = __nccwpck_require__(7565);
const tls_1 = __nccwpck_require__(4016);
const channel_1 = __nccwpck_require__(5855);
const backoff_timeout_1 = __nccwpck_require__(8048);
const resolver_1 = __nccwpck_require__(8234);
const logging = __nccwpck_require__(8679);
const constants_1 = __nccwpck_require__(9329);
const http_proxy_1 = __nccwpck_require__(3974);
const net = __nccwpck_require__(1631);
const uri_parser_1 = __nccwpck_require__(5562);
const clientVersion = __nccwpck_require__(8160)/* .version */ .i8;
const TRACER_NAME = 'subchannel';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
function refTrace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', text);
}
const MIN_CONNECT_TIMEOUT_MS = 20000;
const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;
/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
 * have a constant for the max signed 32 bit integer, so this is a simple way
 * to calculate it */
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
const KEEPALIVE_TIMEOUT_MS = 20000;
const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
/**
 * Get a number uniformly at random in the range [min, max)
 * @param min
 * @param max
 */
function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
}
const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
function isTcpSubchannelAddress(address) {
    return 'port' in address;
}
exports.isTcpSubchannelAddress = isTcpSubchannelAddress;
function subchannelAddressEqual(address1, address2) {
    if (isTcpSubchannelAddress(address1)) {
        return (isTcpSubchannelAddress(address2) &&
            address1.host === address2.host &&
            address1.port === address2.port);
    }
    else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
    }
}
exports.subchannelAddressEqual = subchannelAddressEqual;
function subchannelAddressToString(address) {
    if (isTcpSubchannelAddress(address)) {
        return address.host + ':' + address.port;
    }
    else {
        return address.path;
    }
}
exports.subchannelAddressToString = subchannelAddressToString;
class Subchannel {
    /**
     * A class representing a connection to a single backend.
     * @param channelTarget The target string for the channel as a whole
     * @param subchannelAddress The address for the backend that this subchannel
     *     will connect to
     * @param options The channel options, plus any specific subchannel options
     *     for this subchannel
     * @param credentials The channel credentials used to establish this
     *     connection
     */
    constructor(channelTarget, subchannelAddress, options, credentials) {
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials;
        /**
         * The subchannel's current connectivity state. Invariant: `session` === `null`
         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
         */
        this.connectivityState = channel_1.ConnectivityState.IDLE;
        /**
         * The underlying http2 session used to make requests.
         */
        this.session = null;
        /**
         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
         * CONNECTING instead of IDLE when the backoff timeout ends.
         */
        this.continueConnecting = false;
        /**
         * A list of listener functions that will be called whenever the connectivity
         * state changes. Will be modified by `addConnectivityStateListener` and
         * `removeConnectivityStateListener`
         */
        this.stateListeners = [];
        /**
         * A list of listener functions that will be called when the underlying
         * socket disconnects. Used for ending active calls with an UNAVAILABLE
         * status.
         */
        this.disconnectListeners = [];
        /**
         * The amount of time in between sending pings
         */
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        /**
         * The amount of time to wait for an acknowledgement after sending a ping
         */
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        /**
         * Indicates whether keepalive pings should be sent without any active calls
         */
        this.keepaliveWithoutCalls = false;
        /**
         * Tracks calls with references to this subchannel
         */
        this.callRefcount = 0;
        /**
         * Tracks channels and subchannel pools with references to this subchannel
         */
        this.refcount = 0;
        // Build user-agent string.
        this.userAgent = [
            options['grpc.primary_user_agent'],
            `grpc-node-js/${clientVersion}`,
            options['grpc.secondary_user_agent'],
        ]
            .filter((e) => e)
            .join(' '); // remove falsey values first
        if ('grpc.keepalive_time_ms' in options) {
            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
        }
        if ('grpc.keepalive_timeout_ms' in options) {
            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
        }
        if ('grpc.keepalive_permit_without_calls' in options) {
            this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;
        }
        else {
            this.keepaliveWithoutCalls = false;
        }
        this.keepaliveIntervalId = setTimeout(() => { }, 0);
        clearTimeout(this.keepaliveIntervalId);
        this.keepaliveTimeoutId = setTimeout(() => { }, 0);
        clearTimeout(this.keepaliveTimeoutId);
        const backoffOptions = {
            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
            maxDelay: options['grpc.max_reconnect_backoff_ms'],
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
            this.handleBackoffTimer();
        }, backoffOptions);
        this.subchannelAddressString = subchannelAddressToString(subchannelAddress);
    }
    handleBackoffTimer() {
        if (this.continueConnecting) {
            this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
        }
        else {
            this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.IDLE);
        }
    }
    /**
     * Start a backoff timer with the current nextBackoff timeout
     */
    startBackoff() {
        this.backoffTimeout.runOnce();
    }
    stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
    }
    sendPing() {
        var _a, _b;
        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', 'Sending ping to ' + this.subchannelAddressString);
        this.keepaliveTimeoutId = setTimeout(() => {
            this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
        }, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.session.ping((err, duration, payload) => {
            clearTimeout(this.keepaliveTimeoutId);
        });
    }
    startKeepalivePings() {
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => {
            this.sendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        /* Don't send a ping immediately because whatever caused us to start
         * sending pings should also involve some network activity. */
    }
    stopKeepalivePings() {
        clearInterval(this.keepaliveIntervalId);
        clearTimeout(this.keepaliveTimeoutId);
    }
    createSession(proxyConnectionResult) {
        var _a, _b, _c;
        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
        let connectionOptions = this.credentials._getConnectionOptions() || {};
        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
        if ('grpc-node.max_session_memory' in this.options) {
            connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];
        }
        let addressScheme = 'http://';
        if ('secureContext' in connectionOptions) {
            addressScheme = 'https://';
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (this.options['grpc.ssl_target_name_override']) {
                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];
                connectionOptions.checkServerIdentity = (host, cert) => {
                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
                };
                connectionOptions.servername = sslTargetNameOverride;
            }
            else {
                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';
                // We want to always set servername to support SNI
                connectionOptions.servername = authorityHostname;
            }
            if (proxyConnectionResult.socket) {
                /* This is part of the workaround for
                 * https://github.com/nodejs/node/issues/32922. Without that bug,
                 * proxyConnectionResult.socket would always be a plaintext socket and
                 * this would say
                 * connectionOptions.socket = proxyConnectionResult.socket; */
                connectionOptions.createConnection = (authority, option) => {
                    return proxyConnectionResult.socket;
                };
            }
        }
        else {
            /* In all but the most recent versions of Node, http2.connect does not use
             * the options when establishing plaintext connections, so we need to
             * establish that connection explicitly. */
            connectionOptions.createConnection = (authority, option) => {
                if (proxyConnectionResult.socket) {
                    return proxyConnectionResult.socket;
                }
                else {
                    /* net.NetConnectOpts is declared in a way that is more restrictive
                     * than what net.connect will actually accept, so we use the type
                     * assertion to work around that. */
                    return net.connect(this.subchannelAddress);
                }
            };
        }
        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);
        /* http2.connect uses the options here:
         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
         * The spread operator overides earlier values with later ones, so any port
         * or host values in the options will be used rather than any values extracted
         * from the first argument. In addition, the path overrides the host and port,
         * as documented for plaintext connections here:
         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
         * and for TLS connections here:
         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
         * earlier versions of Node, http2.connect passes these options to
         * tls.connect but not net.connect, so in the insecure case we still need
         * to set the createConnection option above to create the connection
         * explicitly. We cannot do that in the TLS case because http2.connect
         * passes necessary additional options to tls.connect.
         * The first argument just needs to be parseable as a URL and the scheme
         * determines whether the connection will be established over TLS or not.
         */
        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
        this.session = session;
        session.unref();
        /* For all of these events, check if the session at the time of the event
         * is the same one currently attached to this subchannel, to ensure that
         * old events from previous connection attempts cannot cause invalid state
         * transitions. */
        session.once('connect', () => {
            if (this.session === session) {
                this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);
            }
        });
        session.once('close', () => {
            if (this.session === session) {
                this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
                /* Transitioning directly to IDLE here should be OK because we are not
                 * doing any backoff, because a connection was established at some
                 * point */
                this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
            }
        });
        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {
            if (this.session === session) {
                /* See the last paragraph of
                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
                if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
                    opaqueData.equals(tooManyPingsData)) {
                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);
                }
                trace(this.subchannelAddressString +
                    ' connection closed by GOAWAY with code ' +
                    errorCode);
                this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
            }
        });
        session.once('error', (error) => {
            /* Do nothing here. Any error should also trigger a close event, which is
             * where we want to handle that.  */
            trace(this.subchannelAddressString +
                ' connection closed with error ' +
                error.message);
        });
    }
    startConnectingInternal() {
        var _a, _b;
        /* Pass connection options through to the proxy so that it's able to
         * upgrade it's connection to support tls if needed.
         * This is a workaround for https://github.com/nodejs/node/issues/32922
         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
        const connectionOptions = this.credentials._getConnectionOptions() || {};
        if ('secureContext' in connectionOptions) {
            connectionOptions.ALPNProtocols = ['h2'];
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (this.options['grpc.ssl_target_name_override']) {
                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];
                connectionOptions.checkServerIdentity = (host, cert) => {
                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
                };
                connectionOptions.servername = sslTargetNameOverride;
            }
            else {
                if ('grpc.http_connect_target' in this.options) {
                    /* This is more or less how servername will be set in createSession
                     * if a connection is successfully established through the proxy.
                     * If the proxy is not used, these connectionOptions are discarded
                     * anyway */
                    const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {
                        path: 'localhost',
                    });
                    const hostPort = uri_parser_1.splitHostPort(targetPath);
                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
                }
            }
        }
        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {
            this.createSession(result);
        }, (reason) => {
            this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        });
    }
    /**
     * Initiate a state transition from any element of oldStates to the new
     * state. If the current connectivityState is not in oldStates, do nothing.
     * @param oldStates The set of states to transition from
     * @param newState The state to transition to
     * @returns True if the state changed, false otherwise
     */
    transitionToState(oldStates, newState) {
        if (oldStates.indexOf(this.connectivityState) === -1) {
            return false;
        }
        trace(this.subchannelAddressString +
            ' ' +
            channel_1.ConnectivityState[this.connectivityState] +
            ' -> ' +
            channel_1.ConnectivityState[newState]);
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
            case channel_1.ConnectivityState.READY:
                this.stopBackoff();
                this.session.socket.once('close', () => {
                    for (const listener of this.disconnectListeners) {
                        listener();
                    }
                });
                if (this.keepaliveWithoutCalls) {
                    this.startKeepalivePings();
                }
                break;
            case channel_1.ConnectivityState.CONNECTING:
                this.startBackoff();
                this.startConnectingInternal();
                this.continueConnecting = false;
                break;
            case channel_1.ConnectivityState.TRANSIENT_FAILURE:
                if (this.session) {
                    this.session.close();
                }
                this.session = null;
                this.stopKeepalivePings();
                /* If the backoff timer has already ended by the time we get to the
                 * TRANSIENT_FAILURE state, we want to immediately transition out of
                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
                if (!this.backoffTimeout.isRunning()) {
                    process.nextTick(() => {
                        this.handleBackoffTimer();
                    });
                }
                break;
            case channel_1.ConnectivityState.IDLE:
                if (this.session) {
                    this.session.close();
                }
                this.session = null;
                this.stopKeepalivePings();
                break;
            default:
                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        /* We use a shallow copy of the stateListeners array in case a listener
         * is removed during this iteration */
        for (const listener of [...this.stateListeners]) {
            listener(this, previousState, newState);
        }
        return true;
    }
    /**
     * Check if the subchannel associated with zero calls and with zero channels.
     * If so, shut it down.
     */
    checkBothRefcounts() {
        /* If no calls, channels, or subchannel pools have any more references to
         * this subchannel, we can be sure it will never be used again. */
        if (this.callRefcount === 0 && this.refcount === 0) {
            this.transitionToState([
                channel_1.ConnectivityState.CONNECTING,
                channel_1.ConnectivityState.READY,
            ], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        }
    }
    callRef() {
        refTrace(this.subchannelAddressString +
            ' callRefcount ' +
            this.callRefcount +
            ' -> ' +
            (this.callRefcount + 1));
        if (this.callRefcount === 0) {
            if (this.session) {
                this.session.ref();
            }
            this.backoffTimeout.ref();
            if (!this.keepaliveWithoutCalls) {
                this.startKeepalivePings();
            }
        }
        this.callRefcount += 1;
    }
    callUnref() {
        refTrace(this.subchannelAddressString +
            ' callRefcount ' +
            this.callRefcount +
            ' -> ' +
            (this.callRefcount - 1));
        this.callRefcount -= 1;
        if (this.callRefcount === 0) {
            if (this.session) {
                this.session.unref();
            }
            this.backoffTimeout.unref();
            if (!this.keepaliveWithoutCalls) {
                this.stopKeepalivePings();
            }
            this.checkBothRefcounts();
        }
    }
    ref() {
        refTrace(this.subchannelAddressString +
            ' refcount ' +
            this.refcount +
            ' -> ' +
            (this.refcount + 1));
        this.refcount += 1;
    }
    unref() {
        refTrace(this.subchannelAddressString +
            ' refcount ' +
            this.refcount +
            ' -> ' +
            (this.refcount - 1));
        this.refcount -= 1;
        this.checkBothRefcounts();
    }
    unrefIfOneRef() {
        if (this.refcount === 1) {
            this.unref();
            return true;
        }
        return false;
    }
    /**
     * Start a stream on the current session with the given `metadata` as headers
     * and then attach it to the `callStream`. Must only be called if the
     * subchannel's current connectivity state is READY.
     * @param metadata
     * @param callStream
     */
    startCallStream(metadata, callStream, extraFilterFactory) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
        headers[HTTP2_HEADER_METHOD] = 'POST';
        headers[HTTP2_HEADER_PATH] = callStream.getMethod();
        headers[HTTP2_HEADER_TE] = 'trailers';
        let http2Stream;
        /* In theory, if an error is thrown by session.request because session has
         * become unusable (e.g. because it has received a goaway), this subchannel
         * should soon see the corresponding close or goaway event anyway and leave
         * READY. But we have seen reports that this does not happen
         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
         * so for defense in depth, we just discard the session when we see an
         * error here.
         */
        try {
            http2Stream = this.session.request(headers);
        }
        catch (e) {
            this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);
            throw e;
        }
        let headersString = '';
        for (const header of Object.keys(headers)) {
            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
        }
        logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream on subchannel ' + this.subchannelAddressString + ' with headers\n' + headersString);
        callStream.attachHttp2Stream(http2Stream, this, extraFilterFactory);
    }
    /**
     * If the subchannel is currently IDLE, start connecting and switch to the
     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
     * the next time it would transition to IDLE, start connecting again instead.
     * Otherwise, do nothing.
     */
    startConnecting() {
        /* First, try to transition from IDLE to connecting. If that doesn't happen
         * because the state is not currently IDLE, check if it is
         * TRANSIENT_FAILURE, and if so indicate that it should go back to
         * connecting after the backoff timer ends. Otherwise do nothing */
        if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {
            if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                this.continueConnecting = true;
            }
        }
    }
    /**
     * Get the subchannel's current connectivity state.
     */
    getConnectivityState() {
        return this.connectivityState;
    }
    /**
     * Add a listener function to be called whenever the subchannel's
     * connectivity state changes.
     * @param listener
     */
    addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
    }
    /**
     * Remove a listener previously added with `addConnectivityStateListener`
     * @param listener A reference to a function previously passed to
     *     `addConnectivityStateListener`
     */
    removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
            this.stateListeners.splice(listenerIndex, 1);
        }
    }
    addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
    }
    removeDisconnectListener(listener) {
        const listenerIndex = this.disconnectListeners.indexOf(listener);
        if (listenerIndex > -1) {
            this.disconnectListeners.splice(listenerIndex, 1);
        }
    }
    /**
     * Reset the backoff timeout, and immediately start connecting if in backoff.
     */
    resetBackoff() {
        this.backoffTimeout.reset();
        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
    }
    getAddress() {
        return this.subchannelAddressString;
    }
}
exports.Subchannel = Subchannel;
//# sourceMappingURL=subchannel.js.map

/***/ }),

/***/ 3570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;
const fs = __nccwpck_require__(5747);
exports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
let defaultRootsData = null;
function getDefaultRootsData() {
    if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
    }
    return null;
}
exports.getDefaultRootsData = getDefaultRootsData;
//# sourceMappingURL=tls-helpers.js.map

/***/ }),

/***/ 5562:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriToString = exports.splitHostPort = exports.parseUri = void 0;
/*
 * The groups correspond to URI parts as follows:
 * 1. scheme
 * 2. authority
 * 3. path
 */
const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
function parseUri(uriString) {
    const parsedUri = URI_REGEX.exec(uriString);
    if (parsedUri === null) {
        return null;
    }
    return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3],
    };
}
exports.parseUri = parseUri;
const NUMBER_REGEX = /^\d+$/;
function splitHostPort(path) {
    if (path.startsWith('[')) {
        const hostEnd = path.indexOf(']');
        if (hostEnd === -1) {
            return null;
        }
        const host = path.substring(1, hostEnd);
        /* Only an IPv6 address should be in bracketed notation, and an IPv6
         * address should have at least one colon */
        if (host.indexOf(':') === -1) {
            return null;
        }
        if (path.length > hostEnd + 1) {
            if (path[hostEnd + 1] === ':') {
                const portString = path.substring(hostEnd + 2);
                if (NUMBER_REGEX.test(portString)) {
                    return {
                        host: host,
                        port: +portString,
                    };
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        else {
            return {
                host,
            };
        }
    }
    else {
        const splitPath = path.split(':');
        /* Exactly one colon means that this is host:port. Zero colons means that
         * there is no port. And multiple colons means that this is a bare IPv6
         * address with no port */
        if (splitPath.length === 2) {
            if (NUMBER_REGEX.test(splitPath[1])) {
                return {
                    host: splitPath[0],
                    port: +splitPath[1],
                };
            }
            else {
                return null;
            }
        }
        else {
            return {
                host: path,
            };
        }
    }
}
exports.splitHostPort = splitHostPort;
function uriToString(uri) {
    let result = '';
    if (uri.scheme !== undefined) {
        result += uri.scheme + ':';
    }
    if (uri.authority !== undefined) {
        result += '//' + uri.authority + '/';
    }
    result += uri.path;
    return result;
}
exports.uriToString = uriToString;
//# sourceMappingURL=uri-parser.js.map

/***/ }),

/***/ 973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:!0})),exports.SchedulableTransactionBody=exports.ScheduleID=exports.ThresholdKey=exports.KeyList=exports.Key=exports.ConsensusTopicQuery=exports.ConsensusTopicResponse=exports.TransactionRecord=exports.TransactionReceipt=exports.TransactionID=exports.TransactionBody=exports.TransactionList=exports.SignedTransaction=exports.Transaction=exports.TopicID=exports.TokenID=exports.SemanticVersion=exports.ResponseType=exports.ResponseCodeEnum=exports.Query=exports.NetworkGetVersionInfoResponse=exports.FileID=exports.FileGetInfoResponse=exports.CryptoGetInfoResponse=exports.ContractID=exports.ContractGetInfoResponse=exports.AccountID=exports.ScheduleService=exports.TokenService=exports.SmartContractService=exports.NetworkService=exports.MirrorConsensusService=exports.FreezeService=exports.FileService=exports.CryptoService=exports.ConsensusService=exports.Writer=exports.Reader=void 0;var $protobuf=_interopRequireWildcard(__nccwpck_require__(6738)),_proto=__nccwpck_require__(3969);function _getRequireWildcardCache(a){if("function"!=typeof WeakMap)return null;var b=new WeakMap,c=new WeakMap;return(_getRequireWildcardCache=function(a){return a?c:b})(a)}function _interopRequireWildcard(a,b){if(!b&&a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return{default:a};var c=_getRequireWildcardCache(b);if(c&&c.has(a))return c.get(a);var d={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var f in a)if("default"!=f&&Object.prototype.hasOwnProperty.call(a,f)){var g=e?Object.getOwnPropertyDescriptor(a,f):null;g&&(g.get||g.set)?Object.defineProperty(d,f,g):d[f]=a[f]}return d.default=a,c&&c.set(a,d),d}const Reader=$protobuf.Reader;exports.Reader=Reader;const Writer=$protobuf.Writer;exports.Writer=Writer;const ConsensusService=_proto.proto.ConsensusService;exports.ConsensusService=ConsensusService;const CryptoService=_proto.proto.CryptoService;exports.CryptoService=CryptoService;const FileService=_proto.proto.FileService;exports.FileService=FileService;const FreezeService=_proto.proto.FreezeService;exports.FreezeService=FreezeService;const MirrorConsensusService=_proto.proto.MirrorConsensusService;exports.MirrorConsensusService=MirrorConsensusService;const NetworkService=_proto.proto.NetworkService;exports.NetworkService=NetworkService;const SmartContractService=_proto.proto.SmartContractService;exports.SmartContractService=SmartContractService;const TokenService=_proto.proto.TokenService;exports.TokenService=TokenService;const ScheduleService=_proto.proto.ScheduleService;exports.ScheduleService=ScheduleService;const AccountID=_proto.proto.AccountID;exports.AccountID=AccountID;const ContractGetInfoResponse=_proto.proto.ContractGetInfoResponse;exports.ContractGetInfoResponse=ContractGetInfoResponse;const ContractID=_proto.proto.ContractID;exports.ContractID=ContractID;const CryptoGetInfoResponse=_proto.proto.CryptoGetInfoResponse;exports.CryptoGetInfoResponse=CryptoGetInfoResponse;const FileGetInfoResponse=_proto.proto.FileGetInfoResponse;exports.FileGetInfoResponse=FileGetInfoResponse;const FileID=_proto.proto.FileID;exports.FileID=FileID;const NetworkGetVersionInfoResponse=_proto.proto.NetworkGetVersionInfoResponse;exports.NetworkGetVersionInfoResponse=NetworkGetVersionInfoResponse;const Query=_proto.proto.Query;exports.Query=Query;const ResponseCodeEnum=_proto.proto.ResponseCodeEnum;exports.ResponseCodeEnum=ResponseCodeEnum;const ResponseType=_proto.proto.ResponseType;exports.ResponseType=ResponseType;const SemanticVersion=_proto.proto.SemanticVersion;exports.SemanticVersion=SemanticVersion;const TokenID=_proto.proto.TokenID;exports.TokenID=TokenID;const TopicID=_proto.proto.TopicID;exports.TopicID=TopicID;const Transaction=_proto.proto.Transaction;exports.Transaction=Transaction;const SignedTransaction=_proto.proto.SignedTransaction;exports.SignedTransaction=SignedTransaction;const TransactionList=_proto.proto.TransactionList;exports.TransactionList=TransactionList;const TransactionBody=_proto.proto.TransactionBody;exports.TransactionBody=TransactionBody;const TransactionID=_proto.proto.TransactionID;exports.TransactionID=TransactionID;const TransactionReceipt=_proto.proto.TransactionReceipt;exports.TransactionReceipt=TransactionReceipt;const TransactionRecord=_proto.proto.TransactionRecord;exports.TransactionRecord=TransactionRecord;const ConsensusTopicResponse=_proto.proto.ConsensusTopicResponse;exports.ConsensusTopicResponse=ConsensusTopicResponse;const ConsensusTopicQuery=_proto.proto.ConsensusTopicQuery;exports.ConsensusTopicQuery=ConsensusTopicQuery;const Key=_proto.proto.Key;exports.Key=Key;const KeyList=_proto.proto.KeyList;exports.KeyList=KeyList;const ThresholdKey=_proto.proto.ThresholdKey;exports.ThresholdKey=ThresholdKey;const ScheduleID=_proto.proto.ScheduleID;exports.ScheduleID=ScheduleID;const SchedulableTransactionBody=_proto.proto.SchedulableTransactionBody;exports.SchedulableTransactionBody=SchedulableTransactionBody;

/***/ }),

/***/ 3969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
var $protobuf=_interopRequireWildcard(__nccwpck_require__(6738));Object.defineProperty(exports, "__esModule", ({value:!0})),exports.default=exports.google=exports.proto=void 0;function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var o=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:o})(e)}function _interopRequireWildcard(e,o){if(!o&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(o);if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var d in e)if("default"!=d&&Object.prototype.hasOwnProperty.call(e,d)){var i=r?Object.getOwnPropertyDescriptor(e,d):null;i&&(i.get||i.set)?Object.defineProperty(n,d,i):n[d]=e[d]}return n.default=e,t&&t.set(e,n),n}const $Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots["default"]||($protobuf.roots["default"]={});exports.default=$root;const proto=$root.proto=(()=>{const e={TokenUnitBalance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenId=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(16).uint64(e.balance),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUnitBalance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.balance=e.uint64();break;default:e.skipType(7&i);}return d},e}(),SingleAccountBalances:function(){function e(e){if(this.tokenUnitBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.hbarBalance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenUnitBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.hbarBalance&&Object.hasOwnProperty.call(e,"hbarBalance")&&o.uint32(16).uint64(e.hbarBalance),null!=e.tokenUnitBalances&&e.tokenUnitBalances.length)for(var t=0;t<e.tokenUnitBalances.length;++t)$root.proto.TokenUnitBalance.encode(e.tokenUnitBalances[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SingleAccountBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hbarBalance=e.uint64();break;case 3:d.tokenUnitBalances&&d.tokenUnitBalances.length||(d.tokenUnitBalances=[]),d.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),AllAccountBalances:function(){function e(e){if(this.allAccounts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.consensusTimestamp=null,e.prototype.allAccounts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(10).fork()).ldelim(),null!=e.allAccounts&&e.allAccounts.length)for(var t=0;t<e.allAccounts.length;++t)$root.proto.SingleAccountBalances.encode(e.allAccounts[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AllAccountBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.allAccounts&&d.allAccounts.length||(d.allAccounts=[]),d.allAccounts.push($root.proto.SingleAccountBalances.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ShardID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ShardID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),RealmID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.RealmID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),AccountID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.accountNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.accountNum&&Object.hasOwnProperty.call(e,"accountNum")&&o.uint32(24).int64(e.accountNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AccountID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.accountNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),FileID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.fileNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.fileNum&&Object.hasOwnProperty.call(e,"fileNum")&&o.uint32(24).int64(e.fileNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.fileNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),ContractID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.contractNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.contractNum&&Object.hasOwnProperty.call(e,"contractNum")&&o.uint32(24).int64(e.contractNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.contractNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),TransactionID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transactionValidStart=null,e.prototype.accountID=null,e.prototype.scheduled=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionValidStart&&Object.hasOwnProperty.call(e,"transactionValidStart")&&$root.proto.Timestamp.encode(e.transactionValidStart,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.scheduled&&Object.hasOwnProperty.call(e,"scheduled")&&o.uint32(24).bool(e.scheduled),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionValidStart=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.scheduled=e.bool();break;default:e.skipType(7&i);}return d},e}(),AccountAmount:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).sint64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AccountAmount,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.amount=e.sint64();break;default:e.skipType(7&i);}return d},e}(),TransferList:function(){function e(e){if(this.accountAmounts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountAmounts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountAmounts&&e.accountAmounts.length)for(var t=0;t<e.accountAmounts.length;++t)$root.proto.AccountAmount.encode(e.accountAmounts[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransferList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountAmounts&&d.accountAmounts.length||(d.accountAmounts=[]),d.accountAmounts.push($root.proto.AccountAmount.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenTransferList:function(){function e(e){if(this.transfers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.transfers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.transfers&&e.transfers.length)for(var t=0;t<e.transfers.length;++t)$root.proto.AccountAmount.encode(e.transfers[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenTransferList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.transfers&&d.transfers.length||(d.transfers=[]),d.transfers.push($root.proto.AccountAmount.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TopicID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.topicNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.topicNum&&Object.hasOwnProperty.call(e,"topicNum")&&o.uint32(24).int64(e.topicNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TopicID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.topicNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.tokenNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.tokenNum&&Object.hasOwnProperty.call(e,"tokenNum")&&o.uint32(24).int64(e.tokenNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.tokenNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),ScheduleID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.scheduleNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.scheduleNum&&Object.hasOwnProperty.call(e,"scheduleNum")&&o.uint32(24).int64(e.scheduleNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.scheduleNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenFreezeStatus:function(){const e={},o=Object.create(e);return o[e[0]="FreezeNotApplicable"]=0,o[e[1]="Frozen"]=1,o[e[2]="Unfrozen"]=2,o}(),TokenKycStatus:function(){const e={},o=Object.create(e);return o[e[0]="KycNotApplicable"]=0,o[e[1]="Granted"]=1,o[e[2]="Revoked"]=2,o}(),Key:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.contractID=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null,e.prototype.thresholdKey=null,e.prototype.keyList=null;let o;return Object.defineProperty(e.prototype,"key",{get:$util.oneOfGetter(o=["contractID","ed25519","RSA_3072","ECDSA_384","thresholdKey","keyList"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(18).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(26).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(34).bytes(e.ECDSA_384),null!=e.thresholdKey&&Object.hasOwnProperty.call(e,"thresholdKey")&&$root.proto.ThresholdKey.encode(e.thresholdKey,o.uint32(42).fork()).ldelim(),null!=e.keyList&&Object.hasOwnProperty.call(e,"keyList")&&$root.proto.KeyList.encode(e.keyList,o.uint32(50).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Key,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.ed25519=e.bytes();break;case 3:d.RSA_3072=e.bytes();break;case 4:d.ECDSA_384=e.bytes();break;case 5:d.thresholdKey=$root.proto.ThresholdKey.decode(e,e.uint32());break;case 6:d.keyList=$root.proto.KeyList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ThresholdKey:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.threshold=0,e.prototype.keys=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.threshold&&Object.hasOwnProperty.call(e,"threshold")&&o.uint32(8).uint32(e.threshold),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThresholdKey,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.threshold=e.uint32();break;case 2:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),KeyList:function(){function e(e){if(this.keys=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.keys=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.keys&&e.keys.length)for(var t=0;t<e.keys.length;++t)$root.proto.Key.encode(e.keys[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.KeyList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.keys&&d.keys.length||(d.keys=[]),d.keys.push($root.proto.Key.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),Signature:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.contract=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null,e.prototype.thresholdSignature=null,e.prototype.signatureList=null;let o;return Object.defineProperty(e.prototype,"signature",{get:$util.oneOfGetter(o=["contract","ed25519","RSA_3072","ECDSA_384","thresholdSignature","signatureList"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contract&&Object.hasOwnProperty.call(e,"contract")&&o.uint32(10).bytes(e.contract),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(18).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(26).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(34).bytes(e.ECDSA_384),null!=e.thresholdSignature&&Object.hasOwnProperty.call(e,"thresholdSignature")&&$root.proto.ThresholdSignature.encode(e.thresholdSignature,o.uint32(42).fork()).ldelim(),null!=e.signatureList&&Object.hasOwnProperty.call(e,"signatureList")&&$root.proto.SignatureList.encode(e.signatureList,o.uint32(50).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Signature,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contract=e.bytes();break;case 2:d.ed25519=e.bytes();break;case 3:d.RSA_3072=e.bytes();break;case 4:d.ECDSA_384=e.bytes();break;case 5:d.thresholdSignature=$root.proto.ThresholdSignature.decode(e,e.uint32());break;case 6:d.signatureList=$root.proto.SignatureList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ThresholdSignature:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.sigs=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.sigs&&Object.hasOwnProperty.call(e,"sigs")&&$root.proto.SignatureList.encode(e.sigs,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThresholdSignature,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.sigs=$root.proto.SignatureList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SignatureList:function(){function e(e){if(this.sigs=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.sigs=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.sigs&&e.sigs.length)for(var t=0;t<e.sigs.length;++t)$root.proto.Signature.encode(e.sigs[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignatureList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.sigs&&d.sigs.length||(d.sigs=[]),d.sigs.push($root.proto.Signature.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),SignaturePair:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.pubKeyPrefix=$util.newBuffer([]),e.prototype.contract=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null;let o;return Object.defineProperty(e.prototype,"signature",{get:$util.oneOfGetter(o=["contract","ed25519","RSA_3072","ECDSA_384"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.pubKeyPrefix&&Object.hasOwnProperty.call(e,"pubKeyPrefix")&&o.uint32(10).bytes(e.pubKeyPrefix),null!=e.contract&&Object.hasOwnProperty.call(e,"contract")&&o.uint32(18).bytes(e.contract),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(26).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(34).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(42).bytes(e.ECDSA_384),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignaturePair,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.pubKeyPrefix=e.bytes();break;case 2:d.contract=e.bytes();break;case 3:d.ed25519=e.bytes();break;case 4:d.RSA_3072=e.bytes();break;case 5:d.ECDSA_384=e.bytes();break;default:e.skipType(7&i);}return d},e}(),SignatureMap:function(){function e(e){if(this.sigPair=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.sigPair=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.sigPair&&e.sigPair.length)for(var t=0;t<e.sigPair.length;++t)$root.proto.SignaturePair.encode(e.sigPair[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignatureMap,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.sigPair&&d.sigPair.length||(d.sigPair=[]),d.sigPair.push($root.proto.SignaturePair.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),HederaFunctionality:function(){const e={},o=Object.create(e);return o[e[0]="NONE"]=0,o[e[1]="CryptoTransfer"]=1,o[e[2]="CryptoUpdate"]=2,o[e[3]="CryptoDelete"]=3,o[e[4]="CryptoAddLiveHash"]=4,o[e[5]="CryptoDeleteLiveHash"]=5,o[e[6]="ContractCall"]=6,o[e[7]="ContractCreate"]=7,o[e[8]="ContractUpdate"]=8,o[e[9]="FileCreate"]=9,o[e[10]="FileAppend"]=10,o[e[11]="FileUpdate"]=11,o[e[12]="FileDelete"]=12,o[e[13]="CryptoGetAccountBalance"]=13,o[e[14]="CryptoGetAccountRecords"]=14,o[e[15]="CryptoGetInfo"]=15,o[e[16]="ContractCallLocal"]=16,o[e[17]="ContractGetInfo"]=17,o[e[18]="ContractGetBytecode"]=18,o[e[19]="GetBySolidityID"]=19,o[e[20]="GetByKey"]=20,o[e[21]="CryptoGetLiveHash"]=21,o[e[22]="CryptoGetStakers"]=22,o[e[23]="FileGetContents"]=23,o[e[24]="FileGetInfo"]=24,o[e[25]="TransactionGetRecord"]=25,o[e[26]="ContractGetRecords"]=26,o[e[27]="CryptoCreate"]=27,o[e[28]="SystemDelete"]=28,o[e[29]="SystemUndelete"]=29,o[e[30]="ContractDelete"]=30,o[e[31]="Freeze"]=31,o[e[32]="CreateTransactionRecord"]=32,o[e[33]="CryptoAccountAutoRenew"]=33,o[e[34]="ContractAutoRenew"]=34,o[e[35]="GetVersionInfo"]=35,o[e[36]="TransactionGetReceipt"]=36,o[e[50]="ConsensusCreateTopic"]=50,o[e[51]="ConsensusUpdateTopic"]=51,o[e[52]="ConsensusDeleteTopic"]=52,o[e[53]="ConsensusGetTopicInfo"]=53,o[e[54]="ConsensusSubmitMessage"]=54,o[e[55]="UncheckedSubmit"]=55,o[e[56]="TokenCreate"]=56,o[e[58]="TokenGetInfo"]=58,o[e[59]="TokenFreezeAccount"]=59,o[e[60]="TokenUnfreezeAccount"]=60,o[e[61]="TokenGrantKycToAccount"]=61,o[e[62]="TokenRevokeKycFromAccount"]=62,o[e[63]="TokenDelete"]=63,o[e[64]="TokenUpdate"]=64,o[e[65]="TokenMint"]=65,o[e[66]="TokenBurn"]=66,o[e[67]="TokenAccountWipe"]=67,o[e[68]="TokenAssociateToAccount"]=68,o[e[69]="TokenDissociateFromAccount"]=69,o[e[70]="ScheduleCreate"]=70,o[e[71]="ScheduleDelete"]=71,o[e[72]="ScheduleSign"]=72,o[e[73]="ScheduleGetInfo"]=73,o}(),FeeComponents:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.min=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.max=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.constant=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.bpt=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.vpt=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.rbh=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.sbh=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.tv=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.bpr=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.sbpr=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.min&&Object.hasOwnProperty.call(e,"min")&&o.uint32(8).int64(e.min),null!=e.max&&Object.hasOwnProperty.call(e,"max")&&o.uint32(16).int64(e.max),null!=e.constant&&Object.hasOwnProperty.call(e,"constant")&&o.uint32(24).int64(e.constant),null!=e.bpt&&Object.hasOwnProperty.call(e,"bpt")&&o.uint32(32).int64(e.bpt),null!=e.vpt&&Object.hasOwnProperty.call(e,"vpt")&&o.uint32(40).int64(e.vpt),null!=e.rbh&&Object.hasOwnProperty.call(e,"rbh")&&o.uint32(48).int64(e.rbh),null!=e.sbh&&Object.hasOwnProperty.call(e,"sbh")&&o.uint32(56).int64(e.sbh),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(64).int64(e.gas),null!=e.tv&&Object.hasOwnProperty.call(e,"tv")&&o.uint32(72).int64(e.tv),null!=e.bpr&&Object.hasOwnProperty.call(e,"bpr")&&o.uint32(80).int64(e.bpr),null!=e.sbpr&&Object.hasOwnProperty.call(e,"sbpr")&&o.uint32(88).int64(e.sbpr),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeComponents,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.min=e.int64();break;case 2:d.max=e.int64();break;case 3:d.constant=e.int64();break;case 4:d.bpt=e.int64();break;case 5:d.vpt=e.int64();break;case 6:d.rbh=e.int64();break;case 7:d.sbh=e.int64();break;case 8:d.gas=e.int64();break;case 9:d.tv=e.int64();break;case 10:d.bpr=e.int64();break;case 11:d.sbpr=e.int64();break;default:e.skipType(7&i);}return d},e}(),TransactionFeeSchedule:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.hederaFunctionality=0,e.prototype.feeData=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.hederaFunctionality&&Object.hasOwnProperty.call(e,"hederaFunctionality")&&o.uint32(8).int32(e.hederaFunctionality),null!=e.feeData&&Object.hasOwnProperty.call(e,"feeData")&&$root.proto.FeeData.encode(e.feeData,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionFeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.hederaFunctionality=e.int32();break;case 2:d.feeData=$root.proto.FeeData.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FeeData:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodedata=null,e.prototype.networkdata=null,e.prototype.servicedata=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodedata&&Object.hasOwnProperty.call(e,"nodedata")&&$root.proto.FeeComponents.encode(e.nodedata,o.uint32(10).fork()).ldelim(),null!=e.networkdata&&Object.hasOwnProperty.call(e,"networkdata")&&$root.proto.FeeComponents.encode(e.networkdata,o.uint32(18).fork()).ldelim(),null!=e.servicedata&&Object.hasOwnProperty.call(e,"servicedata")&&$root.proto.FeeComponents.encode(e.servicedata,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeData,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodedata=$root.proto.FeeComponents.decode(e,e.uint32());break;case 2:d.networkdata=$root.proto.FeeComponents.decode(e,e.uint32());break;case 3:d.servicedata=$root.proto.FeeComponents.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FeeSchedule:function(){function e(e){if(this.transactionFeeSchedule=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transactionFeeSchedule=$util.emptyArray,e.prototype.expiryTime=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transactionFeeSchedule&&e.transactionFeeSchedule.length)for(var t=0;t<e.transactionFeeSchedule.length;++t)$root.proto.TransactionFeeSchedule.encode(e.transactionFeeSchedule[t],o.uint32(10).fork()).ldelim();return null!=e.expiryTime&&Object.hasOwnProperty.call(e,"expiryTime")&&$root.proto.TimestampSeconds.encode(e.expiryTime,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionFeeSchedule&&d.transactionFeeSchedule.length||(d.transactionFeeSchedule=[]),d.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(e,e.uint32()));break;case 2:d.expiryTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CurrentAndNextFeeSchedule:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.currentFeeSchedule=null,e.prototype.nextFeeSchedule=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.currentFeeSchedule&&Object.hasOwnProperty.call(e,"currentFeeSchedule")&&$root.proto.FeeSchedule.encode(e.currentFeeSchedule,o.uint32(10).fork()).ldelim(),null!=e.nextFeeSchedule&&Object.hasOwnProperty.call(e,"nextFeeSchedule")&&$root.proto.FeeSchedule.encode(e.nextFeeSchedule,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CurrentAndNextFeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.currentFeeSchedule=$root.proto.FeeSchedule.decode(e,e.uint32());break;case 2:d.nextFeeSchedule=$root.proto.FeeSchedule.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NodeEndpoint:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.ipAddress="",e.prototype.port="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.ipAddress&&Object.hasOwnProperty.call(e,"ipAddress")&&o.uint32(10).string(e.ipAddress),null!=e.port&&Object.hasOwnProperty.call(e,"port")&&o.uint32(18).string(e.port),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NodeEndpoint,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.ipAddress=e.string();break;case 2:d.port=e.string();break;default:e.skipType(7&i);}return d},e}(),NodeAddress:function(){function e(e){if(this.nodeEndpoint=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.ipAddress=$util.newBuffer([]),e.prototype.portno=0,e.prototype.memo=$util.newBuffer([]),e.prototype.RSA_PubKey="",e.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.nodeAccountId=null,e.prototype.nodeCertHash=$util.newBuffer([]),e.prototype.nodeEndpoint=$util.emptyArray,e.prototype.description="",e.prototype.stake=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.ipAddress&&Object.hasOwnProperty.call(e,"ipAddress")&&o.uint32(10).bytes(e.ipAddress),null!=e.portno&&Object.hasOwnProperty.call(e,"portno")&&o.uint32(16).int32(e.portno),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(26).bytes(e.memo),null!=e.RSA_PubKey&&Object.hasOwnProperty.call(e,"RSA_PubKey")&&o.uint32(34).string(e.RSA_PubKey),null!=e.nodeId&&Object.hasOwnProperty.call(e,"nodeId")&&o.uint32(40).int64(e.nodeId),null!=e.nodeAccountId&&Object.hasOwnProperty.call(e,"nodeAccountId")&&$root.proto.AccountID.encode(e.nodeAccountId,o.uint32(50).fork()).ldelim(),null!=e.nodeCertHash&&Object.hasOwnProperty.call(e,"nodeCertHash")&&o.uint32(58).bytes(e.nodeCertHash),null!=e.nodeEndpoint&&e.nodeEndpoint.length)for(var t=0;t<e.nodeEndpoint.length;++t)$root.proto.NodeEndpoint.encode(e.nodeEndpoint[t],o.uint32(66).fork()).ldelim();return null!=e.description&&Object.hasOwnProperty.call(e,"description")&&o.uint32(74).string(e.description),null!=e.stake&&Object.hasOwnProperty.call(e,"stake")&&o.uint32(80).int64(e.stake),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NodeAddress,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.ipAddress=e.bytes();break;case 2:d.portno=e.int32();break;case 3:d.memo=e.bytes();break;case 4:d.RSA_PubKey=e.string();break;case 5:d.nodeId=e.int64();break;case 6:d.nodeAccountId=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.nodeCertHash=e.bytes();break;case 8:d.nodeEndpoint&&d.nodeEndpoint.length||(d.nodeEndpoint=[]),d.nodeEndpoint.push($root.proto.NodeEndpoint.decode(e,e.uint32()));break;case 9:d.description=e.string();break;case 10:d.stake=e.int64();break;default:e.skipType(7&i);}return d},e}(),AddressBook:function(){function e(e){if(this.nodeAddress=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodeAddress=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nodeAddress&&e.nodeAddress.length)for(var t=0;t<e.nodeAddress.length;++t)$root.proto.NodeAddress.encode(e.nodeAddress[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AddressBook,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeAddress&&d.nodeAddress.length||(d.nodeAddress=[]),d.nodeAddress.push($root.proto.NodeAddress.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),NodeAddressForClients:function(){function e(e){if(this.nodeEndpoint=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.nodeAccountId=null,e.prototype.nodeCertHash=$util.newBuffer([]),e.prototype.nodeEndpoint=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nodeId&&Object.hasOwnProperty.call(e,"nodeId")&&o.uint32(40).int64(e.nodeId),null!=e.nodeAccountId&&Object.hasOwnProperty.call(e,"nodeAccountId")&&$root.proto.AccountID.encode(e.nodeAccountId,o.uint32(50).fork()).ldelim(),null!=e.nodeCertHash&&Object.hasOwnProperty.call(e,"nodeCertHash")&&o.uint32(58).bytes(e.nodeCertHash),null!=e.nodeEndpoint&&e.nodeEndpoint.length)for(var t=0;t<e.nodeEndpoint.length;++t)$root.proto.NodeEndpoint.encode(e.nodeEndpoint[t],o.uint32(66).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NodeAddressForClients,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 5:d.nodeId=e.int64();break;case 6:d.nodeAccountId=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.nodeCertHash=e.bytes();break;case 8:d.nodeEndpoint&&d.nodeEndpoint.length||(d.nodeEndpoint=[]),d.nodeEndpoint.push($root.proto.NodeEndpoint.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),AddressBookForClients:function(){function e(e){if(this.nodeAddressForClients=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodeAddressForClients=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nodeAddressForClients&&e.nodeAddressForClients.length)for(var t=0;t<e.nodeAddressForClients.length;++t)$root.proto.NodeAddressForClients.encode(e.nodeAddressForClients[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AddressBookForClients,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeAddressForClients&&d.nodeAddressForClients.length||(d.nodeAddressForClients=[]),d.nodeAddressForClients.push($root.proto.NodeAddressForClients.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),SemanticVersion:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.major=0,e.prototype.minor=0,e.prototype.patch=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.major&&Object.hasOwnProperty.call(e,"major")&&o.uint32(8).int32(e.major),null!=e.minor&&Object.hasOwnProperty.call(e,"minor")&&o.uint32(16).int32(e.minor),null!=e.patch&&Object.hasOwnProperty.call(e,"patch")&&o.uint32(24).int32(e.patch),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SemanticVersion,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.major=e.int32();break;case 2:d.minor=e.int32();break;case 3:d.patch=e.int32();break;default:e.skipType(7&i);}return d},e}(),Setting:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.name="",e.prototype.value="",e.prototype.data=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(18).string(e.value),null!=e.data&&Object.hasOwnProperty.call(e,"data")&&o.uint32(26).bytes(e.data),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Setting,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.value=e.string();break;case 3:d.data=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ServicesConfigurationList:function(){function e(e){if(this.nameValue=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nameValue=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nameValue&&e.nameValue.length)for(var t=0;t<e.nameValue.length;++t)$root.proto.Setting.encode(e.nameValue[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ServicesConfigurationList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nameValue&&d.nameValue.length||(d.nameValue=[]),d.nameValue.push($root.proto.Setting.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenRelationship:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenId=null,e.prototype.symbol="",e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.kycStatus=0,e.prototype.freezeStatus=0,e.prototype.decimals=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(24).uint64(e.balance),null!=e.kycStatus&&Object.hasOwnProperty.call(e,"kycStatus")&&o.uint32(32).int32(e.kycStatus),null!=e.freezeStatus&&Object.hasOwnProperty.call(e,"freezeStatus")&&o.uint32(40).int32(e.freezeStatus),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(48).uint32(e.decimals),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenRelationship,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.symbol=e.string();break;case 3:d.balance=e.uint64();break;case 4:d.kycStatus=e.int32();break;case 5:d.freezeStatus=e.int32();break;case 6:d.decimals=e.uint32();break;default:e.skipType(7&i);}return d},e}(),TokenBalance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenId=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.decimals=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(16).uint64(e.balance),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(24).uint32(e.decimals),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBalance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.balance=e.uint64();break;case 3:d.decimals=e.uint32();break;default:e.skipType(7&i);}return d},e}(),TokenBalances:function(){function e(e){if(this.tokenBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenBalances&&e.tokenBalances.length)for(var t=0;t<e.tokenBalances.length;++t)$root.proto.TokenBalance.encode(e.tokenBalances[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenBalances&&d.tokenBalances.length||(d.tokenBalances=[]),d.tokenBalances.push($root.proto.TokenBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),Timestamp:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.nanos=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),null!=e.nanos&&Object.hasOwnProperty.call(e,"nanos")&&o.uint32(16).int32(e.nanos),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Timestamp,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;case 2:d.nanos=e.int32();break;default:e.skipType(7&i);}return d},e}(),TimestampSeconds:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TimestampSeconds,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;default:e.skipType(7&i);}return d},e}(),ConsensusCreateTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.memo="",e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(10).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(18).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(26).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(50).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(58).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusCreateTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.memo=e.string();break;case 2:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 3:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 7:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),Duration:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Duration,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;default:e.skipType(7&i);}return d},e}(),ConsensusDeleteTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.topicID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusDeleteTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusGetTopicInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.topicID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusGetTopicInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusGetTopicInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.topicID=null,e.prototype.topicInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(18).fork()).ldelim(),null!=e.topicInfo&&Object.hasOwnProperty.call(e,"topicInfo")&&$root.proto.ConsensusTopicInfo.encode(e.topicInfo,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusGetTopicInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 5:d.topicInfo=$root.proto.ConsensusTopicInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ResponseType:function(){const e={},o=Object.create(e);return o[e[0]="ANSWER_ONLY"]=0,o[e[1]="ANSWER_STATE_PROOF"]=1,o[e[2]="COST_ANSWER"]=2,o[e[3]="COST_ANSWER_STATE_PROOF"]=3,o}(),QueryHeader:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.payment=null,e.prototype.responseType=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.payment&&Object.hasOwnProperty.call(e,"payment")&&$root.proto.Transaction.encode(e.payment,o.uint32(10).fork()).ldelim(),null!=e.responseType&&Object.hasOwnProperty.call(e,"responseType")&&o.uint32(16).int32(e.responseType),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.QueryHeader,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.payment=$root.proto.Transaction.decode(e,e.uint32());break;case 2:d.responseType=e.int32();break;default:e.skipType(7&i);}return d},e}(),Transaction:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.signedTransactionBytes=$util.newBuffer([]),e.prototype.bodyBytes=$util.newBuffer([]),e.prototype.sigMap=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.sigMap&&Object.hasOwnProperty.call(e,"sigMap")&&$root.proto.SignatureMap.encode(e.sigMap,o.uint32(26).fork()).ldelim(),null!=e.bodyBytes&&Object.hasOwnProperty.call(e,"bodyBytes")&&o.uint32(34).bytes(e.bodyBytes),null!=e.signedTransactionBytes&&Object.hasOwnProperty.call(e,"signedTransactionBytes")&&o.uint32(42).bytes(e.signedTransactionBytes),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Transaction,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 5:d.signedTransactionBytes=e.bytes();break;case 4:d.bodyBytes=e.bytes();break;case 3:d.sigMap=$root.proto.SignatureMap.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ResponseHeader:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodeTransactionPrecheckCode=0,e.prototype.responseType=0,e.prototype.cost=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.stateProof=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodeTransactionPrecheckCode&&Object.hasOwnProperty.call(e,"nodeTransactionPrecheckCode")&&o.uint32(8).int32(e.nodeTransactionPrecheckCode),null!=e.responseType&&Object.hasOwnProperty.call(e,"responseType")&&o.uint32(16).int32(e.responseType),null!=e.cost&&Object.hasOwnProperty.call(e,"cost")&&o.uint32(24).uint64(e.cost),null!=e.stateProof&&Object.hasOwnProperty.call(e,"stateProof")&&o.uint32(34).bytes(e.stateProof),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ResponseHeader,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeTransactionPrecheckCode=e.int32();break;case 2:d.responseType=e.int32();break;case 3:d.cost=e.uint64();break;case 4:d.stateProof=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TransactionResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.nodeTransactionPrecheckCode=0,e.prototype.cost=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodeTransactionPrecheckCode&&Object.hasOwnProperty.call(e,"nodeTransactionPrecheckCode")&&o.uint32(8).int32(e.nodeTransactionPrecheckCode),null!=e.cost&&Object.hasOwnProperty.call(e,"cost")&&o.uint32(16).uint64(e.cost),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeTransactionPrecheckCode=e.int32();break;case 2:d.cost=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ResponseCodeEnum:function(){const e={},o=Object.create(e);return o[e[0]="OK"]=0,o[e[1]="INVALID_TRANSACTION"]=1,o[e[2]="PAYER_ACCOUNT_NOT_FOUND"]=2,o[e[3]="INVALID_NODE_ACCOUNT"]=3,o[e[4]="TRANSACTION_EXPIRED"]=4,o[e[5]="INVALID_TRANSACTION_START"]=5,o[e[6]="INVALID_TRANSACTION_DURATION"]=6,o[e[7]="INVALID_SIGNATURE"]=7,o[e[8]="MEMO_TOO_LONG"]=8,o[e[9]="INSUFFICIENT_TX_FEE"]=9,o[e[10]="INSUFFICIENT_PAYER_BALANCE"]=10,o[e[11]="DUPLICATE_TRANSACTION"]=11,o[e[12]="BUSY"]=12,o[e[13]="NOT_SUPPORTED"]=13,o[e[14]="INVALID_FILE_ID"]=14,o[e[15]="INVALID_ACCOUNT_ID"]=15,o[e[16]="INVALID_CONTRACT_ID"]=16,o[e[17]="INVALID_TRANSACTION_ID"]=17,o[e[18]="RECEIPT_NOT_FOUND"]=18,o[e[19]="RECORD_NOT_FOUND"]=19,o[e[20]="INVALID_SOLIDITY_ID"]=20,o[e[21]="UNKNOWN"]=21,o[e[22]="SUCCESS"]=22,o[e[23]="FAIL_INVALID"]=23,o[e[24]="FAIL_FEE"]=24,o[e[25]="FAIL_BALANCE"]=25,o[e[26]="KEY_REQUIRED"]=26,o[e[27]="BAD_ENCODING"]=27,o[e[28]="INSUFFICIENT_ACCOUNT_BALANCE"]=28,o[e[29]="INVALID_SOLIDITY_ADDRESS"]=29,o[e[30]="INSUFFICIENT_GAS"]=30,o[e[31]="CONTRACT_SIZE_LIMIT_EXCEEDED"]=31,o[e[32]="LOCAL_CALL_MODIFICATION_EXCEPTION"]=32,o[e[33]="CONTRACT_REVERT_EXECUTED"]=33,o[e[34]="CONTRACT_EXECUTION_EXCEPTION"]=34,o[e[35]="INVALID_RECEIVING_NODE_ACCOUNT"]=35,o[e[36]="MISSING_QUERY_HEADER"]=36,o[e[37]="ACCOUNT_UPDATE_FAILED"]=37,o[e[38]="INVALID_KEY_ENCODING"]=38,o[e[39]="NULL_SOLIDITY_ADDRESS"]=39,o[e[40]="CONTRACT_UPDATE_FAILED"]=40,o[e[41]="INVALID_QUERY_HEADER"]=41,o[e[42]="INVALID_FEE_SUBMITTED"]=42,o[e[43]="INVALID_PAYER_SIGNATURE"]=43,o[e[44]="KEY_NOT_PROVIDED"]=44,o[e[45]="INVALID_EXPIRATION_TIME"]=45,o[e[46]="NO_WACL_KEY"]=46,o[e[47]="FILE_CONTENT_EMPTY"]=47,o[e[48]="INVALID_ACCOUNT_AMOUNTS"]=48,o[e[49]="EMPTY_TRANSACTION_BODY"]=49,o[e[50]="INVALID_TRANSACTION_BODY"]=50,o[e[51]="INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"]=51,o[e[52]="INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"]=52,o[e[53]="EMPTY_LIVE_HASH_BODY"]=53,o[e[54]="EMPTY_LIVE_HASH"]=54,o[e[55]="EMPTY_LIVE_HASH_KEYS"]=55,o[e[56]="INVALID_LIVE_HASH_SIZE"]=56,o[e[57]="EMPTY_QUERY_BODY"]=57,o[e[58]="EMPTY_LIVE_HASH_QUERY"]=58,o[e[59]="LIVE_HASH_NOT_FOUND"]=59,o[e[60]="ACCOUNT_ID_DOES_NOT_EXIST"]=60,o[e[61]="LIVE_HASH_ALREADY_EXISTS"]=61,o[e[62]="INVALID_FILE_WACL"]=62,o[e[63]="SERIALIZATION_FAILED"]=63,o[e[64]="TRANSACTION_OVERSIZE"]=64,o[e[65]="TRANSACTION_TOO_MANY_LAYERS"]=65,o[e[66]="CONTRACT_DELETED"]=66,o[e[67]="PLATFORM_NOT_ACTIVE"]=67,o[e[68]="KEY_PREFIX_MISMATCH"]=68,o[e[69]="PLATFORM_TRANSACTION_NOT_CREATED"]=69,o[e[70]="INVALID_RENEWAL_PERIOD"]=70,o[e[71]="INVALID_PAYER_ACCOUNT_ID"]=71,o[e[72]="ACCOUNT_DELETED"]=72,o[e[73]="FILE_DELETED"]=73,o[e[74]="ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"]=74,o[e[75]="SETTING_NEGATIVE_ACCOUNT_BALANCE"]=75,o[e[76]="OBTAINER_REQUIRED"]=76,o[e[77]="OBTAINER_SAME_CONTRACT_ID"]=77,o[e[78]="OBTAINER_DOES_NOT_EXIST"]=78,o[e[79]="MODIFYING_IMMUTABLE_CONTRACT"]=79,o[e[80]="FILE_SYSTEM_EXCEPTION"]=80,o[e[81]="AUTORENEW_DURATION_NOT_IN_RANGE"]=81,o[e[82]="ERROR_DECODING_BYTESTRING"]=82,o[e[83]="CONTRACT_FILE_EMPTY"]=83,o[e[84]="CONTRACT_BYTECODE_EMPTY"]=84,o[e[85]="INVALID_INITIAL_BALANCE"]=85,o[e[86]="INVALID_RECEIVE_RECORD_THRESHOLD"]=86,o[e[87]="INVALID_SEND_RECORD_THRESHOLD"]=87,o[e[88]="ACCOUNT_IS_NOT_GENESIS_ACCOUNT"]=88,o[e[89]="PAYER_ACCOUNT_UNAUTHORIZED"]=89,o[e[90]="INVALID_FREEZE_TRANSACTION_BODY"]=90,o[e[91]="FREEZE_TRANSACTION_BODY_NOT_FOUND"]=91,o[e[92]="TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=92,o[e[93]="RESULT_SIZE_LIMIT_EXCEEDED"]=93,o[e[94]="NOT_SPECIAL_ACCOUNT"]=94,o[e[95]="CONTRACT_NEGATIVE_GAS"]=95,o[e[96]="CONTRACT_NEGATIVE_VALUE"]=96,o[e[97]="INVALID_FEE_FILE"]=97,o[e[98]="INVALID_EXCHANGE_RATE_FILE"]=98,o[e[99]="INSUFFICIENT_LOCAL_CALL_GAS"]=99,o[e[100]="ENTITY_NOT_ALLOWED_TO_DELETE"]=100,o[e[101]="AUTHORIZATION_FAILED"]=101,o[e[102]="FILE_UPLOADED_PROTO_INVALID"]=102,o[e[103]="FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"]=103,o[e[104]="FEE_SCHEDULE_FILE_PART_UPLOADED"]=104,o[e[105]="EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"]=105,o[e[106]="MAX_CONTRACT_STORAGE_EXCEEDED"]=106,o[e[107]="TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"]=107,o[e[108]="TOTAL_LEDGER_BALANCE_INVALID"]=108,o[e[110]="EXPIRATION_REDUCTION_NOT_ALLOWED"]=110,o[e[111]="MAX_GAS_LIMIT_EXCEEDED"]=111,o[e[112]="MAX_FILE_SIZE_EXCEEDED"]=112,o[e[150]="INVALID_TOPIC_ID"]=150,o[e[155]="INVALID_ADMIN_KEY"]=155,o[e[156]="INVALID_SUBMIT_KEY"]=156,o[e[157]="UNAUTHORIZED"]=157,o[e[158]="INVALID_TOPIC_MESSAGE"]=158,o[e[159]="INVALID_AUTORENEW_ACCOUNT"]=159,o[e[160]="AUTORENEW_ACCOUNT_NOT_ALLOWED"]=160,o[e[162]="TOPIC_EXPIRED"]=162,o[e[163]="INVALID_CHUNK_NUMBER"]=163,o[e[164]="INVALID_CHUNK_TRANSACTION_ID"]=164,o[e[165]="ACCOUNT_FROZEN_FOR_TOKEN"]=165,o[e[166]="TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"]=166,o[e[167]="INVALID_TOKEN_ID"]=167,o[e[168]="INVALID_TOKEN_DECIMALS"]=168,o[e[169]="INVALID_TOKEN_INITIAL_SUPPLY"]=169,o[e[170]="INVALID_TREASURY_ACCOUNT_FOR_TOKEN"]=170,o[e[171]="INVALID_TOKEN_SYMBOL"]=171,o[e[172]="TOKEN_HAS_NO_FREEZE_KEY"]=172,o[e[173]="TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"]=173,o[e[174]="MISSING_TOKEN_SYMBOL"]=174,o[e[175]="TOKEN_SYMBOL_TOO_LONG"]=175,o[e[176]="ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"]=176,o[e[177]="TOKEN_HAS_NO_KYC_KEY"]=177,o[e[178]="INSUFFICIENT_TOKEN_BALANCE"]=178,o[e[179]="TOKEN_WAS_DELETED"]=179,o[e[180]="TOKEN_HAS_NO_SUPPLY_KEY"]=180,o[e[181]="TOKEN_HAS_NO_WIPE_KEY"]=181,o[e[182]="INVALID_TOKEN_MINT_AMOUNT"]=182,o[e[183]="INVALID_TOKEN_BURN_AMOUNT"]=183,o[e[184]="TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"]=184,o[e[185]="CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"]=185,o[e[186]="INVALID_KYC_KEY"]=186,o[e[187]="INVALID_WIPE_KEY"]=187,o[e[188]="INVALID_FREEZE_KEY"]=188,o[e[189]="INVALID_SUPPLY_KEY"]=189,o[e[190]="MISSING_TOKEN_NAME"]=190,o[e[191]="TOKEN_NAME_TOO_LONG"]=191,o[e[192]="INVALID_WIPING_AMOUNT"]=192,o[e[193]="TOKEN_IS_IMMUTABLE"]=193,o[e[194]="TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"]=194,o[e[195]="TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"]=195,o[e[196]="ACCOUNT_IS_TREASURY"]=196,o[e[197]="TOKEN_ID_REPEATED_IN_TOKEN_LIST"]=197,o[e[198]="TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=198,o[e[199]="EMPTY_TOKEN_TRANSFER_BODY"]=199,o[e[200]="EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"]=200,o[e[201]="INVALID_SCHEDULE_ID"]=201,o[e[202]="SCHEDULE_IS_IMMUTABLE"]=202,o[e[203]="INVALID_SCHEDULE_PAYER_ID"]=203,o[e[204]="INVALID_SCHEDULE_ACCOUNT_ID"]=204,o[e[205]="NO_NEW_VALID_SIGNATURES"]=205,o[e[206]="UNRESOLVABLE_REQUIRED_SIGNERS"]=206,o[e[207]="SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"]=207,o[e[208]="SOME_SIGNATURES_WERE_INVALID"]=208,o[e[209]="TRANSACTION_ID_FIELD_NOT_ALLOWED"]=209,o[e[210]="IDENTICAL_SCHEDULE_ALREADY_CREATED"]=210,o[e[211]="INVALID_ZERO_BYTE_IN_STRING"]=211,o[e[212]="SCHEDULE_ALREADY_DELETED"]=212,o[e[213]="SCHEDULE_ALREADY_EXECUTED"]=213,o[e[214]="MESSAGE_SIZE_TOO_LARGE"]=214,o[e[215]="OPERATION_REPEATED_IN_BUCKET_GROUPS"]=215,o[e[216]="BUCKET_CAPACITY_OVERFLOW"]=216,o[e[217]="NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"]=217,o[e[218]="BUCKET_HAS_NO_THROTTLE_GROUPS"]=218,o[e[219]="THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"]=219,o[e[220]="SUCCESS_BUT_MISSING_EXPECTED_OPERATION"]=220,o[e[221]="UNPARSEABLE_THROTTLE_DEFINITIONS"]=221,o[e[222]="INVALID_THROTTLE_DEFINITIONS"]=222,o}(),ConsensusTopicInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.memo="",e.prototype.runningHash=$util.newBuffer([]),e.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(10).string(e.memo),null!=e.runningHash&&Object.hasOwnProperty.call(e,"runningHash")&&o.uint32(18).bytes(e.runningHash),null!=e.sequenceNumber&&Object.hasOwnProperty.call(e,"sequenceNumber")&&o.uint32(24).uint64(e.sequenceNumber),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(42).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(58).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(66).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.memo=e.string();break;case 2:d.runningHash=e.bytes();break;case 3:d.sequenceNumber=e.uint64();break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 5:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 8:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createTopic=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createTopic"}),Object.defineProperty(e.prototype.updateTopic=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"updateTopic"}),Object.defineProperty(e.prototype.deleteTopic=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteTopic"}),Object.defineProperty(e.prototype.getTopicInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getTopicInfo"}),Object.defineProperty(e.prototype.submitMessage=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"submitMessage"}),e}(),Query:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.getByKey=null,e.prototype.getBySolidityID=null,e.prototype.contractCallLocal=null,e.prototype.contractGetInfo=null,e.prototype.contractGetBytecode=null,e.prototype.ContractGetRecords=null,e.prototype.cryptogetAccountBalance=null,e.prototype.cryptoGetAccountRecords=null,e.prototype.cryptoGetInfo=null,e.prototype.cryptoGetLiveHash=null,e.prototype.cryptoGetProxyStakers=null,e.prototype.fileGetContents=null,e.prototype.fileGetInfo=null,e.prototype.transactionGetReceipt=null,e.prototype.transactionGetRecord=null,e.prototype.transactionGetFastRecord=null,e.prototype.consensusGetTopicInfo=null,e.prototype.networkGetVersionInfo=null,e.prototype.tokenGetInfo=null,e.prototype.scheduleGetInfo=null;let o;return Object.defineProperty(e.prototype,"query",{get:$util.oneOfGetter(o=["getByKey","getBySolidityID","contractCallLocal","contractGetInfo","contractGetBytecode","ContractGetRecords","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.getByKey&&Object.hasOwnProperty.call(e,"getByKey")&&$root.proto.GetByKeyQuery.encode(e.getByKey,o.uint32(10).fork()).ldelim(),null!=e.getBySolidityID&&Object.hasOwnProperty.call(e,"getBySolidityID")&&$root.proto.GetBySolidityIDQuery.encode(e.getBySolidityID,o.uint32(18).fork()).ldelim(),null!=e.contractCallLocal&&Object.hasOwnProperty.call(e,"contractCallLocal")&&$root.proto.ContractCallLocalQuery.encode(e.contractCallLocal,o.uint32(26).fork()).ldelim(),null!=e.contractGetInfo&&Object.hasOwnProperty.call(e,"contractGetInfo")&&$root.proto.ContractGetInfoQuery.encode(e.contractGetInfo,o.uint32(34).fork()).ldelim(),null!=e.contractGetBytecode&&Object.hasOwnProperty.call(e,"contractGetBytecode")&&$root.proto.ContractGetBytecodeQuery.encode(e.contractGetBytecode,o.uint32(42).fork()).ldelim(),null!=e.ContractGetRecords&&Object.hasOwnProperty.call(e,"ContractGetRecords")&&$root.proto.ContractGetRecordsQuery.encode(e.ContractGetRecords,o.uint32(50).fork()).ldelim(),null!=e.cryptogetAccountBalance&&Object.hasOwnProperty.call(e,"cryptogetAccountBalance")&&$root.proto.CryptoGetAccountBalanceQuery.encode(e.cryptogetAccountBalance,o.uint32(58).fork()).ldelim(),null!=e.cryptoGetAccountRecords&&Object.hasOwnProperty.call(e,"cryptoGetAccountRecords")&&$root.proto.CryptoGetAccountRecordsQuery.encode(e.cryptoGetAccountRecords,o.uint32(66).fork()).ldelim(),null!=e.cryptoGetInfo&&Object.hasOwnProperty.call(e,"cryptoGetInfo")&&$root.proto.CryptoGetInfoQuery.encode(e.cryptoGetInfo,o.uint32(74).fork()).ldelim(),null!=e.cryptoGetLiveHash&&Object.hasOwnProperty.call(e,"cryptoGetLiveHash")&&$root.proto.CryptoGetLiveHashQuery.encode(e.cryptoGetLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoGetProxyStakers&&Object.hasOwnProperty.call(e,"cryptoGetProxyStakers")&&$root.proto.CryptoGetStakersQuery.encode(e.cryptoGetProxyStakers,o.uint32(90).fork()).ldelim(),null!=e.fileGetContents&&Object.hasOwnProperty.call(e,"fileGetContents")&&$root.proto.FileGetContentsQuery.encode(e.fileGetContents,o.uint32(98).fork()).ldelim(),null!=e.fileGetInfo&&Object.hasOwnProperty.call(e,"fileGetInfo")&&$root.proto.FileGetInfoQuery.encode(e.fileGetInfo,o.uint32(106).fork()).ldelim(),null!=e.transactionGetReceipt&&Object.hasOwnProperty.call(e,"transactionGetReceipt")&&$root.proto.TransactionGetReceiptQuery.encode(e.transactionGetReceipt,o.uint32(114).fork()).ldelim(),null!=e.transactionGetRecord&&Object.hasOwnProperty.call(e,"transactionGetRecord")&&$root.proto.TransactionGetRecordQuery.encode(e.transactionGetRecord,o.uint32(122).fork()).ldelim(),null!=e.transactionGetFastRecord&&Object.hasOwnProperty.call(e,"transactionGetFastRecord")&&$root.proto.TransactionGetFastRecordQuery.encode(e.transactionGetFastRecord,o.uint32(130).fork()).ldelim(),null!=e.consensusGetTopicInfo&&Object.hasOwnProperty.call(e,"consensusGetTopicInfo")&&$root.proto.ConsensusGetTopicInfoQuery.encode(e.consensusGetTopicInfo,o.uint32(402).fork()).ldelim(),null!=e.networkGetVersionInfo&&Object.hasOwnProperty.call(e,"networkGetVersionInfo")&&$root.proto.NetworkGetVersionInfoQuery.encode(e.networkGetVersionInfo,o.uint32(410).fork()).ldelim(),null!=e.tokenGetInfo&&Object.hasOwnProperty.call(e,"tokenGetInfo")&&$root.proto.TokenGetInfoQuery.encode(e.tokenGetInfo,o.uint32(418).fork()).ldelim(),null!=e.scheduleGetInfo&&Object.hasOwnProperty.call(e,"scheduleGetInfo")&&$root.proto.ScheduleGetInfoQuery.encode(e.scheduleGetInfo,o.uint32(426).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Query,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.getByKey=$root.proto.GetByKeyQuery.decode(e,e.uint32());break;case 2:d.getBySolidityID=$root.proto.GetBySolidityIDQuery.decode(e,e.uint32());break;case 3:d.contractCallLocal=$root.proto.ContractCallLocalQuery.decode(e,e.uint32());break;case 4:d.contractGetInfo=$root.proto.ContractGetInfoQuery.decode(e,e.uint32());break;case 5:d.contractGetBytecode=$root.proto.ContractGetBytecodeQuery.decode(e,e.uint32());break;case 6:d.ContractGetRecords=$root.proto.ContractGetRecordsQuery.decode(e,e.uint32());break;case 7:d.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceQuery.decode(e,e.uint32());break;case 8:d.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsQuery.decode(e,e.uint32());break;case 9:d.cryptoGetInfo=$root.proto.CryptoGetInfoQuery.decode(e,e.uint32());break;case 10:d.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashQuery.decode(e,e.uint32());break;case 11:d.cryptoGetProxyStakers=$root.proto.CryptoGetStakersQuery.decode(e,e.uint32());break;case 12:d.fileGetContents=$root.proto.FileGetContentsQuery.decode(e,e.uint32());break;case 13:d.fileGetInfo=$root.proto.FileGetInfoQuery.decode(e,e.uint32());break;case 14:d.transactionGetReceipt=$root.proto.TransactionGetReceiptQuery.decode(e,e.uint32());break;case 15:d.transactionGetRecord=$root.proto.TransactionGetRecordQuery.decode(e,e.uint32());break;case 16:d.transactionGetFastRecord=$root.proto.TransactionGetFastRecordQuery.decode(e,e.uint32());break;case 50:d.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoQuery.decode(e,e.uint32());break;case 51:d.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoQuery.decode(e,e.uint32());break;case 52:d.tokenGetInfo=$root.proto.TokenGetInfoQuery.decode(e,e.uint32());break;case 53:d.scheduleGetInfo=$root.proto.ScheduleGetInfoQuery.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),GetByKeyQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.key=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetByKeyQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.key=$root.proto.Key.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),EntityID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.accountID=null,e.prototype.liveHash=null,e.prototype.fileID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"entity",{get:$util.oneOfGetter(o=["accountID","liveHash","fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.EntityID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),GetByKeyResponse:function(){function e(e){if(this.entities=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.entities=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.entities&&e.entities.length)for(var t=0;t<e.entities.length;++t)$root.proto.EntityID.encode(e.entities[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetByKeyResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.entities&&d.entities.length||(d.entities=[]),d.entities.push($root.proto.EntityID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),LiveHash:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountId=null,e.prototype.hash=$util.newBuffer([]),e.prototype.keys=null,e.prototype.duration=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountId&&Object.hasOwnProperty.call(e,"accountId")&&$root.proto.AccountID.encode(e.accountId,o.uint32(10).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(18).bytes(e.hash),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.duration&&Object.hasOwnProperty.call(e,"duration")&&$root.proto.Duration.encode(e.duration,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.LiveHash,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountId=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hash=e.bytes();break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 5:d.duration=$root.proto.Duration.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoAddLiveHashTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.liveHash=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoAddLiveHashTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 3:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),GetBySolidityIDQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.solidityID="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.solidityID&&Object.hasOwnProperty.call(e,"solidityID")&&o.uint32(18).string(e.solidityID),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetBySolidityIDQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.solidityID=e.string();break;default:e.skipType(7&i);}return d},e}(),GetBySolidityIDResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.fileID=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetBySolidityIDResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractLoginfo:function(){function e(e){if(this.topic=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.contractID=null,e.prototype.bloom=$util.newBuffer([]),e.prototype.topic=$util.emptyArray,e.prototype.data=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.bloom&&Object.hasOwnProperty.call(e,"bloom")&&o.uint32(18).bytes(e.bloom),null!=e.topic&&e.topic.length)for(var t=0;t<e.topic.length;++t)o.uint32(26).bytes(e.topic[t]);return null!=e.data&&Object.hasOwnProperty.call(e,"data")&&o.uint32(34).bytes(e.data),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractLoginfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.bloom=e.bytes();break;case 3:d.topic&&d.topic.length||(d.topic=[]),d.topic.push(e.bytes());break;case 4:d.data=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractFunctionResult:function(){function e(e){if(this.logInfo=[],this.createdContractIDs=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.contractID=null,e.prototype.contractCallResult=$util.newBuffer([]),e.prototype.errorMessage="",e.prototype.bloom=$util.newBuffer([]),e.prototype.gasUsed=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.logInfo=$util.emptyArray,e.prototype.createdContractIDs=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.contractCallResult&&Object.hasOwnProperty.call(e,"contractCallResult")&&o.uint32(18).bytes(e.contractCallResult),null!=e.errorMessage&&Object.hasOwnProperty.call(e,"errorMessage")&&o.uint32(26).string(e.errorMessage),null!=e.bloom&&Object.hasOwnProperty.call(e,"bloom")&&o.uint32(34).bytes(e.bloom),null!=e.gasUsed&&Object.hasOwnProperty.call(e,"gasUsed")&&o.uint32(40).uint64(e.gasUsed),null!=e.logInfo&&e.logInfo.length)for(var t=0;t<e.logInfo.length;++t)$root.proto.ContractLoginfo.encode(e.logInfo[t],o.uint32(50).fork()).ldelim();if(null!=e.createdContractIDs&&e.createdContractIDs.length)for(var t=0;t<e.createdContractIDs.length;++t)$root.proto.ContractID.encode(e.createdContractIDs[t],o.uint32(58).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractFunctionResult,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.contractCallResult=e.bytes();break;case 3:d.errorMessage=e.string();break;case 4:d.bloom=e.bytes();break;case 5:d.gasUsed=e.uint64();break;case 6:d.logInfo&&d.logInfo.length||(d.logInfo=[]),d.logInfo.push($root.proto.ContractLoginfo.decode(e,e.uint32()));break;case 7:d.createdContractIDs&&d.createdContractIDs.length||(d.createdContractIDs=[]),d.createdContractIDs.push($root.proto.ContractID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ContractCallLocalQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractID=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.functionParameters=$util.newBuffer([]),e.prototype.maxResultSize=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(24).int64(e.gas),null!=e.functionParameters&&Object.hasOwnProperty.call(e,"functionParameters")&&o.uint32(34).bytes(e.functionParameters),null!=e.maxResultSize&&Object.hasOwnProperty.call(e,"maxResultSize")&&o.uint32(40).int64(e.maxResultSize),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallLocalQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.gas=e.int64();break;case 4:d.functionParameters=e.bytes();break;case 5:d.maxResultSize=e.int64();break;default:e.skipType(7&i);}return d},e}(),ContractCallLocalResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.functionResult=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.functionResult&&Object.hasOwnProperty.call(e,"functionResult")&&$root.proto.ContractFunctionResult.encode(e.functionResult,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallLocalResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.functionResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractInfo&&Object.hasOwnProperty.call(e,"contractInfo")&&$root.proto.ContractGetInfoResponse.ContractInfo.encode(e.contractInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.contractInfo=$root.proto.ContractGetInfoResponse.ContractInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.ContractInfo=function(){function e(e){if(this.tokenRelationships=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.contractID=null,e.prototype.accountID=null,e.prototype.contractAccountID="",e.prototype.adminKey=null,e.prototype.expirationTime=null,e.prototype.autoRenewPeriod=null,e.prototype.storage=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.memo="",e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.deleted=!1,e.prototype.tokenRelationships=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.contractAccountID&&Object.hasOwnProperty.call(e,"contractAccountID")&&o.uint32(26).string(e.contractAccountID),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(34).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(42).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(50).fork()).ldelim(),null!=e.storage&&Object.hasOwnProperty.call(e,"storage")&&o.uint32(56).int64(e.storage),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(66).string(e.memo),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(72).uint64(e.balance),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(80).bool(e.deleted),null!=e.tokenRelationships&&e.tokenRelationships.length)for(var t=0;t<e.tokenRelationships.length;++t)$root.proto.TokenRelationship.encode(e.tokenRelationships[t],o.uint32(90).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoResponse.ContractInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.contractAccountID=e.string();break;case 4:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 5:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 6:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 7:d.storage=e.int64();break;case 8:d.memo=e.string();break;case 9:d.balance=e.uint64();break;case 10:d.deleted=e.bool();break;case 11:d.tokenRelationships&&d.tokenRelationships.length||(d.tokenRelationships=[]),d.tokenRelationships.push($root.proto.TokenRelationship.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),e}(),ContractGetBytecodeQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetBytecodeQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetBytecodeResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.bytecode=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.bytecode&&Object.hasOwnProperty.call(e,"bytecode")&&o.uint32(50).bytes(e.bytecode),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetBytecodeResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 6:d.bytecode=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractGetRecordsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetRecordsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetRecordsResponse:function(){function e(e){if(this.records=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.contractID=null,e.prototype.records=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.records&&e.records.length)for(var t=0;t<e.records.length;++t)$root.proto.TransactionRecord.encode(e.records[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetRecordsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.records&&d.records.length||(d.records=[]),d.records.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionRecord:function(){function e(e){if(this.tokenTransferLists=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.receipt=null,e.prototype.transactionHash=$util.newBuffer([]),e.prototype.consensusTimestamp=null,e.prototype.transactionID=null,e.prototype.memo="",e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.contractCallResult=null,e.prototype.contractCreateResult=null,e.prototype.transferList=null,e.prototype.tokenTransferLists=$util.emptyArray,e.prototype.scheduleRef=null;let o;return Object.defineProperty(e.prototype,"body",{get:$util.oneOfGetter(o=["contractCallResult","contractCreateResult"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.receipt&&Object.hasOwnProperty.call(e,"receipt")&&$root.proto.TransactionReceipt.encode(e.receipt,o.uint32(10).fork()).ldelim(),null!=e.transactionHash&&Object.hasOwnProperty.call(e,"transactionHash")&&o.uint32(18).bytes(e.transactionHash),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(26).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(34).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(42).string(e.memo),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(48).uint64(e.transactionFee),null!=e.contractCallResult&&Object.hasOwnProperty.call(e,"contractCallResult")&&$root.proto.ContractFunctionResult.encode(e.contractCallResult,o.uint32(58).fork()).ldelim(),null!=e.contractCreateResult&&Object.hasOwnProperty.call(e,"contractCreateResult")&&$root.proto.ContractFunctionResult.encode(e.contractCreateResult,o.uint32(66).fork()).ldelim(),null!=e.transferList&&Object.hasOwnProperty.call(e,"transferList")&&$root.proto.TransferList.encode(e.transferList,o.uint32(82).fork()).ldelim(),null!=e.tokenTransferLists&&e.tokenTransferLists.length)for(var t=0;t<e.tokenTransferLists.length;++t)$root.proto.TokenTransferList.encode(e.tokenTransferLists[t],o.uint32(90).fork()).ldelim();return null!=e.scheduleRef&&Object.hasOwnProperty.call(e,"scheduleRef")&&$root.proto.ScheduleID.encode(e.scheduleRef,o.uint32(98).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionRecord,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.receipt=$root.proto.TransactionReceipt.decode(e,e.uint32());break;case 2:d.transactionHash=e.bytes();break;case 3:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 5:d.memo=e.string();break;case 6:d.transactionFee=e.uint64();break;case 7:d.contractCallResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;case 8:d.contractCreateResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;case 10:d.transferList=$root.proto.TransferList.decode(e,e.uint32());break;case 11:d.tokenTransferLists&&d.tokenTransferLists.length||(d.tokenTransferLists=[]),d.tokenTransferLists.push($root.proto.TokenTransferList.decode(e,e.uint32()));break;case 12:d.scheduleRef=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TransactionReceipt:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.status=0,e.prototype.accountID=null,e.prototype.fileID=null,e.prototype.contractID=null,e.prototype.exchangeRate=null,e.prototype.topicID=null,e.prototype.topicSequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.topicRunningHash=$util.newBuffer([]),e.prototype.topicRunningHashVersion=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenID=null,e.prototype.newTotalSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.scheduleID=null,e.prototype.scheduledTransactionID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.status&&Object.hasOwnProperty.call(e,"status")&&o.uint32(8).int32(e.status),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),null!=e.exchangeRate&&Object.hasOwnProperty.call(e,"exchangeRate")&&$root.proto.ExchangeRateSet.encode(e.exchangeRate,o.uint32(42).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(50).fork()).ldelim(),null!=e.topicSequenceNumber&&Object.hasOwnProperty.call(e,"topicSequenceNumber")&&o.uint32(56).uint64(e.topicSequenceNumber),null!=e.topicRunningHash&&Object.hasOwnProperty.call(e,"topicRunningHash")&&o.uint32(66).bytes(e.topicRunningHash),null!=e.topicRunningHashVersion&&Object.hasOwnProperty.call(e,"topicRunningHashVersion")&&o.uint32(72).uint64(e.topicRunningHashVersion),null!=e.tokenID&&Object.hasOwnProperty.call(e,"tokenID")&&$root.proto.TokenID.encode(e.tokenID,o.uint32(82).fork()).ldelim(),null!=e.newTotalSupply&&Object.hasOwnProperty.call(e,"newTotalSupply")&&o.uint32(88).uint64(e.newTotalSupply),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(98).fork()).ldelim(),null!=e.scheduledTransactionID&&Object.hasOwnProperty.call(e,"scheduledTransactionID")&&$root.proto.TransactionID.encode(e.scheduledTransactionID,o.uint32(106).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionReceipt,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.status=e.int32();break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 5:d.exchangeRate=$root.proto.ExchangeRateSet.decode(e,e.uint32());break;case 6:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 7:d.topicSequenceNumber=e.uint64();break;case 8:d.topicRunningHash=e.bytes();break;case 9:d.topicRunningHashVersion=e.uint64();break;case 10:d.tokenID=$root.proto.TokenID.decode(e,e.uint32());break;case 11:d.newTotalSupply=e.uint64();break;case 12:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;case 13:d.scheduledTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ExchangeRate:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.hbarEquiv=0,e.prototype.centEquiv=0,e.prototype.expirationTime=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.hbarEquiv&&Object.hasOwnProperty.call(e,"hbarEquiv")&&o.uint32(8).int32(e.hbarEquiv),null!=e.centEquiv&&Object.hasOwnProperty.call(e,"centEquiv")&&o.uint32(16).int32(e.centEquiv),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.TimestampSeconds.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ExchangeRate,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.hbarEquiv=e.int32();break;case 2:d.centEquiv=e.int32();break;case 3:d.expirationTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ExchangeRateSet:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.currentRate=null,e.prototype.nextRate=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.currentRate&&Object.hasOwnProperty.call(e,"currentRate")&&$root.proto.ExchangeRate.encode(e.currentRate,o.uint32(10).fork()).ldelim(),null!=e.nextRate&&Object.hasOwnProperty.call(e,"nextRate")&&$root.proto.ExchangeRate.encode(e.nextRate,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ExchangeRateSet,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.currentRate=$root.proto.ExchangeRate.decode(e,e.uint32());break;case 2:d.nextRate=$root.proto.ExchangeRate.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoTransferTransactionBody:function(){function e(e){if(this.tokenTransfers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transfers=null,e.prototype.tokenTransfers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transfers&&Object.hasOwnProperty.call(e,"transfers")&&$root.proto.TransferList.encode(e.transfers,o.uint32(10).fork()).ldelim(),null!=e.tokenTransfers&&e.tokenTransfers.length)for(var t=0;t<e.tokenTransfers.length;++t)$root.proto.TokenTransferList.encode(e.tokenTransfers[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoTransferTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transfers=$root.proto.TransferList.decode(e,e.uint32());break;case 2:d.tokenTransfers&&d.tokenTransfers.length||(d.tokenTransfers=[]),d.tokenTransfers.push($root.proto.TokenTransferList.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountBalanceQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.header=null,e.prototype.accountID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"balanceSource",{get:$util.oneOfGetter(o=["accountID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountBalanceQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountBalanceResponse:function(){function e(e){if(this.tokenBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(24).uint64(e.balance),null!=e.tokenBalances&&e.tokenBalances.length)for(var t=0;t<e.tokenBalances.length;++t)$root.proto.TokenBalance.encode(e.tokenBalances[t],o.uint32(34).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountBalanceResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.balance=e.uint64();break;case 4:d.tokenBalances&&d.tokenBalances.length||(d.tokenBalances=[]),d.tokenBalances.push($root.proto.TokenBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountRecordsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountRecordsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountRecordsResponse:function(){function e(e){if(this.records=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.records=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.records&&e.records.length)for(var t=0;t<e.records.length;++t)$root.proto.TransactionRecord.encode(e.records[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountRecordsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.records&&d.records.length||(d.records=[]),d.records.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountInfo&&Object.hasOwnProperty.call(e,"accountInfo")&&$root.proto.CryptoGetInfoResponse.AccountInfo.encode(e.accountInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountInfo=$root.proto.CryptoGetInfoResponse.AccountInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.AccountInfo=function(){function e(e){if(this.liveHashes=[],this.tokenRelationships=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.contractAccountID="",e.prototype.deleted=!1,e.prototype.proxyAccountID=null,e.prototype.proxyReceived=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.key=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.generateSendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.generateReceiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiverSigRequired=!1,e.prototype.expirationTime=null,e.prototype.autoRenewPeriod=null,e.prototype.liveHashes=$util.emptyArray,e.prototype.tokenRelationships=$util.emptyArray,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.contractAccountID&&Object.hasOwnProperty.call(e,"contractAccountID")&&o.uint32(18).string(e.contractAccountID),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(24).bool(e.deleted),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(34).fork()).ldelim(),null!=e.proxyReceived&&Object.hasOwnProperty.call(e,"proxyReceived")&&o.uint32(48).int64(e.proxyReceived),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(58).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(64).uint64(e.balance),null!=e.generateSendRecordThreshold&&Object.hasOwnProperty.call(e,"generateSendRecordThreshold")&&o.uint32(72).uint64(e.generateSendRecordThreshold),null!=e.generateReceiveRecordThreshold&&Object.hasOwnProperty.call(e,"generateReceiveRecordThreshold")&&o.uint32(80).uint64(e.generateReceiveRecordThreshold),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(88).bool(e.receiverSigRequired),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(98).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(106).fork()).ldelim(),null!=e.liveHashes&&e.liveHashes.length)for(var t=0;t<e.liveHashes.length;++t)$root.proto.LiveHash.encode(e.liveHashes[t],o.uint32(114).fork()).ldelim();if(null!=e.tokenRelationships&&e.tokenRelationships.length)for(var t=0;t<e.tokenRelationships.length;++t)$root.proto.TokenRelationship.encode(e.tokenRelationships[t],o.uint32(122).fork()).ldelim();return null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(130).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoResponse.AccountInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.contractAccountID=e.string();break;case 3:d.deleted=e.bool();break;case 4:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.proxyReceived=e.int64();break;case 7:d.key=$root.proto.Key.decode(e,e.uint32());break;case 8:d.balance=e.uint64();break;case 9:d.generateSendRecordThreshold=e.uint64();break;case 10:d.generateReceiveRecordThreshold=e.uint64();break;case 11:d.receiverSigRequired=e.bool();break;case 12:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 13:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 14:d.liveHashes&&d.liveHashes.length||(d.liveHashes=[]),d.liveHashes.push($root.proto.LiveHash.decode(e,e.uint32()));break;case 15:d.tokenRelationships&&d.tokenRelationships.length||(d.tokenRelationships=[]),d.tokenRelationships.push($root.proto.TokenRelationship.decode(e,e.uint32()));break;case 16:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),e}(),CryptoGetLiveHashQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.hash=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(26).bytes(e.hash),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetLiveHashQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.hash=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoGetLiveHashResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.liveHash=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetLiveHashResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetStakersQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetStakersQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ProxyStaker:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ProxyStaker,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),AllProxyStakers:function(){function e(e){if(this.proxyStaker=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.proxyStaker=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.proxyStaker&&e.proxyStaker.length)for(var t=0;t<e.proxyStaker.length;++t)$root.proto.ProxyStaker.encode(e.proxyStaker[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AllProxyStakers,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.proxyStaker&&d.proxyStaker.length||(d.proxyStaker=[]),d.proxyStaker.push($root.proto.ProxyStaker.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetStakersResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.stakers=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.stakers&&Object.hasOwnProperty.call(e,"stakers")&&$root.proto.AllProxyStakers.encode(e.stakers,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetStakersResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 3:d.stakers=$root.proto.AllProxyStakers.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetContentsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetContentsResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.fileContents=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileContents&&Object.hasOwnProperty.call(e,"fileContents")&&$root.proto.FileGetContentsResponse.FileContents.encode(e.fileContents,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.fileContents=$root.proto.FileGetContentsResponse.FileContents.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.FileContents=function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.prototype.contents=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(18).bytes(e.contents),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsResponse.FileContents,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contents=e.bytes();break;default:e.skipType(7&i);}return d},e}(),e}(),FileGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.fileInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileInfo&&Object.hasOwnProperty.call(e,"fileInfo")&&$root.proto.FileGetInfoResponse.FileInfo.encode(e.fileInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.fileInfo=$root.proto.FileGetInfoResponse.FileInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.FileInfo=function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.prototype.size=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.expirationTime=null,e.prototype.deleted=!1,e.prototype.keys=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.size&&Object.hasOwnProperty.call(e,"size")&&o.uint32(16).int64(e.size),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(32).bool(e.deleted),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(42).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoResponse.FileInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.size=e.int64();break;case 3:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.deleted=e.bool();break;case 5:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 6:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),e}(),TransactionGetReceiptQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.transactionID=null,e.prototype.includeDuplicates=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),null!=e.includeDuplicates&&Object.hasOwnProperty.call(e,"includeDuplicates")&&o.uint32(24).bool(e.includeDuplicates),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetReceiptQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 3:d.includeDuplicates=e.bool();break;default:e.skipType(7&i);}return d},e}(),TransactionGetReceiptResponse:function(){function e(e){if(this.duplicateTransactionReceipts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.receipt=null,e.prototype.duplicateTransactionReceipts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.receipt&&Object.hasOwnProperty.call(e,"receipt")&&$root.proto.TransactionReceipt.encode(e.receipt,o.uint32(18).fork()).ldelim(),null!=e.duplicateTransactionReceipts&&e.duplicateTransactionReceipts.length)for(var t=0;t<e.duplicateTransactionReceipts.length;++t)$root.proto.TransactionReceipt.encode(e.duplicateTransactionReceipts[t],o.uint32(34).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetReceiptResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.receipt=$root.proto.TransactionReceipt.decode(e,e.uint32());break;case 4:d.duplicateTransactionReceipts&&d.duplicateTransactionReceipts.length||(d.duplicateTransactionReceipts=[]),d.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionGetRecordQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.transactionID=null,e.prototype.includeDuplicates=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),null!=e.includeDuplicates&&Object.hasOwnProperty.call(e,"includeDuplicates")&&o.uint32(24).bool(e.includeDuplicates),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetRecordQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 3:d.includeDuplicates=e.bool();break;default:e.skipType(7&i);}return d},e}(),TransactionGetRecordResponse:function(){function e(e){if(this.duplicateTransactionRecords=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.transactionRecord=null,e.prototype.duplicateTransactionRecords=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionRecord&&Object.hasOwnProperty.call(e,"transactionRecord")&&$root.proto.TransactionRecord.encode(e.transactionRecord,o.uint32(26).fork()).ldelim(),null!=e.duplicateTransactionRecords&&e.duplicateTransactionRecords.length)for(var t=0;t<e.duplicateTransactionRecords.length;++t)$root.proto.TransactionRecord.encode(e.duplicateTransactionRecords[t],o.uint32(34).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetRecordResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 3:d.transactionRecord=$root.proto.TransactionRecord.decode(e,e.uint32());break;case 4:d.duplicateTransactionRecords&&d.duplicateTransactionRecords.length||(d.duplicateTransactionRecords=[]),d.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionGetFastRecordQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.transactionID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetFastRecordQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TransactionGetFastRecordResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.transactionRecord=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionRecord&&Object.hasOwnProperty.call(e,"transactionRecord")&&$root.proto.TransactionRecord.encode(e.transactionRecord,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetFastRecordResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.transactionRecord=$root.proto.TransactionRecord.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NetworkGetVersionInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetVersionInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NetworkGetVersionInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.hapiProtoVersion=null,e.prototype.hederaServicesVersion=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.hapiProtoVersion&&Object.hasOwnProperty.call(e,"hapiProtoVersion")&&$root.proto.SemanticVersion.encode(e.hapiProtoVersion,o.uint32(18).fork()).ldelim(),null!=e.hederaServicesVersion&&Object.hasOwnProperty.call(e,"hederaServicesVersion")&&$root.proto.SemanticVersion.encode(e.hederaServicesVersion,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetVersionInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.hapiProtoVersion=$root.proto.SemanticVersion.decode(e,e.uint32());break;case 3:d.hederaServicesVersion=$root.proto.SemanticVersion.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenId=null,e.prototype.name="",e.prototype.symbol="",e.prototype.decimals=0,e.prototype.totalSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.defaultFreezeStatus=0,e.prototype.defaultKycStatus=0,e.prototype.deleted=!1,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.expiry=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(18).string(e.name),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(26).string(e.symbol),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(32).uint32(e.decimals),null!=e.totalSupply&&Object.hasOwnProperty.call(e,"totalSupply")&&o.uint32(40).uint64(e.totalSupply),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(50).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(58).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(66).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(74).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(82).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(90).fork()).ldelim(),null!=e.defaultFreezeStatus&&Object.hasOwnProperty.call(e,"defaultFreezeStatus")&&o.uint32(96).int32(e.defaultFreezeStatus),null!=e.defaultKycStatus&&Object.hasOwnProperty.call(e,"defaultKycStatus")&&o.uint32(104).int32(e.defaultKycStatus),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(112).bool(e.deleted),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(122).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(130).fork()).ldelim(),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(138).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(146).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.name=e.string();break;case 3:d.symbol=e.string();break;case 4:d.decimals=e.uint32();break;case 5:d.totalSupply=e.uint64();break;case 6:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 11:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 12:d.defaultFreezeStatus=e.int32();break;case 13:d.defaultKycStatus=e.int32();break;case 14:d.deleted=e.bool();break;case 15:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 16:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 17:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 18:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),TokenGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.tokenInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.tokenInfo&&Object.hasOwnProperty.call(e,"tokenInfo")&&$root.proto.TokenInfo.encode(e.tokenInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.tokenInfo=$root.proto.TokenInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.scheduleID=null,e.prototype.deletionTime=null,e.prototype.executionTime=null,e.prototype.expirationTime=null,e.prototype.scheduledTransactionBody=null,e.prototype.memo="",e.prototype.adminKey=null,e.prototype.signers=null,e.prototype.creatorAccountID=null,e.prototype.payerAccountID=null,e.prototype.scheduledTransactionID=null;let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["deletionTime","executionTime"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),null!=e.deletionTime&&Object.hasOwnProperty.call(e,"deletionTime")&&$root.proto.Timestamp.encode(e.deletionTime,o.uint32(18).fork()).ldelim(),null!=e.executionTime&&Object.hasOwnProperty.call(e,"executionTime")&&$root.proto.Timestamp.encode(e.executionTime,o.uint32(26).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.scheduledTransactionBody&&Object.hasOwnProperty.call(e,"scheduledTransactionBody")&&$root.proto.SchedulableTransactionBody.encode(e.scheduledTransactionBody,o.uint32(42).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(58).fork()).ldelim(),null!=e.signers&&Object.hasOwnProperty.call(e,"signers")&&$root.proto.KeyList.encode(e.signers,o.uint32(66).fork()).ldelim(),null!=e.creatorAccountID&&Object.hasOwnProperty.call(e,"creatorAccountID")&&$root.proto.AccountID.encode(e.creatorAccountID,o.uint32(74).fork()).ldelim(),null!=e.payerAccountID&&Object.hasOwnProperty.call(e,"payerAccountID")&&$root.proto.AccountID.encode(e.payerAccountID,o.uint32(82).fork()).ldelim(),null!=e.scheduledTransactionID&&Object.hasOwnProperty.call(e,"scheduledTransactionID")&&$root.proto.TransactionID.encode(e.scheduledTransactionID,o.uint32(90).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;case 2:d.deletionTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.executionTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 5:d.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(e,e.uint32());break;case 6:d.memo=e.string();break;case 7:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.signers=$root.proto.KeyList.decode(e,e.uint32());break;case 9:d.creatorAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 10:d.payerAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 11:d.scheduledTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.scheduleInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.scheduleInfo&&Object.hasOwnProperty.call(e,"scheduleInfo")&&$root.proto.ScheduleInfo.encode(e.scheduleInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.scheduleInfo=$root.proto.ScheduleInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SchedulableTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.memo="",e.prototype.contractCall=null,e.prototype.contractCreateInstance=null,e.prototype.contractUpdateInstance=null,e.prototype.contractDeleteInstance=null,e.prototype.cryptoCreateAccount=null,e.prototype.cryptoDelete=null,e.prototype.cryptoTransfer=null,e.prototype.cryptoUpdateAccount=null,e.prototype.fileAppend=null,e.prototype.fileCreate=null,e.prototype.fileDelete=null,e.prototype.fileUpdate=null,e.prototype.systemDelete=null,e.prototype.systemUndelete=null,e.prototype.freeze=null,e.prototype.consensusCreateTopic=null,e.prototype.consensusUpdateTopic=null,e.prototype.consensusDeleteTopic=null,e.prototype.consensusSubmitMessage=null,e.prototype.tokenCreation=null,e.prototype.tokenFreeze=null,e.prototype.tokenUnfreeze=null,e.prototype.tokenGrantKyc=null,e.prototype.tokenRevokeKyc=null,e.prototype.tokenDeletion=null,e.prototype.tokenUpdate=null,e.prototype.tokenMint=null,e.prototype.tokenBurn=null,e.prototype.tokenWipe=null,e.prototype.tokenAssociate=null,e.prototype.tokenDissociate=null,e.prototype.scheduleDelete=null;let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["contractCall","contractCreateInstance","contractUpdateInstance","contractDeleteInstance","cryptoCreateAccount","cryptoDelete","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","scheduleDelete"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(8).uint64(e.transactionFee),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(18).string(e.memo),null!=e.contractCall&&Object.hasOwnProperty.call(e,"contractCall")&&$root.proto.ContractCallTransactionBody.encode(e.contractCall,o.uint32(26).fork()).ldelim(),null!=e.contractCreateInstance&&Object.hasOwnProperty.call(e,"contractCreateInstance")&&$root.proto.ContractCreateTransactionBody.encode(e.contractCreateInstance,o.uint32(34).fork()).ldelim(),null!=e.contractUpdateInstance&&Object.hasOwnProperty.call(e,"contractUpdateInstance")&&$root.proto.ContractUpdateTransactionBody.encode(e.contractUpdateInstance,o.uint32(42).fork()).ldelim(),null!=e.contractDeleteInstance&&Object.hasOwnProperty.call(e,"contractDeleteInstance")&&$root.proto.ContractDeleteTransactionBody.encode(e.contractDeleteInstance,o.uint32(50).fork()).ldelim(),null!=e.cryptoCreateAccount&&Object.hasOwnProperty.call(e,"cryptoCreateAccount")&&$root.proto.CryptoCreateTransactionBody.encode(e.cryptoCreateAccount,o.uint32(58).fork()).ldelim(),null!=e.cryptoDelete&&Object.hasOwnProperty.call(e,"cryptoDelete")&&$root.proto.CryptoDeleteTransactionBody.encode(e.cryptoDelete,o.uint32(66).fork()).ldelim(),null!=e.cryptoTransfer&&Object.hasOwnProperty.call(e,"cryptoTransfer")&&$root.proto.CryptoTransferTransactionBody.encode(e.cryptoTransfer,o.uint32(74).fork()).ldelim(),null!=e.cryptoUpdateAccount&&Object.hasOwnProperty.call(e,"cryptoUpdateAccount")&&$root.proto.CryptoUpdateTransactionBody.encode(e.cryptoUpdateAccount,o.uint32(82).fork()).ldelim(),null!=e.fileAppend&&Object.hasOwnProperty.call(e,"fileAppend")&&$root.proto.FileAppendTransactionBody.encode(e.fileAppend,o.uint32(90).fork()).ldelim(),null!=e.fileCreate&&Object.hasOwnProperty.call(e,"fileCreate")&&$root.proto.FileCreateTransactionBody.encode(e.fileCreate,o.uint32(98).fork()).ldelim(),null!=e.fileDelete&&Object.hasOwnProperty.call(e,"fileDelete")&&$root.proto.FileDeleteTransactionBody.encode(e.fileDelete,o.uint32(106).fork()).ldelim(),null!=e.fileUpdate&&Object.hasOwnProperty.call(e,"fileUpdate")&&$root.proto.FileUpdateTransactionBody.encode(e.fileUpdate,o.uint32(114).fork()).ldelim(),null!=e.systemDelete&&Object.hasOwnProperty.call(e,"systemDelete")&&$root.proto.SystemDeleteTransactionBody.encode(e.systemDelete,o.uint32(122).fork()).ldelim(),null!=e.systemUndelete&&Object.hasOwnProperty.call(e,"systemUndelete")&&$root.proto.SystemUndeleteTransactionBody.encode(e.systemUndelete,o.uint32(130).fork()).ldelim(),null!=e.freeze&&Object.hasOwnProperty.call(e,"freeze")&&$root.proto.FreezeTransactionBody.encode(e.freeze,o.uint32(138).fork()).ldelim(),null!=e.consensusCreateTopic&&Object.hasOwnProperty.call(e,"consensusCreateTopic")&&$root.proto.ConsensusCreateTopicTransactionBody.encode(e.consensusCreateTopic,o.uint32(146).fork()).ldelim(),null!=e.consensusUpdateTopic&&Object.hasOwnProperty.call(e,"consensusUpdateTopic")&&$root.proto.ConsensusUpdateTopicTransactionBody.encode(e.consensusUpdateTopic,o.uint32(154).fork()).ldelim(),null!=e.consensusDeleteTopic&&Object.hasOwnProperty.call(e,"consensusDeleteTopic")&&$root.proto.ConsensusDeleteTopicTransactionBody.encode(e.consensusDeleteTopic,o.uint32(162).fork()).ldelim(),null!=e.consensusSubmitMessage&&Object.hasOwnProperty.call(e,"consensusSubmitMessage")&&$root.proto.ConsensusSubmitMessageTransactionBody.encode(e.consensusSubmitMessage,o.uint32(170).fork()).ldelim(),null!=e.tokenCreation&&Object.hasOwnProperty.call(e,"tokenCreation")&&$root.proto.TokenCreateTransactionBody.encode(e.tokenCreation,o.uint32(178).fork()).ldelim(),null!=e.tokenFreeze&&Object.hasOwnProperty.call(e,"tokenFreeze")&&$root.proto.TokenFreezeAccountTransactionBody.encode(e.tokenFreeze,o.uint32(186).fork()).ldelim(),null!=e.tokenUnfreeze&&Object.hasOwnProperty.call(e,"tokenUnfreeze")&&$root.proto.TokenUnfreezeAccountTransactionBody.encode(e.tokenUnfreeze,o.uint32(194).fork()).ldelim(),null!=e.tokenGrantKyc&&Object.hasOwnProperty.call(e,"tokenGrantKyc")&&$root.proto.TokenGrantKycTransactionBody.encode(e.tokenGrantKyc,o.uint32(202).fork()).ldelim(),null!=e.tokenRevokeKyc&&Object.hasOwnProperty.call(e,"tokenRevokeKyc")&&$root.proto.TokenRevokeKycTransactionBody.encode(e.tokenRevokeKyc,o.uint32(210).fork()).ldelim(),null!=e.tokenDeletion&&Object.hasOwnProperty.call(e,"tokenDeletion")&&$root.proto.TokenDeleteTransactionBody.encode(e.tokenDeletion,o.uint32(218).fork()).ldelim(),null!=e.tokenUpdate&&Object.hasOwnProperty.call(e,"tokenUpdate")&&$root.proto.TokenUpdateTransactionBody.encode(e.tokenUpdate,o.uint32(226).fork()).ldelim(),null!=e.tokenMint&&Object.hasOwnProperty.call(e,"tokenMint")&&$root.proto.TokenMintTransactionBody.encode(e.tokenMint,o.uint32(234).fork()).ldelim(),null!=e.tokenBurn&&Object.hasOwnProperty.call(e,"tokenBurn")&&$root.proto.TokenBurnTransactionBody.encode(e.tokenBurn,o.uint32(242).fork()).ldelim(),null!=e.tokenWipe&&Object.hasOwnProperty.call(e,"tokenWipe")&&$root.proto.TokenWipeAccountTransactionBody.encode(e.tokenWipe,o.uint32(250).fork()).ldelim(),null!=e.tokenAssociate&&Object.hasOwnProperty.call(e,"tokenAssociate")&&$root.proto.TokenAssociateTransactionBody.encode(e.tokenAssociate,o.uint32(258).fork()).ldelim(),null!=e.tokenDissociate&&Object.hasOwnProperty.call(e,"tokenDissociate")&&$root.proto.TokenDissociateTransactionBody.encode(e.tokenDissociate,o.uint32(266).fork()).ldelim(),null!=e.scheduleDelete&&Object.hasOwnProperty.call(e,"scheduleDelete")&&$root.proto.ScheduleDeleteTransactionBody.encode(e.scheduleDelete,o.uint32(274).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SchedulableTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionFee=e.uint64();break;case 2:d.memo=e.string();break;case 3:d.contractCall=$root.proto.ContractCallTransactionBody.decode(e,e.uint32());break;case 4:d.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(e,e.uint32());break;case 5:d.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(e,e.uint32());break;case 6:d.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(e,e.uint32());break;case 7:d.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(e,e.uint32());break;case 8:d.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(e,e.uint32());break;case 9:d.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(e,e.uint32());break;case 10:d.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(e,e.uint32());break;case 11:d.fileAppend=$root.proto.FileAppendTransactionBody.decode(e,e.uint32());break;case 12:d.fileCreate=$root.proto.FileCreateTransactionBody.decode(e,e.uint32());break;case 13:d.fileDelete=$root.proto.FileDeleteTransactionBody.decode(e,e.uint32());break;case 14:d.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(e,e.uint32());break;case 15:d.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(e,e.uint32());break;case 16:d.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(e,e.uint32());break;case 17:d.freeze=$root.proto.FreezeTransactionBody.decode(e,e.uint32());break;case 18:d.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(e,e.uint32());break;case 19:d.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(e,e.uint32());break;case 20:d.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(e,e.uint32());break;case 21:d.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(e,e.uint32());break;case 22:d.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(e,e.uint32());break;case 23:d.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(e,e.uint32());break;case 24:d.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(e,e.uint32());break;case 25:d.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(e,e.uint32());break;case 26:d.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(e,e.uint32());break;case 27:d.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(e,e.uint32());break;case 28:d.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(e,e.uint32());break;case 29:d.tokenMint=$root.proto.TokenMintTransactionBody.decode(e,e.uint32());break;case 30:d.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(e,e.uint32());break;case 31:d.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(e,e.uint32());break;case 32:d.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(e,e.uint32());break;case 33:d.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(e,e.uint32());break;case 34:d.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SystemDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.fileID=null,e.prototype.contractID=null,e.prototype.expirationTime=null;let o;return Object.defineProperty(e.prototype,"id",{get:$util.oneOfGetter(o=["fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.TimestampSeconds.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SystemDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.expirationTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SystemUndeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.fileID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"id",{get:$util.oneOfGetter(o=["fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SystemUndeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FreezeTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.startHour=0,e.prototype.startMin=0,e.prototype.endHour=0,e.prototype.endMin=0,e.prototype.updateFile=null,e.prototype.fileHash=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.startHour&&Object.hasOwnProperty.call(e,"startHour")&&o.uint32(8).int32(e.startHour),null!=e.startMin&&Object.hasOwnProperty.call(e,"startMin")&&o.uint32(16).int32(e.startMin),null!=e.endHour&&Object.hasOwnProperty.call(e,"endHour")&&o.uint32(24).int32(e.endHour),null!=e.endMin&&Object.hasOwnProperty.call(e,"endMin")&&o.uint32(32).int32(e.endMin),null!=e.updateFile&&Object.hasOwnProperty.call(e,"updateFile")&&$root.proto.FileID.encode(e.updateFile,o.uint32(42).fork()).ldelim(),null!=e.fileHash&&Object.hasOwnProperty.call(e,"fileHash")&&o.uint32(50).bytes(e.fileHash),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FreezeTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.startHour=e.int32();break;case 2:d.startMin=e.int32();break;case 3:d.endHour=e.int32();break;case 4:d.endMin=e.int32();break;case 5:d.updateFile=$root.proto.FileID.decode(e,e.uint32());break;case 6:d.fileHash=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractCallTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.contractID=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.functionParameters=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(16).int64(e.gas),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).int64(e.amount),null!=e.functionParameters&&Object.hasOwnProperty.call(e,"functionParameters")&&o.uint32(34).bytes(e.functionParameters),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.gas=e.int64();break;case 3:d.amount=e.int64();break;case 4:d.functionParameters=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.prototype.adminKey=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.proxyAccountID=null,e.prototype.autoRenewPeriod=null,e.prototype.constructorParameters=$util.newBuffer([]),e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(32).int64(e.gas),null!=e.initialBalance&&Object.hasOwnProperty.call(e,"initialBalance")&&o.uint32(40).int64(e.initialBalance),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.constructorParameters&&Object.hasOwnProperty.call(e,"constructorParameters")&&o.uint32(74).bytes(e.constructorParameters),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(82).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(90).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(106).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 4:d.gas=e.int64();break;case 5:d.initialBalance=e.int64();break;case 6:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.constructorParameters=e.bytes();break;case 10:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 11:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 12:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 13:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),ContractUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.contractID=null,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.proxyAccountID=null,e.prototype.autoRenewPeriod=null,e.prototype.fileID=null,e.prototype.memo=null,e.prototype.memoWrapper=null;let o;return Object.defineProperty(e.prototype,"memoField",{get:$util.oneOfGetter(o=["memo","memoWrapper"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(58).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(66).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(74).string(e.memo),null!=e.memoWrapper&&Object.hasOwnProperty.call(e,"memoWrapper")&&$root.google.protobuf.StringValue.encode(e.memoWrapper,o.uint32(82).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 8:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 9:d.memo=e.string();break;case 10:d.memoWrapper=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.key=null,e.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.proxyAccountID=null,e.prototype.sendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiverSigRequired=!1,e.prototype.autoRenewPeriod=null,e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(10).fork()).ldelim(),null!=e.initialBalance&&Object.hasOwnProperty.call(e,"initialBalance")&&o.uint32(16).uint64(e.initialBalance),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(26).fork()).ldelim(),null!=e.sendRecordThreshold&&Object.hasOwnProperty.call(e,"sendRecordThreshold")&&o.uint32(48).uint64(e.sendRecordThreshold),null!=e.receiveRecordThreshold&&Object.hasOwnProperty.call(e,"receiveRecordThreshold")&&o.uint32(56).uint64(e.receiveRecordThreshold),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(64).bool(e.receiverSigRequired),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(74).fork()).ldelim(),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(82).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(90).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(106).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.key=$root.proto.Key.decode(e,e.uint32());break;case 2:d.initialBalance=e.uint64();break;case 3:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.sendRecordThreshold=e.uint64();break;case 7:d.receiveRecordThreshold=e.uint64();break;case 8:d.receiverSigRequired=e.bool();break;case 9:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 10:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 11:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 12:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 13:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),CryptoDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transferAccountID=null,e.prototype.deleteAccountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transferAccountID&&Object.hasOwnProperty.call(e,"transferAccountID")&&$root.proto.AccountID.encode(e.transferAccountID,o.uint32(10).fork()).ldelim(),null!=e.deleteAccountID&&Object.hasOwnProperty.call(e,"deleteAccountID")&&$root.proto.AccountID.encode(e.deleteAccountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transferAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.deleteAccountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.accountIDToUpdate=null,e.prototype.key=null,e.prototype.proxyAccountID=null,e.prototype.proxyFraction=0,e.prototype.sendRecordThreshold=null,e.prototype.sendRecordThresholdWrapper=null,e.prototype.receiveRecordThreshold=null,e.prototype.receiveRecordThresholdWrapper=null,e.prototype.autoRenewPeriod=null,e.prototype.expirationTime=null,e.prototype.receiverSigRequired=null,e.prototype.receiverSigRequiredWrapper=null,e.prototype.memo=null;let o;return Object.defineProperty(e.prototype,"sendRecordThresholdField",{get:$util.oneOfGetter(o=["sendRecordThreshold","sendRecordThresholdWrapper"]),set:$util.oneOfSetter(o)}),Object.defineProperty(e.prototype,"receiveRecordThresholdField",{get:$util.oneOfGetter(o=["receiveRecordThreshold","receiveRecordThresholdWrapper"]),set:$util.oneOfSetter(o)}),Object.defineProperty(e.prototype,"receiverSigRequiredField",{get:$util.oneOfGetter(o=["receiverSigRequired","receiverSigRequiredWrapper"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountIDToUpdate&&Object.hasOwnProperty.call(e,"accountIDToUpdate")&&$root.proto.AccountID.encode(e.accountIDToUpdate,o.uint32(18).fork()).ldelim(),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(26).fork()).ldelim(),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(34).fork()).ldelim(),null!=e.proxyFraction&&Object.hasOwnProperty.call(e,"proxyFraction")&&o.uint32(40).int32(e.proxyFraction),null!=e.sendRecordThreshold&&Object.hasOwnProperty.call(e,"sendRecordThreshold")&&o.uint32(48).uint64(e.sendRecordThreshold),null!=e.receiveRecordThreshold&&Object.hasOwnProperty.call(e,"receiveRecordThreshold")&&o.uint32(56).uint64(e.receiveRecordThreshold),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(74).fork()).ldelim(),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(80).bool(e.receiverSigRequired),null!=e.sendRecordThresholdWrapper&&Object.hasOwnProperty.call(e,"sendRecordThresholdWrapper")&&$root.google.protobuf.UInt64Value.encode(e.sendRecordThresholdWrapper,o.uint32(90).fork()).ldelim(),null!=e.receiveRecordThresholdWrapper&&Object.hasOwnProperty.call(e,"receiveRecordThresholdWrapper")&&$root.google.protobuf.UInt64Value.encode(e.receiveRecordThresholdWrapper,o.uint32(98).fork()).ldelim(),null!=e.receiverSigRequiredWrapper&&Object.hasOwnProperty.call(e,"receiverSigRequiredWrapper")&&$root.google.protobuf.BoolValue.encode(e.receiverSigRequiredWrapper,o.uint32(106).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(114).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.accountIDToUpdate=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.key=$root.proto.Key.decode(e,e.uint32());break;case 4:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 5:d.proxyFraction=e.int32();break;case 6:d.sendRecordThreshold=e.uint64();break;case 11:d.sendRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(e,e.uint32());break;case 7:d.receiveRecordThreshold=e.uint64();break;case 12:d.receiveRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 10:d.receiverSigRequired=e.bool();break;case 13:d.receiverSigRequiredWrapper=$root.google.protobuf.BoolValue.decode(e,e.uint32());break;case 14:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileAppendTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.prototype.contents=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileAppendTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;default:e.skipType(7&i);}return d},e}(),FileCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.expirationTime=null,e.prototype.keys=null,e.prototype.contents=$util.newBuffer([]),e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(42).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(50).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(58).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(66).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;case 5:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 6:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 7:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),FileDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.fileID=null,e.prototype.expirationTime=null,e.prototype.keys=null,e.prototype.contents=$util.newBuffer([]),e.prototype.memo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;case 5:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.contractID=null,e.prototype.transferAccountID=null,e.prototype.transferContractID=null;let o;return Object.defineProperty(e.prototype,"obtainers",{get:$util.oneOfGetter(o=["transferAccountID","transferContractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.transferAccountID&&Object.hasOwnProperty.call(e,"transferAccountID")&&$root.proto.AccountID.encode(e.transferAccountID,o.uint32(18).fork()).ldelim(),null!=e.transferContractID&&Object.hasOwnProperty.call(e,"transferContractID")&&$root.proto.ContractID.encode(e.transferContractID,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.transferAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.transferContractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusUpdateTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.topicID=null,e.prototype.memo=null,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(18).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(50).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(58).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(74).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusUpdateTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 6:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusMessageChunkInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.initialTransactionID=null,e.prototype.total=0,e.prototype.number=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.initialTransactionID&&Object.hasOwnProperty.call(e,"initialTransactionID")&&$root.proto.TransactionID.encode(e.initialTransactionID,o.uint32(10).fork()).ldelim(),null!=e.total&&Object.hasOwnProperty.call(e,"total")&&o.uint32(16).int32(e.total),null!=e.number&&Object.hasOwnProperty.call(e,"number")&&o.uint32(24).int32(e.number),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusMessageChunkInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.initialTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 2:d.total=e.int32();break;case 3:d.number=e.int32();break;default:e.skipType(7&i);}return d},e}(),ConsensusSubmitMessageTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.topicID=null,e.prototype.message=$util.newBuffer([]),e.prototype.chunkInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.message&&Object.hasOwnProperty.call(e,"message")&&o.uint32(18).bytes(e.message),null!=e.chunkInfo&&Object.hasOwnProperty.call(e,"chunkInfo")&&$root.proto.ConsensusMessageChunkInfo.encode(e.chunkInfo,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusSubmitMessageTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.message=e.bytes();break;case 3:d.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.name="",e.prototype.symbol="",e.prototype.decimals=0,e.prototype.initialSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.freezeDefault=!1,e.prototype.expiry=null,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(24).uint32(e.decimals),null!=e.initialSupply&&Object.hasOwnProperty.call(e,"initialSupply")&&o.uint32(32).uint64(e.initialSupply),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(42).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(50).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(58).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(66).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(74).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(82).fork()).ldelim(),null!=e.freezeDefault&&Object.hasOwnProperty.call(e,"freezeDefault")&&o.uint32(88).bool(e.freezeDefault),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(106).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(114).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(122).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(130).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.symbol=e.string();break;case 3:d.decimals=e.uint32();break;case 4:d.initialSupply=e.uint64();break;case 5:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 11:d.freezeDefault=e.bool();break;case 13:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 14:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 15:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 16:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),TokenFreezeAccountTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenFreezeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenUnfreezeAccountTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUnfreezeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenGrantKycTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGrantKycTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenRevokeKycTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenRevokeKycTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.symbol="",e.prototype.name="",e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.expiry=null,e.prototype.memo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(26).string(e.name),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(42).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(50).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(58).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(66).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(74).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(82).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(90).fork()).ldelim(),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(106).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.symbol=e.string();break;case 3:d.name=e.string();break;case 4:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 5:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 11:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 12:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 13:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenMintTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).uint64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenMintTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.amount=e.uint64();break;default:e.skipType(7&i);}return d},e}(),TokenBurnTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).uint64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBurnTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.amount=e.uint64();break;default:e.skipType(7&i);}return d},e}(),TokenWipeAccountTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.token=null,e.prototype.account=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).uint64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenWipeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.amount=e.uint64();break;default:e.skipType(7&i);}return d},e}(),TokenAssociateTransactionBody:function(){function e(e){if(this.tokens=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.account=null,e.prototype.tokens=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(10).fork()).ldelim(),null!=e.tokens&&e.tokens.length)for(var t=0;t<e.tokens.length;++t)$root.proto.TokenID.encode(e.tokens[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenAssociateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.tokens&&d.tokens.length||(d.tokens=[]),d.tokens.push($root.proto.TokenID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenDissociateTransactionBody:function(){function e(e){if(this.tokens=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.account=null,e.prototype.tokens=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(10).fork()).ldelim(),null!=e.tokens&&e.tokens.length)for(var t=0;t<e.tokens.length;++t)$root.proto.TokenID.encode(e.tokens[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenDissociateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.tokens&&d.tokens.length||(d.tokens=[]),d.tokens.push($root.proto.TokenID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ScheduleDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),Response:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.getByKey=null,e.prototype.getBySolidityID=null,e.prototype.contractCallLocal=null,e.prototype.contractGetBytecodeResponse=null,e.prototype.contractGetInfo=null,e.prototype.contractGetRecordsResponse=null,e.prototype.cryptogetAccountBalance=null,e.prototype.cryptoGetAccountRecords=null,e.prototype.cryptoGetInfo=null,e.prototype.cryptoGetLiveHash=null,e.prototype.cryptoGetProxyStakers=null,e.prototype.fileGetContents=null,e.prototype.fileGetInfo=null,e.prototype.transactionGetReceipt=null,e.prototype.transactionGetRecord=null,e.prototype.transactionGetFastRecord=null,e.prototype.consensusGetTopicInfo=null,e.prototype.networkGetVersionInfo=null,e.prototype.tokenGetInfo=null,e.prototype.scheduleGetInfo=null;let o;return Object.defineProperty(e.prototype,"response",{get:$util.oneOfGetter(o=["getByKey","getBySolidityID","contractCallLocal","contractGetBytecodeResponse","contractGetInfo","contractGetRecordsResponse","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.getByKey&&Object.hasOwnProperty.call(e,"getByKey")&&$root.proto.GetByKeyResponse.encode(e.getByKey,o.uint32(10).fork()).ldelim(),null!=e.getBySolidityID&&Object.hasOwnProperty.call(e,"getBySolidityID")&&$root.proto.GetBySolidityIDResponse.encode(e.getBySolidityID,o.uint32(18).fork()).ldelim(),null!=e.contractCallLocal&&Object.hasOwnProperty.call(e,"contractCallLocal")&&$root.proto.ContractCallLocalResponse.encode(e.contractCallLocal,o.uint32(26).fork()).ldelim(),null!=e.contractGetInfo&&Object.hasOwnProperty.call(e,"contractGetInfo")&&$root.proto.ContractGetInfoResponse.encode(e.contractGetInfo,o.uint32(34).fork()).ldelim(),null!=e.contractGetBytecodeResponse&&Object.hasOwnProperty.call(e,"contractGetBytecodeResponse")&&$root.proto.ContractGetBytecodeResponse.encode(e.contractGetBytecodeResponse,o.uint32(42).fork()).ldelim(),null!=e.contractGetRecordsResponse&&Object.hasOwnProperty.call(e,"contractGetRecordsResponse")&&$root.proto.ContractGetRecordsResponse.encode(e.contractGetRecordsResponse,o.uint32(50).fork()).ldelim(),null!=e.cryptogetAccountBalance&&Object.hasOwnProperty.call(e,"cryptogetAccountBalance")&&$root.proto.CryptoGetAccountBalanceResponse.encode(e.cryptogetAccountBalance,o.uint32(58).fork()).ldelim(),null!=e.cryptoGetAccountRecords&&Object.hasOwnProperty.call(e,"cryptoGetAccountRecords")&&$root.proto.CryptoGetAccountRecordsResponse.encode(e.cryptoGetAccountRecords,o.uint32(66).fork()).ldelim(),null!=e.cryptoGetInfo&&Object.hasOwnProperty.call(e,"cryptoGetInfo")&&$root.proto.CryptoGetInfoResponse.encode(e.cryptoGetInfo,o.uint32(74).fork()).ldelim(),null!=e.cryptoGetLiveHash&&Object.hasOwnProperty.call(e,"cryptoGetLiveHash")&&$root.proto.CryptoGetLiveHashResponse.encode(e.cryptoGetLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoGetProxyStakers&&Object.hasOwnProperty.call(e,"cryptoGetProxyStakers")&&$root.proto.CryptoGetStakersResponse.encode(e.cryptoGetProxyStakers,o.uint32(90).fork()).ldelim(),null!=e.fileGetContents&&Object.hasOwnProperty.call(e,"fileGetContents")&&$root.proto.FileGetContentsResponse.encode(e.fileGetContents,o.uint32(98).fork()).ldelim(),null!=e.fileGetInfo&&Object.hasOwnProperty.call(e,"fileGetInfo")&&$root.proto.FileGetInfoResponse.encode(e.fileGetInfo,o.uint32(106).fork()).ldelim(),null!=e.transactionGetReceipt&&Object.hasOwnProperty.call(e,"transactionGetReceipt")&&$root.proto.TransactionGetReceiptResponse.encode(e.transactionGetReceipt,o.uint32(114).fork()).ldelim(),null!=e.transactionGetRecord&&Object.hasOwnProperty.call(e,"transactionGetRecord")&&$root.proto.TransactionGetRecordResponse.encode(e.transactionGetRecord,o.uint32(122).fork()).ldelim(),null!=e.transactionGetFastRecord&&Object.hasOwnProperty.call(e,"transactionGetFastRecord")&&$root.proto.TransactionGetFastRecordResponse.encode(e.transactionGetFastRecord,o.uint32(130).fork()).ldelim(),null!=e.consensusGetTopicInfo&&Object.hasOwnProperty.call(e,"consensusGetTopicInfo")&&$root.proto.ConsensusGetTopicInfoResponse.encode(e.consensusGetTopicInfo,o.uint32(1202).fork()).ldelim(),null!=e.networkGetVersionInfo&&Object.hasOwnProperty.call(e,"networkGetVersionInfo")&&$root.proto.NetworkGetVersionInfoResponse.encode(e.networkGetVersionInfo,o.uint32(1210).fork()).ldelim(),null!=e.tokenGetInfo&&Object.hasOwnProperty.call(e,"tokenGetInfo")&&$root.proto.TokenGetInfoResponse.encode(e.tokenGetInfo,o.uint32(1218).fork()).ldelim(),null!=e.scheduleGetInfo&&Object.hasOwnProperty.call(e,"scheduleGetInfo")&&$root.proto.ScheduleGetInfoResponse.encode(e.scheduleGetInfo,o.uint32(1226).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Response,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.getByKey=$root.proto.GetByKeyResponse.decode(e,e.uint32());break;case 2:d.getBySolidityID=$root.proto.GetBySolidityIDResponse.decode(e,e.uint32());break;case 3:d.contractCallLocal=$root.proto.ContractCallLocalResponse.decode(e,e.uint32());break;case 5:d.contractGetBytecodeResponse=$root.proto.ContractGetBytecodeResponse.decode(e,e.uint32());break;case 4:d.contractGetInfo=$root.proto.ContractGetInfoResponse.decode(e,e.uint32());break;case 6:d.contractGetRecordsResponse=$root.proto.ContractGetRecordsResponse.decode(e,e.uint32());break;case 7:d.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceResponse.decode(e,e.uint32());break;case 8:d.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsResponse.decode(e,e.uint32());break;case 9:d.cryptoGetInfo=$root.proto.CryptoGetInfoResponse.decode(e,e.uint32());break;case 10:d.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashResponse.decode(e,e.uint32());break;case 11:d.cryptoGetProxyStakers=$root.proto.CryptoGetStakersResponse.decode(e,e.uint32());break;case 12:d.fileGetContents=$root.proto.FileGetContentsResponse.decode(e,e.uint32());break;case 13:d.fileGetInfo=$root.proto.FileGetInfoResponse.decode(e,e.uint32());break;case 14:d.transactionGetReceipt=$root.proto.TransactionGetReceiptResponse.decode(e,e.uint32());break;case 15:d.transactionGetRecord=$root.proto.TransactionGetRecordResponse.decode(e,e.uint32());break;case 16:d.transactionGetFastRecord=$root.proto.TransactionGetFastRecordResponse.decode(e,e.uint32());break;case 150:d.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoResponse.decode(e,e.uint32());break;case 151:d.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoResponse.decode(e,e.uint32());break;case 152:d.tokenGetInfo=$root.proto.TokenGetInfoResponse.decode(e,e.uint32());break;case 153:d.scheduleGetInfo=$root.proto.ScheduleGetInfoResponse.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),Claim:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountID=null,e.prototype.hash=$util.newBuffer([]),e.prototype.keys=null,e.prototype.claimDuration=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(18).bytes(e.hash),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.claimDuration&&Object.hasOwnProperty.call(e,"claimDuration")&&$root.proto.Duration.encode(e.claimDuration,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Claim,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hash=e.bytes();break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 5:d.claimDuration=$root.proto.Duration.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoAddClaimTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.claim=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.claim&&Object.hasOwnProperty.call(e,"claim")&&$root.proto.Claim.encode(e.claim,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoAddClaimTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 3:d.claim=$root.proto.Claim.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoDeleteClaimTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountIDToDeleteFrom=null,e.prototype.hashToDelete=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountIDToDeleteFrom&&Object.hasOwnProperty.call(e,"accountIDToDeleteFrom")&&$root.proto.AccountID.encode(e.accountIDToDeleteFrom,o.uint32(10).fork()).ldelim(),null!=e.hashToDelete&&Object.hasOwnProperty.call(e,"hashToDelete")&&o.uint32(18).bytes(e.hashToDelete),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoDeleteClaimTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountIDToDeleteFrom=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hashToDelete=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoDeleteLiveHashTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.accountOfLiveHash=null,e.prototype.liveHashToDelete=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountOfLiveHash&&Object.hasOwnProperty.call(e,"accountOfLiveHash")&&$root.proto.AccountID.encode(e.accountOfLiveHash,o.uint32(10).fork()).ldelim(),null!=e.liveHashToDelete&&Object.hasOwnProperty.call(e,"liveHashToDelete")&&o.uint32(18).bytes(e.liveHashToDelete),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoDeleteLiveHashTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountOfLiveHash=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.liveHashToDelete=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoGetClaimQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.hash=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(26).bytes(e.hash),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetClaimQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.hash=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoGetClaimResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.header=null,e.prototype.claim=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.claim&&Object.hasOwnProperty.call(e,"claim")&&$root.proto.Claim.encode(e.claim,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetClaimResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.claim=$root.proto.Claim.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createAccount"}),Object.defineProperty(e.prototype.updateAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"updateAccount"}),Object.defineProperty(e.prototype.cryptoTransfer=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"cryptoTransfer"}),Object.defineProperty(e.prototype.cryptoDelete=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"cryptoDelete"}),Object.defineProperty(e.prototype.addLiveHash=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"addLiveHash"}),Object.defineProperty(e.prototype.deleteLiveHash=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteLiveHash"}),Object.defineProperty(e.prototype.getLiveHash=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getLiveHash"}),Object.defineProperty(e.prototype.getAccountRecords=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getAccountRecords"}),Object.defineProperty(e.prototype.cryptoGetBalance=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"cryptoGetBalance"}),Object.defineProperty(e.prototype.getAccountInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getAccountInfo"}),Object.defineProperty(e.prototype.getTransactionReceipts=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getTransactionReceipts"}),Object.defineProperty(e.prototype.getFastTransactionRecord=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getFastTransactionRecord"}),Object.defineProperty(e.prototype.getTxRecordByTxID=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getTxRecordByTxID"}),Object.defineProperty(e.prototype.getStakersByAccountID=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getStakersByAccountID"}),e}(),FileService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createFile=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createFile"}),Object.defineProperty(e.prototype.updateFile=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"updateFile"}),Object.defineProperty(e.prototype.deleteFile=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteFile"}),Object.defineProperty(e.prototype.appendContent=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"appendContent"}),Object.defineProperty(e.prototype.getFileContent=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getFileContent"}),Object.defineProperty(e.prototype.getFileInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getFileInfo"}),Object.defineProperty(e.prototype.systemDelete=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"systemDelete"}),Object.defineProperty(e.prototype.systemUndelete=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"systemUndelete"}),e}(),FreezeService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.freeze=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"freeze"}),e}(),ConsensusTopicQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.topicID=null,e.prototype.consensusStartTime=null,e.prototype.consensusEndTime=null,e.prototype.limit=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.consensusStartTime&&Object.hasOwnProperty.call(e,"consensusStartTime")&&$root.proto.Timestamp.encode(e.consensusStartTime,o.uint32(18).fork()).ldelim(),null!=e.consensusEndTime&&Object.hasOwnProperty.call(e,"consensusEndTime")&&$root.proto.Timestamp.encode(e.consensusEndTime,o.uint32(26).fork()).ldelim(),null!=e.limit&&Object.hasOwnProperty.call(e,"limit")&&o.uint32(32).uint64(e.limit),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.consensusStartTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.consensusEndTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.limit=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ConsensusTopicResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.consensusTimestamp=null,e.prototype.message=$util.newBuffer([]),e.prototype.runningHash=$util.newBuffer([]),e.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.runningHashVersion=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.chunkInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(10).fork()).ldelim(),null!=e.message&&Object.hasOwnProperty.call(e,"message")&&o.uint32(18).bytes(e.message),null!=e.runningHash&&Object.hasOwnProperty.call(e,"runningHash")&&o.uint32(26).bytes(e.runningHash),null!=e.sequenceNumber&&Object.hasOwnProperty.call(e,"sequenceNumber")&&o.uint32(32).uint64(e.sequenceNumber),null!=e.runningHashVersion&&Object.hasOwnProperty.call(e,"runningHashVersion")&&o.uint32(40).uint64(e.runningHashVersion),null!=e.chunkInfo&&Object.hasOwnProperty.call(e,"chunkInfo")&&$root.proto.ConsensusMessageChunkInfo.encode(e.chunkInfo,o.uint32(50).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.message=e.bytes();break;case 3:d.runningHash=e.bytes();break;case 4:d.sequenceNumber=e.uint64();break;case 5:d.runningHashVersion=e.uint64();break;case 6:d.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),MirrorConsensusService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.subscribeTopic=function e(o,t){return this.rpcCall(e,$root.proto.ConsensusTopicQuery,$root.proto.ConsensusTopicResponse,o,t)},"name",{value:"subscribeTopic"}),e}(),NetworkService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.getVersionInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getVersionInfo"}),Object.defineProperty(e.prototype.uncheckedSubmit=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"uncheckedSubmit"}),e}(),ScheduleCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.scheduledTransactionBody=null,e.prototype.memo="",e.prototype.adminKey=null,e.prototype.payerAccountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduledTransactionBody&&Object.hasOwnProperty.call(e,"scheduledTransactionBody")&&$root.proto.SchedulableTransactionBody.encode(e.scheduledTransactionBody,o.uint32(10).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(18).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.payerAccountID&&Object.hasOwnProperty.call(e,"payerAccountID")&&$root.proto.AccountID.encode(e.payerAccountID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(e,e.uint32());break;case 2:d.memo=e.string();break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 4:d.payerAccountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createSchedule=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createSchedule"}),Object.defineProperty(e.prototype.signSchedule=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"signSchedule"}),Object.defineProperty(e.prototype.deleteSchedule=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteSchedule"}),Object.defineProperty(e.prototype.getScheduleInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getScheduleInfo"}),e}(),ScheduleSignTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleSignTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SmartContractService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createContract=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createContract"}),Object.defineProperty(e.prototype.updateContract=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"updateContract"}),Object.defineProperty(e.prototype.contractCallMethod=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"contractCallMethod"}),Object.defineProperty(e.prototype.getContractInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getContractInfo"}),Object.defineProperty(e.prototype.contractCallLocalMethod=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"contractCallLocalMethod"}),Object.defineProperty(e.prototype.contractGetBytecode=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"ContractGetBytecode"}),Object.defineProperty(e.prototype.getBySolidityID=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getBySolidityID"}),Object.defineProperty(e.prototype.getTxRecordByContractID=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getTxRecordByContractID"}),Object.defineProperty(e.prototype.deleteContract=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteContract"}),Object.defineProperty(e.prototype.systemDelete=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"systemDelete"}),Object.defineProperty(e.prototype.systemUndelete=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"systemUndelete"}),e}(),ThrottleGroup:function(){function e(e){if(this.operations=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.operations=$util.emptyArray,e.prototype.milliOpsPerSec=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.operations&&e.operations.length){o.uint32(10).fork();for(var t=0;t<e.operations.length;++t)o.int32(e.operations[t]);o.ldelim()}return null!=e.milliOpsPerSec&&Object.hasOwnProperty.call(e,"milliOpsPerSec")&&o.uint32(16).uint64(e.milliOpsPerSec),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleGroup,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:if(d.operations&&d.operations.length||(d.operations=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.operations.push(e.int32());else d.operations.push(e.int32());break;case 2:d.milliOpsPerSec=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ThrottleBucket:function(){function e(e){if(this.throttleGroups=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.name="",e.prototype.burstPeriodMs=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.throttleGroups=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.burstPeriodMs&&Object.hasOwnProperty.call(e,"burstPeriodMs")&&o.uint32(16).uint64(e.burstPeriodMs),null!=e.throttleGroups&&e.throttleGroups.length)for(var t=0;t<e.throttleGroups.length;++t)$root.proto.ThrottleGroup.encode(e.throttleGroups[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleBucket,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.burstPeriodMs=e.uint64();break;case 3:d.throttleGroups&&d.throttleGroups.length||(d.throttleGroups=[]),d.throttleGroups.push($root.proto.ThrottleGroup.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ThrottleDefinitions:function(){function e(e){if(this.throttleBuckets=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.throttleBuckets=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.throttleBuckets&&e.throttleBuckets.length)for(var t=0;t<e.throttleBuckets.length;++t)$root.proto.ThrottleBucket.encode(e.throttleBuckets[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleDefinitions,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.throttleBuckets&&d.throttleBuckets.length||(d.throttleBuckets=[]),d.throttleBuckets.push($root.proto.ThrottleBucket.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t)}return(e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createToken=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"createToken"}),Object.defineProperty(e.prototype.updateToken=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"updateToken"}),Object.defineProperty(e.prototype.mintToken=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"mintToken"}),Object.defineProperty(e.prototype.burnToken=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"burnToken"}),Object.defineProperty(e.prototype.deleteToken=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"deleteToken"}),Object.defineProperty(e.prototype.wipeTokenAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"wipeTokenAccount"}),Object.defineProperty(e.prototype.freezeTokenAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"freezeTokenAccount"}),Object.defineProperty(e.prototype.unfreezeTokenAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"unfreezeTokenAccount"}),Object.defineProperty(e.prototype.grantKycToTokenAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"grantKycToTokenAccount"}),Object.defineProperty(e.prototype.revokeKycFromTokenAccount=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"revokeKycFromTokenAccount"}),Object.defineProperty(e.prototype.associateTokens=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"associateTokens"}),Object.defineProperty(e.prototype.dissociateTokens=function e(o,t){return this.rpcCall(e,$root.proto.Transaction,$root.proto.TransactionResponse,o,t)},"name",{value:"dissociateTokens"}),Object.defineProperty(e.prototype.getTokenInfo=function e(o,t){return this.rpcCall(e,$root.proto.Query,$root.proto.Response,o,t)},"name",{value:"getTokenInfo"}),e}(),TokenTransfersTransactionBody:function(){function e(e){if(this.tokenTransfers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.tokenTransfers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenTransfers&&e.tokenTransfers.length)for(var t=0;t<e.tokenTransfers.length;++t)$root.proto.TokenTransferList.encode(e.tokenTransfers[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenTransfersTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenTransfers&&d.tokenTransfers.length||(d.tokenTransfers=[]),d.tokenTransfers.push($root.proto.TokenTransferList.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}e.prototype.transactionID=null,e.prototype.nodeAccountID=null,e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.transactionValidDuration=null,e.prototype.generateRecord=!1,e.prototype.memo="",e.prototype.contractCall=null,e.prototype.contractCreateInstance=null,e.prototype.contractUpdateInstance=null,e.prototype.contractDeleteInstance=null,e.prototype.cryptoAddLiveHash=null,e.prototype.cryptoCreateAccount=null,e.prototype.cryptoDelete=null,e.prototype.cryptoDeleteLiveHash=null,e.prototype.cryptoTransfer=null,e.prototype.cryptoUpdateAccount=null,e.prototype.fileAppend=null,e.prototype.fileCreate=null,e.prototype.fileDelete=null,e.prototype.fileUpdate=null,e.prototype.systemDelete=null,e.prototype.systemUndelete=null,e.prototype.freeze=null,e.prototype.consensusCreateTopic=null,e.prototype.consensusUpdateTopic=null,e.prototype.consensusDeleteTopic=null,e.prototype.consensusSubmitMessage=null,e.prototype.uncheckedSubmit=null,e.prototype.tokenCreation=null,e.prototype.tokenFreeze=null,e.prototype.tokenUnfreeze=null,e.prototype.tokenGrantKyc=null,e.prototype.tokenRevokeKyc=null,e.prototype.tokenDeletion=null,e.prototype.tokenUpdate=null,e.prototype.tokenMint=null,e.prototype.tokenBurn=null,e.prototype.tokenWipe=null,e.prototype.tokenAssociate=null,e.prototype.tokenDissociate=null,e.prototype.scheduleCreate=null,e.prototype.scheduleDelete=null,e.prototype.scheduleSign=null;let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["contractCall","contractCreateInstance","contractUpdateInstance","contractDeleteInstance","cryptoAddLiveHash","cryptoCreateAccount","cryptoDelete","cryptoDeleteLiveHash","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","uncheckedSubmit","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","scheduleCreate","scheduleDelete","scheduleSign"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(10).fork()).ldelim(),null!=e.nodeAccountID&&Object.hasOwnProperty.call(e,"nodeAccountID")&&$root.proto.AccountID.encode(e.nodeAccountID,o.uint32(18).fork()).ldelim(),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(24).uint64(e.transactionFee),null!=e.transactionValidDuration&&Object.hasOwnProperty.call(e,"transactionValidDuration")&&$root.proto.Duration.encode(e.transactionValidDuration,o.uint32(34).fork()).ldelim(),null!=e.generateRecord&&Object.hasOwnProperty.call(e,"generateRecord")&&o.uint32(40).bool(e.generateRecord),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),null!=e.contractCall&&Object.hasOwnProperty.call(e,"contractCall")&&$root.proto.ContractCallTransactionBody.encode(e.contractCall,o.uint32(58).fork()).ldelim(),null!=e.contractCreateInstance&&Object.hasOwnProperty.call(e,"contractCreateInstance")&&$root.proto.ContractCreateTransactionBody.encode(e.contractCreateInstance,o.uint32(66).fork()).ldelim(),null!=e.contractUpdateInstance&&Object.hasOwnProperty.call(e,"contractUpdateInstance")&&$root.proto.ContractUpdateTransactionBody.encode(e.contractUpdateInstance,o.uint32(74).fork()).ldelim(),null!=e.cryptoAddLiveHash&&Object.hasOwnProperty.call(e,"cryptoAddLiveHash")&&$root.proto.CryptoAddLiveHashTransactionBody.encode(e.cryptoAddLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoCreateAccount&&Object.hasOwnProperty.call(e,"cryptoCreateAccount")&&$root.proto.CryptoCreateTransactionBody.encode(e.cryptoCreateAccount,o.uint32(90).fork()).ldelim(),null!=e.cryptoDelete&&Object.hasOwnProperty.call(e,"cryptoDelete")&&$root.proto.CryptoDeleteTransactionBody.encode(e.cryptoDelete,o.uint32(98).fork()).ldelim(),null!=e.cryptoDeleteLiveHash&&Object.hasOwnProperty.call(e,"cryptoDeleteLiveHash")&&$root.proto.CryptoDeleteLiveHashTransactionBody.encode(e.cryptoDeleteLiveHash,o.uint32(106).fork()).ldelim(),null!=e.cryptoTransfer&&Object.hasOwnProperty.call(e,"cryptoTransfer")&&$root.proto.CryptoTransferTransactionBody.encode(e.cryptoTransfer,o.uint32(114).fork()).ldelim(),null!=e.cryptoUpdateAccount&&Object.hasOwnProperty.call(e,"cryptoUpdateAccount")&&$root.proto.CryptoUpdateTransactionBody.encode(e.cryptoUpdateAccount,o.uint32(122).fork()).ldelim(),null!=e.fileAppend&&Object.hasOwnProperty.call(e,"fileAppend")&&$root.proto.FileAppendTransactionBody.encode(e.fileAppend,o.uint32(130).fork()).ldelim(),null!=e.fileCreate&&Object.hasOwnProperty.call(e,"fileCreate")&&$root.proto.FileCreateTransactionBody.encode(e.fileCreate,o.uint32(138).fork()).ldelim(),null!=e.fileDelete&&Object.hasOwnProperty.call(e,"fileDelete")&&$root.proto.FileDeleteTransactionBody.encode(e.fileDelete,o.uint32(146).fork()).ldelim(),null!=e.fileUpdate&&Object.hasOwnProperty.call(e,"fileUpdate")&&$root.proto.FileUpdateTransactionBody.encode(e.fileUpdate,o.uint32(154).fork()).ldelim(),null!=e.systemDelete&&Object.hasOwnProperty.call(e,"systemDelete")&&$root.proto.SystemDeleteTransactionBody.encode(e.systemDelete,o.uint32(162).fork()).ldelim(),null!=e.systemUndelete&&Object.hasOwnProperty.call(e,"systemUndelete")&&$root.proto.SystemUndeleteTransactionBody.encode(e.systemUndelete,o.uint32(170).fork()).ldelim(),null!=e.contractDeleteInstance&&Object.hasOwnProperty.call(e,"contractDeleteInstance")&&$root.proto.ContractDeleteTransactionBody.encode(e.contractDeleteInstance,o.uint32(178).fork()).ldelim(),null!=e.freeze&&Object.hasOwnProperty.call(e,"freeze")&&$root.proto.FreezeTransactionBody.encode(e.freeze,o.uint32(186).fork()).ldelim(),null!=e.consensusCreateTopic&&Object.hasOwnProperty.call(e,"consensusCreateTopic")&&$root.proto.ConsensusCreateTopicTransactionBody.encode(e.consensusCreateTopic,o.uint32(194).fork()).ldelim(),null!=e.consensusUpdateTopic&&Object.hasOwnProperty.call(e,"consensusUpdateTopic")&&$root.proto.ConsensusUpdateTopicTransactionBody.encode(e.consensusUpdateTopic,o.uint32(202).fork()).ldelim(),null!=e.consensusDeleteTopic&&Object.hasOwnProperty.call(e,"consensusDeleteTopic")&&$root.proto.ConsensusDeleteTopicTransactionBody.encode(e.consensusDeleteTopic,o.uint32(210).fork()).ldelim(),null!=e.consensusSubmitMessage&&Object.hasOwnProperty.call(e,"consensusSubmitMessage")&&$root.proto.ConsensusSubmitMessageTransactionBody.encode(e.consensusSubmitMessage,o.uint32(218).fork()).ldelim(),null!=e.uncheckedSubmit&&Object.hasOwnProperty.call(e,"uncheckedSubmit")&&$root.proto.UncheckedSubmitBody.encode(e.uncheckedSubmit,o.uint32(226).fork()).ldelim(),null!=e.tokenCreation&&Object.hasOwnProperty.call(e,"tokenCreation")&&$root.proto.TokenCreateTransactionBody.encode(e.tokenCreation,o.uint32(234).fork()).ldelim(),null!=e.tokenFreeze&&Object.hasOwnProperty.call(e,"tokenFreeze")&&$root.proto.TokenFreezeAccountTransactionBody.encode(e.tokenFreeze,o.uint32(250).fork()).ldelim(),null!=e.tokenUnfreeze&&Object.hasOwnProperty.call(e,"tokenUnfreeze")&&$root.proto.TokenUnfreezeAccountTransactionBody.encode(e.tokenUnfreeze,o.uint32(258).fork()).ldelim(),null!=e.tokenGrantKyc&&Object.hasOwnProperty.call(e,"tokenGrantKyc")&&$root.proto.TokenGrantKycTransactionBody.encode(e.tokenGrantKyc,o.uint32(266).fork()).ldelim(),null!=e.tokenRevokeKyc&&Object.hasOwnProperty.call(e,"tokenRevokeKyc")&&$root.proto.TokenRevokeKycTransactionBody.encode(e.tokenRevokeKyc,o.uint32(274).fork()).ldelim(),null!=e.tokenDeletion&&Object.hasOwnProperty.call(e,"tokenDeletion")&&$root.proto.TokenDeleteTransactionBody.encode(e.tokenDeletion,o.uint32(282).fork()).ldelim(),null!=e.tokenUpdate&&Object.hasOwnProperty.call(e,"tokenUpdate")&&$root.proto.TokenUpdateTransactionBody.encode(e.tokenUpdate,o.uint32(290).fork()).ldelim(),null!=e.tokenMint&&Object.hasOwnProperty.call(e,"tokenMint")&&$root.proto.TokenMintTransactionBody.encode(e.tokenMint,o.uint32(298).fork()).ldelim(),null!=e.tokenBurn&&Object.hasOwnProperty.call(e,"tokenBurn")&&$root.proto.TokenBurnTransactionBody.encode(e.tokenBurn,o.uint32(306).fork()).ldelim(),null!=e.tokenWipe&&Object.hasOwnProperty.call(e,"tokenWipe")&&$root.proto.TokenWipeAccountTransactionBody.encode(e.tokenWipe,o.uint32(314).fork()).ldelim(),null!=e.tokenAssociate&&Object.hasOwnProperty.call(e,"tokenAssociate")&&$root.proto.TokenAssociateTransactionBody.encode(e.tokenAssociate,o.uint32(322).fork()).ldelim(),null!=e.tokenDissociate&&Object.hasOwnProperty.call(e,"tokenDissociate")&&$root.proto.TokenDissociateTransactionBody.encode(e.tokenDissociate,o.uint32(330).fork()).ldelim(),null!=e.scheduleCreate&&Object.hasOwnProperty.call(e,"scheduleCreate")&&$root.proto.ScheduleCreateTransactionBody.encode(e.scheduleCreate,o.uint32(338).fork()).ldelim(),null!=e.scheduleDelete&&Object.hasOwnProperty.call(e,"scheduleDelete")&&$root.proto.ScheduleDeleteTransactionBody.encode(e.scheduleDelete,o.uint32(346).fork()).ldelim(),null!=e.scheduleSign&&Object.hasOwnProperty.call(e,"scheduleSign")&&$root.proto.ScheduleSignTransactionBody.encode(e.scheduleSign,o.uint32(354).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 2:d.nodeAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.transactionFee=e.uint64();break;case 4:d.transactionValidDuration=$root.proto.Duration.decode(e,e.uint32());break;case 5:d.generateRecord=e.bool();break;case 6:d.memo=e.string();break;case 7:d.contractCall=$root.proto.ContractCallTransactionBody.decode(e,e.uint32());break;case 8:d.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(e,e.uint32());break;case 9:d.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(e,e.uint32());break;case 22:d.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(e,e.uint32());break;case 10:d.cryptoAddLiveHash=$root.proto.CryptoAddLiveHashTransactionBody.decode(e,e.uint32());break;case 11:d.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(e,e.uint32());break;case 12:d.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(e,e.uint32());break;case 13:d.cryptoDeleteLiveHash=$root.proto.CryptoDeleteLiveHashTransactionBody.decode(e,e.uint32());break;case 14:d.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(e,e.uint32());break;case 15:d.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(e,e.uint32());break;case 16:d.fileAppend=$root.proto.FileAppendTransactionBody.decode(e,e.uint32());break;case 17:d.fileCreate=$root.proto.FileCreateTransactionBody.decode(e,e.uint32());break;case 18:d.fileDelete=$root.proto.FileDeleteTransactionBody.decode(e,e.uint32());break;case 19:d.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(e,e.uint32());break;case 20:d.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(e,e.uint32());break;case 21:d.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(e,e.uint32());break;case 23:d.freeze=$root.proto.FreezeTransactionBody.decode(e,e.uint32());break;case 24:d.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(e,e.uint32());break;case 25:d.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(e,e.uint32());break;case 26:d.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(e,e.uint32());break;case 27:d.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(e,e.uint32());break;case 28:d.uncheckedSubmit=$root.proto.UncheckedSubmitBody.decode(e,e.uint32());break;case 29:d.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(e,e.uint32());break;case 31:d.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(e,e.uint32());break;case 32:d.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(e,e.uint32());break;case 33:d.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(e,e.uint32());break;case 34:d.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(e,e.uint32());break;case 35:d.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(e,e.uint32());break;case 36:d.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(e,e.uint32());break;case 37:d.tokenMint=$root.proto.TokenMintTransactionBody.decode(e,e.uint32());break;case 38:d.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(e,e.uint32());break;case 39:d.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(e,e.uint32());break;case 40:d.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(e,e.uint32());break;case 41:d.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(e,e.uint32());break;case 42:d.scheduleCreate=$root.proto.ScheduleCreateTransactionBody.decode(e,e.uint32());break;case 43:d.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(e,e.uint32());break;case 44:d.scheduleSign=$root.proto.ScheduleSignTransactionBody.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),UncheckedSubmitBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transactionBytes=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionBytes&&Object.hasOwnProperty.call(e,"transactionBytes")&&o.uint32(10).bytes(e.transactionBytes),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UncheckedSubmitBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionBytes=e.bytes();break;default:e.skipType(7&i);}return d},e}(),SignedTransaction:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.bodyBytes=$util.newBuffer([]),e.prototype.sigMap=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.bodyBytes&&Object.hasOwnProperty.call(e,"bodyBytes")&&o.uint32(10).bytes(e.bodyBytes),null!=e.sigMap&&Object.hasOwnProperty.call(e,"sigMap")&&$root.proto.SignatureMap.encode(e.sigMap,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignedTransaction,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.bodyBytes=e.bytes();break;case 2:d.sigMap=$root.proto.SignatureMap.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TransactionList:function(){function e(e){if(this.transactionList=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.transactionList=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transactionList&&e.transactionList.length)for(var t=0;t<e.transactionList.length;++t)$root.proto.Transaction.encode(e.transactionList[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionList&&d.transactionList.length||(d.transactionList=[]),d.transactionList.push($root.proto.Transaction.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),DoubleValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(9).double(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.DoubleValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.double();break;default:e.skipType(7&i);}return d},e}(),FloatValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(13).float(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FloatValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.float();break;default:e.skipType(7&i);}return d},e}(),Int64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Int64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int64();break;default:e.skipType(7&i);}return d},e}(),UInt64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UInt64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint64();break;default:e.skipType(7&i);}return d},e}(),Int32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Int32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int32();break;default:e.skipType(7&i);}return d},e}(),UInt32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UInt32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint32();break;default:e.skipType(7&i);}return d},e}(),BoolValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).bool(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.BoolValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bool();break;default:e.skipType(7&i);}return d},e}(),StringValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).string(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.StringValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.string();break;default:e.skipType(7&i);}return d},e}(),BytesValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).bytes(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.BytesValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bytes();break;default:e.skipType(7&i);}return d},e}()};return e})();exports.proto=proto;const google=$root.google=(()=>{const e={protobuf:function(){const e={DoubleValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(9).double(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.DoubleValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.double();break;default:e.skipType(7&i);}return d},e}(),FloatValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(13).float(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.FloatValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.float();break;default:e.skipType(7&i);}return d},e}(),Int64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.Int64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int64();break;default:e.skipType(7&i);}return d},e}(),UInt64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.UInt64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint64();break;default:e.skipType(7&i);}return d},e}(),Int32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.Int32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int32();break;default:e.skipType(7&i);}return d},e}(),UInt32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.UInt32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint32();break;default:e.skipType(7&i);}return d},e}(),BoolValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).bool(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.BoolValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bool();break;default:e.skipType(7&i);}return d},e}(),StringValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).string(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.StringValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.string();break;default:e.skipType(7&i);}return d},e}(),BytesValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]])}return e.prototype.value=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).bytes(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.BytesValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bytes();break;default:e.skipType(7&i);}return d},e}()};return e}()};return e})();exports.google=google;

/***/ }),

/***/ 3165:
/***/ ((module) => {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ 529:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ 4455:
/***/ ((module) => {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ 1179:
/***/ ((module) => {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ 8014:
/***/ ((module) => {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ 4307:
/***/ ((module) => {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ 9188:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ 2639:
/***/ (function(module) {

;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if ( true && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);


/***/ }),

/***/ 492:
/***/ ((module) => {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ 6738:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// minimal library entry point.


module.exports = __nccwpck_require__(8432);


/***/ }),

/***/ 8432:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __nccwpck_require__(1433);
protobuf.BufferWriter = __nccwpck_require__(6268);
protobuf.Reader       = __nccwpck_require__(176);
protobuf.BufferReader = __nccwpck_require__(3543);

// Utility
protobuf.util         = __nccwpck_require__(425);
protobuf.rpc          = __nccwpck_require__(9662);
protobuf.roots        = __nccwpck_require__(9135);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ 176:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = Reader;

var util      = __nccwpck_require__(425);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ 3543:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __nccwpck_require__(176);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __nccwpck_require__(425);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ 9135:
/***/ ((module) => {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ 9662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __nccwpck_require__(6057);


/***/ }),

/***/ 6057:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = Service;

var util = __nccwpck_require__(425);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ 1889:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = LongBits;

var util = __nccwpck_require__(425);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ 425:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __nccwpck_require__(3165);

// converts to / from base64 encoded strings
util.base64 = __nccwpck_require__(529);

// base class of rpc.Service
util.EventEmitter = __nccwpck_require__(4455);

// float handling accross browsers
util.float = __nccwpck_require__(1179);

// requires modules optionally and hides the call from bundlers
util.inquire = __nccwpck_require__(8014);

// converts to / from utf8 encoded strings
util.utf8 = __nccwpck_require__(9188);

// provides a node-like buffer pool in the browser
util.pool = __nccwpck_require__(4307);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __nccwpck_require__(1889);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ 1433:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = Writer;

var util      = __nccwpck_require__(425);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ 6268:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __nccwpck_require__(1433);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __nccwpck_require__(425);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ 6703:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __nccwpck_require__(6417);
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ 9413:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * Signals that a key could not be realized from the input.
 */
class BadKeyError extends Error {
  /**
   * @param {Error | string} messageOrCause
   */
  constructor(messageOrCause) {
    super(messageOrCause instanceof Error ? messageOrCause.message : messageOrCause);
    this.name = "BadKeyError";

    if (messageOrCause instanceof Error) {
      /** @type {?Error} */
      this.cause = messageOrCause;
      this.stack = messageOrCause.stack;
    }
  }

}

exports.default = BadKeyError;

/***/ }),

/***/ 2413:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _BadMnemonicReason = _interopRequireDefault(__nccwpck_require__(448));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @typedef {import("./Mnemonic.js").default} Mnemonic */
class BadMnemonicError extends Error {
  /**
   * @param {Mnemonic} mnemonic
   * @param {string} reason
   * @param {number[]} unknownWordIndices
   * @hideconstructor
   */
  constructor(mnemonic, reason, unknownWordIndices) {
    let reasonMessage;

    switch (reason) {
      case _BadMnemonicReason.default.BadLength:
        reasonMessage = "mnemonic is of an unexpected number of words";
        break;

      case _BadMnemonicReason.default.ChecksumMismatch:
        reasonMessage = "checksum byte in mnemonic did not match the rest of the mnemonic";
        break;

      case _BadMnemonicReason.default.UnknownWords:
        reasonMessage = "mnemonic contained words that are not in the standard word list";
        break;

      default:
        throw new Error(`unexpected value ${reason.toString()} for 'reason'`);
    }

    super(`invalid mnemonic: ${reasonMessage}`);

    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, BadMnemonicError);
    }

    this.name = "BadMnemonicError";
    /** The reason for which the mnemonic failed validation. */

    this.reason = reason;
    /** The mnemonic that failed validation. */

    this.mnemonic = mnemonic;
    /**
     * The indices in the mnemonic that were not found in the BIP-39
     * standard English word list.
     */

    this.unknownWordIndices = unknownWordIndices;
  }

}

exports.default = BadMnemonicError;

/***/ }),

/***/ 448:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * Possible statuses for {@link Mnemonic#validate()}.
 *
 * @readonly
 * @enum {string}
 */
const BadMnemonicReason = Object.freeze({
  /**
   * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
   */
  BadLength: "BadLength",

  /**
   * The mnemonic contained words which were not found in the word list.
   */
  UnknownWords: "UnknownWords",

  /**
   * The checksum encoded in the mnemonic did not match the checksum we just calculated for
   * that mnemonic.
   *
   * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
   * after being calculated from it, before being encoded into words.
   *
   * This could happen if two or more of the words were entered out of the original order or
   * replaced with another from the standard word list (as this is only returned if all the words
   * exist in the word list).
   */
  ChecksumMismatch: "ChecksumMismatch"
});
var _default = BadMnemonicReason;
exports.default = _default;

/***/ }),

/***/ 8592:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

class Key {}

exports.default = Key;

/***/ }),

/***/ 2385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Key = _interopRequireDefault(__nccwpck_require__(8592));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A list of Keys (`Key`) with an optional threshold.
 */
class KeyList extends _Key.default {
  /**
   * @param {?Key[]} [keys]
   * @param {?number} [threshold]
   */
  constructor(keys, threshold) {
    super();
    /**
     * @private
     * @type {Key[]}
     */

    this._keys = keys == null ? [] : keys;
    /**
     * @type {?number}
     */

    this._threshold = threshold == null ? null : threshold;
  }
  /**
   * @param {Key[]} keys
   * @returns {KeyList}
   */


  static of(...keys) {
    return new KeyList(keys, null);
  }
  /**
   * @template T
   * @param {ArrayLike<Key>} arrayLike
   * @param {((key: Key) => Key)} [mapFn]
   * @param {T} [thisArg]
   * @returns {KeyList}
   */


  static from(arrayLike, mapFn, thisArg) {
    if (mapFn == null) {
      return new KeyList(Array.from(arrayLike));
    }

    return new KeyList(Array.from(arrayLike, mapFn, thisArg));
  }
  /**
   * @returns {?number}
   */


  get threshold() {
    return this._threshold;
  }
  /**
   * @param {number} threshold
   * @returns {this}
   */


  setThreshold(threshold) {
    this._threshold = threshold;
    return this;
  }
  /**
   * @param {Key[]} keys
   * @returns {number}
   */


  push(...keys) {
    return this._keys.push(...keys);
  }
  /**
   * @param {number} start
   * @param {number} deleteCount
   * @param {Key[]} items
   * @returns {KeyList}
   */


  splice(start, deleteCount, ...items) {
    return new KeyList(this._keys.splice(start, deleteCount, ...items), this.threshold);
  }
  /**
   * @param {number=} start
   * @param {number=} end
   * @returns {KeyList}
   */


  slice(start, end) {
    return new KeyList(this._keys.slice(start, end), this.threshold);
  }
  /**
   * @returns {Iterator<Key>}
   */


  [Symbol.iterator]() {
    return this._keys[Symbol.iterator]();
  }
  /**
   * @returns {Key[]}
   */


  toArray() {
    return this._keys.slice();
  }
  /**
   * @returns {string}
   */


  toString() {
    return JSON.stringify({
      threshold: this._threshold,
      keys: this._keys.toString()
    });
  }

}

exports.default = KeyList;

/***/ }),

/***/ 1568:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _PrivateKey = _interopRequireDefault(__nccwpck_require__(9841));

var _BadMnemonicError = _interopRequireDefault(__nccwpck_require__(2413));

var _BadMnemonicReason = _interopRequireDefault(__nccwpck_require__(448));

var _legacy = _interopRequireDefault(__nccwpck_require__(2675));

var _bip = _interopRequireDefault(__nccwpck_require__(1090));

var sha256 = _interopRequireWildcard(__nccwpck_require__(213));

var pbkdf2 = _interopRequireWildcard(__nccwpck_require__(3223));

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

var hmac = _interopRequireWildcard(__nccwpck_require__(5886));

var slip10 = _interopRequireWildcard(__nccwpck_require__(6520));

var entropy = _interopRequireWildcard(__nccwpck_require__(2771));

var random = _interopRequireWildcard(__nccwpck_require__(5935));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Multi-word mnemonic phrase (BIP-39).
 *
 * Compatible with the official Hedera mobile
 * wallets (24-words or 22-words) and BRD (12-words).
 */
class Mnemonic {
  /**
   * @param {Object} props
   * @param {string[]} props.words
   * @param {boolean} props.legacy
   * @throws {BadMnemonicError}
   * @hideconstructor
   * @private
   */
  constructor({
    words,
    legacy
  }) {
    this.words = words;
    this._isLegacy = legacy;
  }
  /**
   * Returns a new random 24-word mnemonic from the BIP-39
   * standard English word list.
   *
   * @returns {Promise<Mnemonic>}
   */


  static generate() {
    return Mnemonic._generate(24);
  }
  /**
   * Returns a new random 12-word mnemonic from the BIP-39
   * standard English word list.
   *
   * @returns {Promise<Mnemonic>}
   */


  static generate12() {
    return Mnemonic._generate(12);
  }
  /**
   * @param {number} length
   * @returns {Promise<Mnemonic>}
   */


  static async _generate(length) {
    // only 12-word or 24-word lengths are supported
    let neededEntropy;
    if (length === 12) neededEntropy = 16;else if (length === 24) neededEntropy = 32;else {
      throw new Error(`unsupported phrase length ${length}, only 12 or 24 are supported`);
    } // inlined from (ISC) with heavy alternations for modern crypto
    // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125

    const seed = await random.bytesAsync(neededEntropy);
    const entropyBits = bytesToBinary(Array.from(seed));
    const checksumBits = await deriveChecksumBits(seed);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = (chunks != null ? chunks : []).map(binary => _bip.default[binaryToByte(binary)]);
    return new Mnemonic({
      words,
      legacy: false
    });
  }
  /**
   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
   *
   * An exception of BadMnemonicError will be thrown if the mnemonic
   * contains unknown words or fails the checksum. An invalid mnemonic
   * can still be used to create private keys, the exception will
   * contain the failing mnemonic in case you wish to ignore the
   * validation error and continue.
   *
   * @param {string[]} words
   * @throws {BadMnemonicError}
   * @returns {Promise<Mnemonic>}
   */


  static async fromWords(words) {
    return await new Mnemonic({
      words,
      legacy: words.length === 22
    })._validate();
  }
  /**
   * Recover a private key from this mnemonic phrase, with an
   * optional passphrase.
   *
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */


  async toPrivateKey(passphrase = "") {
    if (this._isLegacy) {
      if (passphrase.length > 0) {
        throw new Error("legacy 22-word mnemonics do not support passphrases");
      }

      return this.toLegacyPrivateKey();
    }

    return await this._toPrivateKey(passphrase);
  }
  /**
   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
   *
   * @param {string} mnemonic
   * @returns {Promise<Mnemonic>}
   */


  static async fromString(mnemonic) {
    return Mnemonic.fromWords(mnemonic.split(/\s|,/));
  }
  /**
   * @returns {Promise<Mnemonic>}
   * @private
   */


  async _validate() {
    // Validate that this is a valid BIP-39 mnemonic
    // as generated by BIP-39's rules.
    // Technically, invalid mnemonics can still be used to generate valid private keys,
    // but if they became invalid due to user error then it will be difficult for the user
    // to tell the difference unless they compare the generated keys.
    // During validation, the following conditions are checked in order
    //  1)) 24 or 12 words
    //  2) All strings in {@link this.words} exist in the BIP-39
    //     standard English word list (no normalization is done)
    //  3) The calculated checksum for the mnemonic equals the
    //     checksum encoded in the mnemonic
    if (this._isLegacy) {
      if (this.words.length !== 22) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.BadLength, []);
      }

      const unknownWordIndices = this.words.reduce((
      /** @type {number[]} */
      unknowns, word, index) => _legacy.default.includes(word.toLowerCase()) ? unknowns : [...unknowns, index], []);

      if (unknownWordIndices.length > 0) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.UnknownWords, unknownWordIndices);
      }

      const [seed, checksum] = entropy.legacy1(this.words, _legacy.default);
      const newChecksum = entropy.crc8(seed);

      if (checksum !== newChecksum) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.ChecksumMismatch, []);
      }
    } else {
      if (!(this.words.length === 12 || this.words.length === 24)) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.BadLength, []);
      }

      const unknownWordIndices = this.words.reduce((
      /** @type {number[]} */
      unknowns, word, index) => _bip.default.includes(word) ? unknowns : [...unknowns, index], []);

      if (unknownWordIndices.length > 0) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.UnknownWords, unknownWordIndices);
      } // FIXME: calculate checksum and compare
      // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112


      const bits = this.words.map(word => {
        return _bip.default.indexOf(word).toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
      const entropyBytes =
      /** @type {RegExpMatchArray} */
      entropyBitsRegex.map(binaryToByte);
      const newChecksum = await deriveChecksumBits(Uint8Array.from(entropyBytes));

      if (newChecksum !== checksumBits) {
        throw new _BadMnemonicError.default(this, _BadMnemonicReason.default.ChecksumMismatch, []);
      }
    }

    return this;
  }
  /**
   * @private
   * @param {string} passphrase
   * @returns {Promise<PrivateKey>}
   */


  async _toPrivateKey(passphrase = "") {
    const input = this.words.join(" ");
    const salt = `mnemonic${passphrase}`;
    const seed = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha512, input, salt, 2048, 64);
    const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, "ed25519 seed", seed);
    let keyData = digest.subarray(0, 32);
    let chainCode = digest.subarray(32);

    for (const index of [44, 3030, 0, 0]) {
      ({
        keyData,
        chainCode
      } = await slip10.derive(keyData, chainCode, index));
    }

    const keyPair = _tweetnacl.default.sign.keyPair.fromSeed(keyData);

    return new _PrivateKey.default(keyPair, chainCode);
  }
  /**
   * @returns {Promise<PrivateKey>}
   */


  async toLegacyPrivateKey() {
    let seed;

    if (this._isLegacy) {
      [seed] = entropy.legacy1(this.words, _legacy.default);
    } else {
      seed = await entropy.legacy2(this.words, _bip.default);
    }

    return _PrivateKey.default.fromBytes(seed);
  }
  /**
   * @returns {string}
   */


  toString() {
    return this.words.join(" ");
  }

}
/**
 * @param {string} bin
 * @returns {number}
 */


exports.default = Mnemonic;

function binaryToByte(bin) {
  return parseInt(bin, 2);
}
/**
 * @param {number[]} bytes
 * @returns {string}
 */


function bytesToBinary(bytes) {
  return bytes.map(x => x.toString(2).padStart(8, "0")).join("");
}
/**
 * @param {Uint8Array} entropyBuffer
 * @returns {Promise<string>}
 */


async function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash = await sha256.digest(entropyBuffer);
  return bytesToBinary(Array.from(hash)).slice(0, CS);
}

/***/ }),

/***/ 9841:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

var _PublicKey = _interopRequireDefault(__nccwpck_require__(6235));

var _Mnemonic = _interopRequireDefault(__nccwpck_require__(1568));

var _array = __nccwpck_require__(4454);

var _keystore = __nccwpck_require__(7749);

var _BadKeyError = _interopRequireDefault(__nccwpck_require__(9413));

var hex = _interopRequireWildcard(__nccwpck_require__(7346));

var _pem = __nccwpck_require__(3260);

var slip10 = _interopRequireWildcard(__nccwpck_require__(6520));

var _Key = _interopRequireDefault(__nccwpck_require__(8592));

var random = _interopRequireWildcard(__nccwpck_require__(5935));

var derive = _interopRequireWildcard(__nccwpck_require__(9833));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const derPrefix = "302e020100300506032b657004220420";
const derPrefixBytes = hex.decode(derPrefix);
/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @typedef {object} Transaction
 * @property {() => boolean} _isFrozen
 * @property {ProtoSignedTransaction[]} _signedTransactions
 * @property {Set<string>} _signerPublicKeys
 * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature
 * @property {() => void} _requireFrozen
 * @property {() => Transaction} freeze
 */

/**
 * A private key on the Hedera network.
 */

class PrivateKey extends _Key.default {
  /**
   * @hideconstructor
   * @internal
   * @param {nacl.SignKeyPair} keyPair
   * @param {?Uint8Array} chainCode
   */
  constructor(keyPair, chainCode) {
    super();
    /**
     * @type {nacl.SignKeyPair}
     * @readonly
     * @private
     */

    this._keyPair = keyPair;
    /**
     * @type {?Uint8Array}
     * @readonly
     * @private
     */

    this._chainCode = chainCode;
  }
  /**
   * Generate a random Ed25519 private key.
   *
   * @returns {PrivateKey}
   */


  static generate() {
    // 32 bytes for the secret key
    // 32 bytes for the chain code (to support derivation)
    const entropy = random.bytes(64);
    return new PrivateKey(_tweetnacl.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)), entropy.subarray(32));
  }
  /**
   * Generate a random Ed25519 private key.
   *
   * @returns {Promise<PrivateKey>}
   */


  static async generateAsync() {
    // 32 bytes for the secret key
    // 32 bytes for the chain code (to support derivation)
    const entropy = await random.bytesAsync(64);
    return new PrivateKey(_tweetnacl.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)), entropy.subarray(32));
  }
  /**
   * Construct a private key from bytes.
   *
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */


  static fromBytes(data) {
    switch (data.length) {
      case 48:
        if ((0, _array.arrayStartsWith)(data, derPrefixBytes)) {
          const keyPair = _tweetnacl.default.sign.keyPair.fromSeed(data.subarray(16));

          return new PrivateKey(keyPair, null);
        }

        break;

      case 32:
        return new PrivateKey(_tweetnacl.default.sign.keyPair.fromSeed(data), null);

      case 64:
        // priv + pub key
        return new PrivateKey(_tweetnacl.default.sign.keyPair.fromSecretKey(data), null);

      default:
    }

    throw new _BadKeyError.default(`invalid private key length: ${data.length} bytes`);
  }
  /**
   * Construct a private key from a hex-encoded string.
   *
   * @param {string} text
   * @returns {PrivateKey}
   */


  static fromString(text) {
    return PrivateKey.fromBytes(hex.decode(text));
  }
  /**
   * Recover a private key from a mnemonic phrase (and optionally a password).
   *
   * @param {Mnemonic | string} mnemonic
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */


  static async fromMnemonic(mnemonic, passphrase = "") {
    return (typeof mnemonic === "string" ? await _Mnemonic.default.fromString(mnemonic) : mnemonic).toPrivateKey(passphrase);
  }
  /**
   * Recover a private key from a keystore, previously created by `.toKeystore()`.
   *
   * This key will _not_ support child key derivation.
   *
   * @param {Uint8Array} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
   */


  static async fromKeystore(data, passphrase = "") {
    return new PrivateKey(await (0, _keystore.loadKeystore)(data, passphrase), null);
  }
  /**
   * Recover a private key from a pem string; the private key may be encrypted.
   *
   * This method assumes the .pem file has been converted to a string already.
   *
   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
   * section and decodes that as a DER-encoded  private key.
   *
   * @param {string} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */


  static async fromPem(data, passphrase = "") {
    return new PrivateKey(await (0, _pem.read)(data, passphrase), null);
  }
  /**
   * Derive a new private key at the given wallet index.
   *
   * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
   * an error.
   *
   * You can check if a key supports derivation with `.supportsDerivation()`
   *
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */


  async derive(index) {
    if (this._chainCode == null) {
      throw new Error("this private key does not support key derivation");
    }

    const {
      keyData,
      chainCode
    } = await slip10.derive(this.toBytes(), this._chainCode, index);

    const keyPair = _tweetnacl.default.sign.keyPair.fromSeed(keyData);

    return new PrivateKey(keyPair, chainCode);
  }
  /**
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */


  async legacyDerive(index) {
    const keyBytes = await derive.legacy(this.toBytes().subarray(0, 32), index);
    return PrivateKey.fromBytes(keyBytes);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   *
   * @returns {PublicKey}
   */


  get publicKey() {
    return new _PublicKey.default(this._keyPair.publicKey);
  }
  /**
   * Sign a message with this private key.
   *
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */


  sign(bytes) {
    return _tweetnacl.default.sign.detached(bytes, this._keyPair.secretKey);
  }
  /**
   * @param {Transaction} transaction
   * @returns {Uint8Array}
   */


  signTransaction(transaction) {
    transaction._requireFrozen();

    if (!transaction._isFrozen()) {
      transaction.freeze();
    }

    if (transaction._signedTransactions.length != 1) {
      throw new Error("`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set");
    }

    const tx =
    /** @type {ProtoSignedTransaction} */
    transaction._signedTransactions[0];
    const publicKeyHex = hex.encode(this.publicKey.toBytes());

    if (tx.sigMap == null) {
      tx.sigMap = {};
    }

    if (tx.sigMap.sigPair == null) {
      tx.sigMap.sigPair = [];
    }

    for (const sigPair of tx.sigMap.sigPair) {
      if (sigPair.pubKeyPrefix != null && hex.encode(sigPair.pubKeyPrefix) === publicKeyHex) {
        return (
          /** @type {Uint8Array} */
          sigPair.ed25519
        );
      }
    }

    const siganture = this.sign(tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array());
    tx.sigMap.sigPair.push({
      pubKeyPrefix: this.publicKey.toBytes(),
      ed25519: siganture
    });

    transaction._signerPublicKeys.add(publicKeyHex);

    return siganture;
  }
  /**
   * Check if `derive` can be called on this private key.
   *
   * This is only the case if the key was created from a mnemonic.
   *
   * @returns {boolean}
   */


  isDerivable() {
    return this._chainCode != null;
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    // copy the bytes so they can't be modified accidentally
    return this._keyPair.secretKey.slice(0, 32);
  }
  /**
   * @returns {string}
   */


  toString() {
    return derPrefix + hex.encode(this.toBytes());
  }
  /**
   * Create a keystore with a given passphrase.
   *
   * The key can be recovered later with `fromKeystore()`.
   *
   * Note that this will not retain the ancillary data used for
   * deriving child keys, thus `.derive()` on the restored key will
   * throw even if this instance supports derivation.
   *
   * @param {string} [passphrase]
   * @returns {Promise<Uint8Array>}
   */


  toKeystore(passphrase = "") {
    return (0, _keystore.createKeystore)(this.toBytes(), passphrase);
  }

}

exports.default = PrivateKey;

/***/ }),

/***/ 6235:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

var _Key = _interopRequireDefault(__nccwpck_require__(8592));

var _array = __nccwpck_require__(4454);

var _BadKeyError = _interopRequireDefault(__nccwpck_require__(9413));

var hex = _interopRequireWildcard(__nccwpck_require__(7346));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./PrivateKey.js").Transaction} Transaction
 */
const derPrefix = "302a300506032b6570032100";
const derPrefixBytes = hex.decode(derPrefix);
/**
 * An public key on the Hedera network.
 */

class PublicKey extends _Key.default {
  /**
   * @internal
   * @hideconstructor
   * @param {Uint8Array} keyData
   */
  constructor(keyData) {
    super();
    /**
     * @type {Uint8Array}
     * @private
     * @readonly
     */

    this._keyData = keyData;
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */


  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return new PublicKey(data);

      case 44:
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if ((0, _array.arrayStartsWith)(data, derPrefixBytes)) {
          return new PublicKey(data.subarray(12));
        }

        break;

      default:
    }

    throw new _BadKeyError.default(`invalid public key length: ${data.length} bytes`);
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   *
   * @param {string} text
   * @returns {PublicKey}
   */


  static fromString(text) {
    return PublicKey.fromBytes(hex.decode(text));
  }
  /**
   * Verify a signature on a message with this public key.
   *
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */


  verify(message, signature) {
    return _tweetnacl.default.sign.detached.verify(message, signature, this._keyData);
  }
  /**
   * @param {Transaction} transaction
   * @returns {boolean}
   */


  verifyTransaction(transaction) {
    transaction._requireFrozen();

    if (!transaction._isFrozen()) {
      transaction.freeze();
    }

    for (const signedTransaction of transaction._signedTransactions) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;

        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix =
          /** @type {Uint8Array} */
          sigPair.pubKeyPrefix;

          if ((0, _array.arrayEqual)(pubKeyPrefix, this._keyData)) {
            found = true;
            const bodyBytes =
            /** @type {Uint8Array} */
            signedTransaction.bodyBytes;
            const signature =
            /** @type {Uint8Array} */
            sigPair.ed25519;

            if (!_tweetnacl.default.sign.detached.verify(bodyBytes, signature, this._keyData)) {
              return false;
            }
          }
        }

        if (!found) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return this._keyData.slice();
  }
  /**
   * @returns {string}
   */


  toString() {
    return derPrefix + hex.encode(this._keyData);
  }
  /**
   * @param {PublicKey} other
   * @returns {boolean}
   */


  equals(other) {
    return (0, _array.arrayEqual)(this._keyData, other._keyData);
  }

}

exports.default = PublicKey;

/***/ }),

/***/ 5604:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decode = decode;
exports.encode = encode;

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function decode(text) {
  return Buffer.from(text, "base64");
}
/**
 * @param {Uint8Array} data
 * @returns {string};
 */


function encode(data) {
  return Buffer.from(data).toString("base64");
}

/***/ }),

/***/ 87:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decode = decode;

/**
 * @typedef {Object} AsnSeq
 * @property {AsnType[]} seq
 */

/**
 * @typedef {Object} AsnInt
 * @property {number} int
 */

/**
 * @typedef {Object} AsnBytes
 * @property {Uint8Array} bytes
 */

/**
 * @typedef {Object} AsnIdent
 * @property {string} ident
 */

/**
 * @typedef {{}} AsnNull
 */

/**
 * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType
 */

/**
 * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.
 *
 *@param {Uint8Array} data
 *@returns {AsnType}
 */
function decode(data) {
  return decodeIncremental(data)[0];
}
/**
 * @param {Uint8Array} bytes
 * @returns {[AsnType, Uint8Array]}
 */


function decodeIncremental(bytes) {
  // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data
  const [len, rem] = decodeLength(bytes.subarray(1));
  const data = rem.subarray(0, len);
  const tail = rem.subarray(len);

  switch (bytes[0]) {
    case 2:
      return [{
        int: decodeInt(data)
      }, tail];

    case 4:
      // must always be primitive form in DER; for OCTET STRING this is literal bytes
      return [{
        bytes: data
      }, tail];

    case 5:
      // empty
      return [{}, tail];

    case 6:
      return [{
        ident: decodeObjectIdent(data)
      }, tail];

    case 48:
      return [{
        seq: decodeSeq(data)
      }, tail];

    default:
      throw new Error(`unsupported DER type tag: ${bytes[0]}`);
  }
}
/**
 * @param {Uint8Array} seqBytes
 * @returns {AsnType[]}
 */


function decodeSeq(seqBytes) {
  let data = seqBytes;
  const seq = [];

  while (data.length !== 0) {
    const [decoded, remaining] = decodeIncremental(data);
    seq.push(decoded);
    data = remaining;
  }

  return seq;
}
/**
 * @param {Uint8Array} idBytes
 * @returns {string}
 */


function decodeObjectIdent(idBytes) {
  const id = [// first octet is 40 * value1 + value2
  Math.floor(idBytes[0] / 40), idBytes[0] % 40]; // each following ID component is big-endian base128 where the MSB is set if another byte
  // follows for the same value

  let val = 0;

  for (const byte of idBytes.subarray(1)) {
    // shift the entire value left by 7 bits
    val *= 128;

    if (byte < 128) {
      // no more octets follow for this value, finish it off
      val += byte;
      id.push(val);
      val = 0;
    } else {
      // zero the MSB
      val += byte & 127;
    }
  }

  return id.join(".");
}
/**
 * @param {Uint8Array} lenBytes
 * @returns {[number, Uint8Array]}
 */


function decodeLength(lenBytes) {
  if (lenBytes[0] < 128) {
    // definite, short form
    return [lenBytes[0], lenBytes.subarray(1)];
  }

  const numBytes = lenBytes[0] - 128;
  const intBytes = lenBytes.subarray(1, numBytes + 1);
  const rem = lenBytes.subarray(numBytes + 1);
  return [decodeInt(intBytes), rem];
}
/**
 * @param {Uint8Array} intBytes
 * @returns {number}
 */


function decodeInt(intBytes) {
  const len = intBytes.length;

  if (len === 1) {
    return intBytes[0];
  }

  let view = new DataView(intBytes.buffer, intBytes.byteOffset, intBytes.byteLength);
  if (len === 2) return view.getUint16(0, false);

  if (len === 3) {
    // prefix a zero byte and we'll treat it as a 32-bit int
    const data = Uint8Array.of(0, ...intBytes);
    view = new DataView(data.buffer);
  }

  if (len > 4) {
    // this probably means a bug in the decoding as this would mean a >4GB structure
    throw new Error(`unsupported DER integer length of ${len} bytes`);
  }

  return view.getUint32(0, false);
}

/***/ }),

/***/ 7346:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encode = encode;
exports.decode = decode;

/**
 * @type {string[]}
 */
const byteToHex = [];

for (let n = 0; n <= 0xff; n += 1) {
  byteToHex.push(n.toString(16).padStart(2, "0"));
}
/**
 * @param {Uint8Array} data
 * @returns {string}
 */


function encode(data) {
  return Buffer.from(data).toString("hex");
}
/**
 * @param {string} text
 * @returns {Uint8Array}
 */


function decode(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  return Buffer.from(str, "hex");
}

/***/ }),

/***/ 3260:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.read = read;

var _BadKeyError = _interopRequireDefault(__nccwpck_require__(9413));

var _pkcs = __nccwpck_require__(3202);

var der = _interopRequireWildcard(__nccwpck_require__(87));

var base64 = _interopRequireWildcard(__nccwpck_require__(5604));

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BEGIN_PRIVATEKEY = "-----BEGIN PRIVATE KEY-----\n";
const END_PRIVATEKEY = "-----END PRIVATE KEY-----\n";
const BEGIN_ENCRYPTED_PRIVATEKEY = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n";
const END_ENCRYPTED_PRIVATEKEY = "-----END ENCRYPTED PRIVATE KEY-----\n";
/**
 * @param {string} pem
 * @param {string} [passphrase]
 * @returns {Promise<nacl.SignKeyPair>}
 */

async function read(pem, passphrase) {
  const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;
  const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;
  const beginIndex = pem.indexOf(beginTag);
  const endIndex = pem.indexOf(endTag);

  if (beginIndex === -1 || endIndex === -1) {
    throw new _BadKeyError.default("failed to find a private key in the PEM file");
  }

  const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);
  const key = base64.decode(keyEncoded);

  if (passphrase) {
    let encrypted;

    try {
      encrypted = _pkcs.EncryptedPrivateKeyInfo.parse(key);
    } catch (error) {
      throw new _BadKeyError.default( // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/explicit-module-boundary-types
      `failed to parse encrypted private key: ${error.message}`);
    }

    const decrypted = await encrypted.decrypt(passphrase);

    if (decrypted.algId.algIdent !== "1.3.101.112") {
      throw new _BadKeyError.default(`unknown private key algorithm ${decrypted.algId.toString()}`);
    }

    const keyData = der.decode(decrypted.privateKey);

    if ("bytes" in keyData) {
      return _tweetnacl.default.sign.keyPair.fromSeed(keyData.bytes);
    }

    throw new _BadKeyError.default(`expected ASN bytes, got ${JSON.stringify(keyData)}`);
  }

  return _tweetnacl.default.sign.keyPair.fromSeed(key.subarray(16));
}

/***/ }),

/***/ 1557:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decode = decode;
exports.encode = encode;

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function decode(data) {
  return Buffer.from(data).toString("utf8");
}
/**
 * @param {string} text
 * @returns {Uint8Array}
 */


function encode(text) {
  return Buffer.from(text, "utf8");
}

/***/ }),

/***/ 7410:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Key", ({
  enumerable: true,
  get: function () {
    return _Key.default;
  }
}));
Object.defineProperty(exports, "KeyList", ({
  enumerable: true,
  get: function () {
    return _KeyList.default;
  }
}));
Object.defineProperty(exports, "PrivateKey", ({
  enumerable: true,
  get: function () {
    return _PrivateKey.default;
  }
}));
Object.defineProperty(exports, "PublicKey", ({
  enumerable: true,
  get: function () {
    return _PublicKey.default;
  }
}));
Object.defineProperty(exports, "Mnemonic", ({
  enumerable: true,
  get: function () {
    return _Mnemonic.default;
  }
}));
Object.defineProperty(exports, "BadKeyError", ({
  enumerable: true,
  get: function () {
    return _BadKeyError.default;
  }
}));
Object.defineProperty(exports, "BadMnemonicError", ({
  enumerable: true,
  get: function () {
    return _BadMnemonicError.default;
  }
}));
Object.defineProperty(exports, "BadMnemonicReason", ({
  enumerable: true,
  get: function () {
    return _BadMnemonicReason.default;
  }
}));

var _Key = _interopRequireDefault(__nccwpck_require__(8592));

var _KeyList = _interopRequireDefault(__nccwpck_require__(2385));

var _PrivateKey = _interopRequireDefault(__nccwpck_require__(9841));

var _PublicKey = _interopRequireDefault(__nccwpck_require__(6235));

var _Mnemonic = _interopRequireDefault(__nccwpck_require__(1568));

var _BadKeyError = _interopRequireDefault(__nccwpck_require__(9413));

var _BadMnemonicError = _interopRequireDefault(__nccwpck_require__(2413));

var _BadMnemonicReason = _interopRequireDefault(__nccwpck_require__(448));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 8552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createCipheriv = createCipheriv;
exports.createDecipheriv = createDecipheriv;
exports.CipherAlgorithm = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6417));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CipherAlgorithm = {
  Aes128Ctr: "AES-128-CTR",
  Aes128Cbc: "AES-128-CBC"
};
/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */

exports.CipherAlgorithm = CipherAlgorithm;

function createCipheriv(algorithm, key, iv, data) {
  const cipher = _crypto.default.createCipheriv(algorithm, key.slice(0, 16), iv);

  return Promise.resolve(Buffer.concat([cipher.update(data), cipher["final"]()]));
}
/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */


function createDecipheriv(algorithm, key, iv, data) {
  const decipher = _crypto.default.createDecipheriv(algorithm, key.slice(0, 16), iv);

  return Promise.resolve(Buffer.concat([decipher.update(data), decipher["final"]()]));
}

/***/ }),

/***/ 5886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hash = hash;
exports.HashAlgorithm = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6417));

var utf8 = _interopRequireWildcard(__nccwpck_require__(1557));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @enum {string}
 */
const HashAlgorithm = {
  Sha256: "SHA-256",
  Sha384: "SHA-384",
  Sha512: "SHA-512"
};
/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} secretKey
 * @param {Uint8Array | string} data
 * @returns {Promise<Uint8Array>}
 */

exports.HashAlgorithm = HashAlgorithm;

function hash(algorithm, secretKey, data) {
  const key = typeof secretKey === "string" ? utf8.encode(secretKey) : secretKey;
  const value = typeof data === "string" ? utf8.encode(data) : data;

  switch (algorithm) {
    case HashAlgorithm.Sha256:
      return Promise.resolve(_crypto.default.createHmac("SHA256", key).update(value).digest());

    case HashAlgorithm.Sha384:
      return Promise.resolve(_crypto.default.createHmac("SHA384", key).update(value).digest());

    case HashAlgorithm.Sha512:
      return Promise.resolve(_crypto.default.createHmac("SHA512", key).update(value).digest());

    default:
      throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
  }
}

/***/ }),

/***/ 7749:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createKeystore = createKeystore;
exports.loadKeystore = loadKeystore;

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

var _BadKeyError = _interopRequireDefault(__nccwpck_require__(9413));

var crypto = _interopRequireWildcard(__nccwpck_require__(8552));

var hex = _interopRequireWildcard(__nccwpck_require__(7346));

var utf8 = _interopRequireWildcard(__nccwpck_require__(1557));

var hmac = _interopRequireWildcard(__nccwpck_require__(5886));

var pbkdf2 = _interopRequireWildcard(__nccwpck_require__(3223));

var random = _interopRequireWildcard(__nccwpck_require__(5935));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const HMAC_SHA256 = "hmac-sha256";
/**
 * @typedef {Object} KeystoreKdfParams
 * @property {number} dkLen
 * @property {string} salt
 * @property {number} c
 * @property {string} prf
 */

/**
 * @typedef {Object} KeystoreCipherParams
 * @property {string} iv
 */

/**
 * @typedef {Object} KeystoreCrypto
 * @property {string} ciphertext
 * @property {KeystoreCipherParams} cipherparams
 * @property {string} cipher
 * @property {string} kdf
 * @property {KeystoreKdfParams} kdfparams
 * @property {string} mac
 */

/**
 * @typedef {Object} Keystore
 * @property {number} version
 * @property {KeystoreCrypto} crypto
 */

/**
 * @param {Uint8Array} privateKey
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */

async function createKeystore(privateKey, passphrase) {
  // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25
  const dkLen = 32;
  const c = 262144;
  const saltLen = 32;
  const salt = await random.bytesAsync(saltLen);
  const key = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha256, passphrase, salt, c, dkLen);
  const iv = await random.bytesAsync(16); // AES-128-CTR with the first half of the derived key and a random IV

  const cipherText = await crypto.createCipheriv(crypto.CipherAlgorithm.Aes128Ctr, key.slice(0, 16), iv, privateKey);
  const mac = await hmac.hash(hmac.HashAlgorithm.Sha384, key.slice(16), cipherText);
  /**
   * @type {Keystore}
   */

  const keystore = {
    version: 1,
    crypto: {
      ciphertext: hex.encode(cipherText),
      cipherparams: {
        iv: hex.encode(iv)
      },
      cipher: crypto.CipherAlgorithm.Aes128Ctr,
      kdf: "pbkdf2",
      kdfparams: {
        dkLen,
        salt: hex.encode(salt),
        c,
        prf: HMAC_SHA256
      },
      mac: hex.encode(mac)
    }
  };
  return utf8.encode(JSON.stringify(keystore));
}
/**
 * @param {Uint8Array} keystoreBytes
 * @param {string} passphrase
 * @returns {Promise<nacl.SignKeyPair>}
 */


async function loadKeystore(keystoreBytes, passphrase) {
  /**
   * @type {Keystore}
   */
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  const keystore = JSON.parse(utf8.decode(keystoreBytes));

  if (keystore.version !== 1) {
    throw new _BadKeyError.default(`unsupported keystore version: ${keystore.version}`);
  }

  const {
    ciphertext,
    cipherparams: {
      iv
    },
    cipher,
    kdf,
    kdfparams: {
      dkLen,
      salt,
      c,
      prf
    },
    mac
  } = keystore.crypto;

  if (kdf !== "pbkdf2") {
    throw new _BadKeyError.default(`unsupported key derivation function:" + ${kdf}`);
  }

  if (prf !== HMAC_SHA256) {
    throw new _BadKeyError.default(`unsupported key derivation hash function: ${prf}`);
  }

  const saltBytes = hex.decode(salt);
  const ivBytes = hex.decode(iv);
  const cipherBytes = hex.decode(ciphertext);
  const key = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha256, passphrase, saltBytes, c, dkLen);
  const macHex = hex.decode(mac);
  const verifyHmac = await hmac.hash(hmac.HashAlgorithm.Sha384, key.slice(16), cipherBytes); // compare that these two Uint8Arrays are equivalent

  if (!macHex.every((b, i) => b === verifyHmac[i])) {
    throw new _BadKeyError.default("HMAC mismatch; passphrase is incorrect");
  }

  const bytes = await crypto.createDecipheriv(cipher, key.slice(0, 16), ivBytes, cipherBytes);
  return _tweetnacl.default.sign.keyPair.fromSeed(Uint8Array.from(bytes));
}

/***/ }),

/***/ 3223:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.deriveKey = deriveKey;

var _hmac = __nccwpck_require__(5886);

var utf8 = _interopRequireWildcard(__nccwpck_require__(1557));

var _util = _interopRequireDefault(__nccwpck_require__(1669));

var _crypto = _interopRequireDefault(__nccwpck_require__(6417));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} password
 * @param {Uint8Array | string} salt
 * @param {number} iterations
 * @param {number} length
 * @returns {Promise<Uint8Array>}
 */
async function deriveKey(algorithm, password, salt, iterations, length) {
  const pass = typeof password === "string" ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
  // should be fine if only valid ASCII characters are used in the password
  utf8.encode(password) : password;
  const nacl = typeof salt === "string" ? utf8.encode(salt) : salt;

  const pbkdf2 = _util.default.promisify(_crypto.default.pbkdf2);

  switch (algorithm) {
    case _hmac.HashAlgorithm.Sha256:
      return pbkdf2(pass, nacl, iterations, length, "sha256");

    case _hmac.HashAlgorithm.Sha384:
      return pbkdf2(pass, nacl, iterations, length, "sha384");

    case _hmac.HashAlgorithm.Sha512:
      return pbkdf2(pass, nacl, iterations, length, "sha512");

    default:
      throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
  }
}

/***/ }),

/***/ 3202:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EncryptedPrivateKeyInfo = exports.PrivateKeyInfo = exports.AlgorithmIdentifier = void 0;

var crypto = _interopRequireWildcard(__nccwpck_require__(8552));

var der = _interopRequireWildcard(__nccwpck_require__(87));

var pbkdf2 = _interopRequireWildcard(__nccwpck_require__(3223));

var hmac = _interopRequireWildcard(__nccwpck_require__(5886));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class AlgorithmIdentifier {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
      /**
       * @type {string}
       */
      this.algIdent = asn.seq[0].ident;
      /**
       * @type {import("../encoding/der.js").AsnType | undefined}
       */

      this.parameters = asn.seq[1];
    } else {
      throw new Error(`error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`);
    }
  }
  /**
   * @returns {string}
   */


  toString() {
    return JSON.stringify(this);
  }

}

exports.AlgorithmIdentifier = AlgorithmIdentifier;

class PBES2Params {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2) {
      /**
       * @type {AlgorithmIdentifier}
       */
      this.kdf = new AlgorithmIdentifier(asn.seq[0]);
      /**
       * @type {AlgorithmIdentifier}
       */

      this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
    } else {
      throw new Error(`error parsing PBES2Params from ${JSON.stringify(asn)}`);
    }
  }

}

class PBKDF2Params {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 2 && "bytes" in asn.seq[0] && "int" in asn.seq[1]) {
      /**
       * @type {Uint8Array}
       */
      this.salt = asn.seq[0].bytes;
      /**
       * @type {number}
       */

      this.iterCount = asn.seq[1]["int"];

      if (asn.seq.length > 2) {
        if ("seq" in asn.seq[2]) {
          this.prf = new AlgorithmIdentifier(asn.seq[2]);
          return;
        } else if ("int" in asn.seq[2]) {
          /**
           * @type {number | undefined}
           */
          this.keyLength = asn.seq[2]["int"];
        }

        if (asn.seq.length === 4) {
          /**
           * @type {AlgorithmIdentifier | undefined}
           */
          this.prf = new AlgorithmIdentifier(asn.seq[3]);
        }

        return;
      }
    }

    throw new Error(`error parsing PBKDF2Params from ${JSON.stringify(asn)}`);
  }

}

class PrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 3) {
      if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
        /**
         * @type {number}
         */
        this.version = 0;
      } else {
        throw new Error(`expected version = 0, got ${JSON.stringify(asn.seq[0])}`);
      }
      /**
       * @type {AlgorithmIdentifier}
       */


      this.algId = new AlgorithmIdentifier(asn.seq[1]);

      if ("bytes" in asn.seq[2]) {
        /**
         * @type {Uint8Array}
         */
        this.privateKey = asn.seq[2].bytes;
      } else {
        throw new Error(`expected octet string as 3rd element, got ${JSON.stringify(asn.seq[2])}`);
      }

      return;
    }

    throw new Error(`error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`);
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {PrivateKeyInfo}
   */


  static parse(encoded) {
    return new PrivateKeyInfo(der.decode(encoded));
  }

}

exports.PrivateKeyInfo = PrivateKeyInfo;

class EncryptedPrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
      /**
       * @type {AlgorithmIdentifier}
       */
      this.algId = new AlgorithmIdentifier(asn.seq[0]);
      /**
       * @type {Uint8Array}
       */

      this.data = asn.seq[1].bytes;
      return;
    }

    throw new Error(`error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`);
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {EncryptedPrivateKeyInfo}
   */


  static parse(encoded) {
    return new EncryptedPrivateKeyInfo(der.decode(encoded));
  }
  /**
   * @param {string} passphrase
   * @returns {Promise<PrivateKeyInfo>}
   */


  async decrypt(passphrase) {
    if (this.algId.algIdent !== "1.2.840.113549.1.5.13" || !this.algId.parameters) {
      // PBES2
      throw new Error(`unsupported key encryption algorithm: ${this.algId.toString()}`);
    }

    const pbes2Params = new PBES2Params(this.algId.parameters);

    if (pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" || !pbes2Params.kdf.parameters) {
      // PBKDF2
      throw new Error(`unsupported key derivation function: ${pbes2Params.kdf.toString()}`);
    }

    const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);

    if (!pbkdf2Params.prf) {
      throw new Error("unsupported PRF HMAC-SHA-1");
    } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
      // HMAC-SHA-256
      throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
    }

    if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
      // AES-128-CBC
      throw new Error(`unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`);
    }

    if (!pbes2Params.encScheme.parameters || !("bytes" in pbes2Params.encScheme.parameters)) {
      throw new Error("expected IV as bytes for AES-128-CBC, " + `got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`);
    }

    const keyLen = pbkdf2Params.keyLength || 16;
    const iv = pbes2Params.encScheme.parameters.bytes;
    const key = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha256, passphrase, pbkdf2Params.salt, pbkdf2Params.iterCount, keyLen);
    const decrypted = await crypto.createDecipheriv(crypto.CipherAlgorithm.Aes128Cbc, key, iv, this.data);
    return PrivateKeyInfo.parse(decrypted);
  }

}

exports.EncryptedPrivateKeyInfo = EncryptedPrivateKeyInfo;

/***/ }),

/***/ 5935:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bytes = bytes;
exports.bytesAsync = bytesAsync;

var _tweetnacl = _interopRequireDefault(__nccwpck_require__(6703));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {number} count
 * @returns {Uint8Array}
 */
function bytes(count) {
  return _tweetnacl.default.randomBytes(count);
}
/**
 * @param {number} count
 * @returns {Promise<Uint8Array>}
 */


function bytesAsync(count) {
  return Promise.resolve(_tweetnacl.default.randomBytes(count));
}

/***/ }),

/***/ 213:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.digest = digest;

var _crypto = _interopRequireDefault(__nccwpck_require__(6417));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
// eslint-disable-next-line @typescript-eslint/require-await
async function digest(data) {
  // fallback to trying node-crypto which could be polyfilled by the browser environment
  return _crypto.default.createHash("sha256").update(data).digest();
}

/***/ }),

/***/ 6520:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.derive = derive;

var hmac = _interopRequireWildcard(__nccwpck_require__(5886));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
async function derive(parentKey, chainCode, index) {
  const input = new Uint8Array(37); // 0x00 + parentKey + index(BE)

  input[0] = 0;
  input.set(parentKey, 1);
  new DataView(input.buffer).setUint32(33, index, false); // set the index to hardened

  input[33] |= 128;
  const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, input);
  return {
    keyData: digest.subarray(0, 32),
    chainCode: digest.subarray(32)
  };
}

/***/ }),

/***/ 4454:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayEqual = arrayEqual;
exports.arrayStartsWith = arrayStartsWith;

/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }

  if (array1.byteLength !== array2.byteLength) {
    return false;
  }

  const view1 = new DataView(array1.buffer);
  const view2 = new DataView(array2.buffer);
  let i = array1.byteLength;

  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Uint8Array} array
 * @param {Uint8Array} arrayPrefix
 * @returns {boolean}
 */


function arrayStartsWith(array, arrayPrefix) {
  if (array.byteLength < arrayPrefix.byteLength) {
    return false;
  }

  let i = arrayPrefix.byteLength;

  while (i--) {
    if (array[i] !== arrayPrefix[i]) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ 9833:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.legacy = legacy;

var pbkdf2 = _interopRequireWildcard(__nccwpck_require__(3223));

var hmac = _interopRequireWildcard(__nccwpck_require__(5886));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @param {Uint8Array} seed
 * @param {number} index
 * @returns {Promise<Uint8Array>}
 */
function legacy(seed, index) {
  const password = new Uint8Array(seed.length + 8);
  password.set(seed, 0);
  const view = new DataView(password.buffer, password.byteOffset + seed.length, 8);
  view.setInt32(0, index);
  view.setInt32(4, index);
  const salt = Uint8Array.from([0xff]);
  return pbkdf2.deriveKey(hmac.HashAlgorithm.Sha512, password, salt, 2048, 32);
}

/***/ }),

/***/ 2771:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.legacy1 = legacy1;
exports.legacy2 = legacy2;
exports.crc8 = crc8;
exports.convertRadix = convertRadix;
exports.bytesToBits = bytesToBits;

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

var sha256 = _interopRequireWildcard(__nccwpck_require__(213));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {[Uint8Array, number]}
 */
function legacy1(words, wordlist) {
  const indicies = words.map(word => wordlist.indexOf(word.toLowerCase()));
  const data = convertRadix(indicies, wordlist.length, 256, 33);
  const checksum = data[data.length - 1];
  const result = new Uint8Array(data.length - 1);

  for (let i = 0; i < data.length - 1; i += 1) {
    result[i] = data[i] ^ checksum;
  }

  return [result, checksum];
}
/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {Promise<Uint8Array>}
 */


async function legacy2(words, wordlist) {
  const concatBitsLen = words.length * 11;
  /** @type {boolean[]} */

  const concatBits = [];
  concatBits.fill(false, 0, concatBitsLen);

  for (const [wordIndex, word] of words.entries()) {
    const index = wordlist.indexOf(word.toLowerCase());

    if (index < 0) {
      throw new Error(`Word not found in wordlist: ${word}`);
    }

    for (let i = 0; i < 11; i += 1) {
      concatBits[wordIndex * 11 + i] = (index & 1 << 10 - i) !== 0;
    }
  }

  const checksumBitsLen = concatBitsLen / 33;
  const entropyBitsLen = concatBitsLen - checksumBitsLen;
  const entropy = new Uint8Array(entropyBitsLen / 8);

  for (let i = 0; i < entropy.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      if (concatBits[i * 8 + j]) {
        entropy[i] |= 1 << 7 - j;
      }
    }
  } // Checksum validation


  const hash = await sha256.digest(entropy);
  const hashBits = bytesToBits(hash);

  for (let i = 0; i < checksumBitsLen; i += 1) {
    if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
      throw new Error("Checksum mismatch");
    }
  }

  return entropy;
}
/**
 * @param {Uint8Array} data
 * @returns {number}
 */


function crc8(data) {
  let crc = 0xff;

  for (let i = 0; i < data.length - 1; i += 1) {
    crc ^= data[i];

    for (let j = 0; j < 8; j += 1) {
      crc = crc >>> 1 ^ ((crc & 1) === 0 ? 0 : 0xb2);
    }
  }

  return crc ^ 0xff;
}
/**
 * @param {number[]} nums
 * @param {number} fromRadix
 * @param {number} toRadix
 * @param {number} toLength
 * @returns {Uint8Array}
 */


function convertRadix(nums, fromRadix, toRadix, toLength) {
  let num = new _bignumber.default(0);

  for (const element of nums) {
    num = num.times(fromRadix);
    num = num.plus(element);
  }

  const result = new Uint8Array(toLength);

  for (let i = toLength - 1; i >= 0; i -= 1) {
    const tem = num.dividedToIntegerBy(toRadix);
    const rem = num.modulo(toRadix);
    num = tem;
    result[i] = rem.toNumber();
  }

  return result;
}
/**
 * @param {Uint8Array} data
 * @returns {boolean[]}
 */


function bytesToBits(data) {
  /** @type {boolean[]} */
  const bits = [];
  bits.fill(false, 0, data.length * 8);

  for (let i = 0; i < data.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      bits[i * 8 + j] = (data[i] & 1 << 7 - j) !== 0;
    }
  }

  return bits;
}

/***/ }),

/***/ 1090:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
var _default = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
exports.default = _default;

/***/ }),

/***/ 2675:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
var _default = ["aback", "abbey", "abbot", "abide", "ablaze", "able", "aboard", "abode", "abort", "abound", "about", "above", "abroad", "abrupt", "absent", "absorb", "absurd", "abuse", "accent", "accept", "access", "accord", "accuse", "ace", "ache", "aching", "acid", "acidic", "acorn", "acre", "across", "act", "action", "active", "actor", "actual", "acute", "adam", "adapt", "add", "added", "addict", "adept", "adhere", "adjust", "admire", "admit", "adobe", "adopt", "adrift", "adult", "adverb", "advice", "aerial", "afar", "affair", "affect", "afford", "afghan", "afield", "afloat", "afraid", "afresh", "after", "again", "age", "agency", "agenda", "agent", "aghast", "agile", "ago", "agony", "agree", "agreed", "ahead", "aid", "aide", "aim", "air", "airman", "airy", "akin", "alarm", "alaska", "albeit", "album", "ale", "alert", "alibi", "alice", "alien", "alight", "align", "alike", "alive", "alkali", "all", "alley", "allied", "allow", "alloy", "ally", "almond", "almost", "aloft", "alone", "along", "aloof", "aloud", "alpha", "alpine", "also", "altar", "alter", "always", "amaze", "amazon", "amber", "ambush", "amen", "amend", "amid", "amidst", "amiss", "among", "amount", "ample", "amuse", "anchor", "and", "andrew", "anew", "angel", "anger", "angle", "angry", "animal", "ankle", "annoy", "annual", "answer", "anthem", "any", "anyhow", "anyway", "apart", "apathy", "apex", "apiece", "appeal", "appear", "apple", "apply", "april", "apron", "arab", "arcade", "arcane", "arch", "arctic", "ardent", "are", "area", "argue", "arid", "arise", "ark", "arm", "armful", "army", "aroma", "around", "arouse", "array", "arrest", "arrive", "arrow", "arson", "art", "artery", "artful", "artist", "ascent", "ash", "ashen", "ashore", "aside", "ask", "asleep", "aspect", "assay", "assent", "assert", "assess", "asset", "assign", "assist", "assume", "assure", "asthma", "astute", "asylum", "ate", "athens", "atlas", "atom", "atomic", "attach", "attack", "attain", "attend", "attic", "auburn", "audio", "audit", "august", "aunt", "auntie", "aura", "austin", "author", "auto", "autumn", "avail", "avenge", "avenue", "avert", "avid", "avoid", "await", "awake", "awaken", "award", "aware", "awash", "away", "awful", "awhile", "axe", "axes", "axiom", "axis", "axle", "aye", "babe", "baby", "bach", "back", "backup", "bacon", "bad", "badge", "badly", "bag", "baggy", "bail", "bait", "bake", "baker", "bakery", "bald", "ball", "ballad", "ballet", "ballot", "baltic", "bamboo", "ban", "banal", "banana", "band", "bang", "bank", "bar", "barber", "bare", "barely", "barge", "bark", "barley", "barn", "baron", "barrel", "barren", "basalt", "base", "basic", "basil", "basin", "basis", "basket", "bass", "bat", "batch", "bath", "baton", "battle", "bay", "beach", "beacon", "beak", "beam", "bean", "bear", "beard", "beast", "beat", "beauty", "become", "bed", "beech", "beef", "beefy", "beep", "beer", "beet", "beetle", "before", "beg", "beggar", "begin", "behalf", "behave", "behind", "beige", "being", "belief", "bell", "belly", "belong", "below", "belt", "bench", "bend", "benign", "bent", "berlin", "berry", "berth", "beset", "beside", "best", "bestow", "bet", "beta", "betray", "better", "beware", "beyond", "bias", "biceps", "bicker", "bid", "big", "bigger", "bike", "bile", "bill", "bin", "binary", "bind", "biopsy", "birch", "bird", "birdie", "birth", "bishop", "bit", "bitch", "bite", "bitter", "black", "blade", "blame", "bland", "blast", "blaze", "bleak", "blend", "bless", "blew", "blind", "blink", "blip", "bliss", "blitz", "block", "blond", "blood", "bloody", "bloom", "blot", "blouse", "blow", "blue", "bluff", "blunt", "blur", "blush", "boar", "board", "boast", "boat", "bob", "bodily", "body", "bogus", "boil", "bold", "bolt", "bomb", "bombay", "bond", "bone", "bonn", "bonnet", "bonus", "bony", "book", "boom", "boost", "boot", "booth", "booze", "border", "bore", "borrow", "bosom", "boss", "boston", "both", "bother", "bottle", "bottom", "bought", "bounce", "bound", "bounty", "bout", "bovine", "bow", "bowel", "bowl", "box", "boy", "boyish", "brace", "brain", "brainy", "brake", "bran", "branch", "brand", "brandy", "brass", "brave", "bravo", "brazil", "breach", "bread", "break", "breast", "breath", "bred", "breed", "breeze", "brew", "bribe", "brick", "bride", "bridge", "brief", "bright", "brim", "brine", "bring", "brink", "brisk", "broad", "broke", "broken", "bronze", "brook", "broom", "brown", "bruise", "brush", "brutal", "brute", "bubble", "buck", "bucket", "buckle", "budget", "buffet", "buggy", "build", "bulb", "bulge", "bulk", "bulky", "bull", "bullet", "bully", "bump", "bumpy", "bunch", "bundle", "bunk", "bunny", "burden", "bureau", "burial", "buried", "burly", "burn", "burnt", "burrow", "burst", "bury", "bus", "bush", "bust", "bustle", "busy", "but", "butler", "butt", "butter", "button", "buy", "buyer", "buzz", "bye", "byte", "cab", "cabin", "cable", "cache", "cactus", "caesar", "cage", "cairo", "cajun", "cajole", "cake", "calf", "call", "caller", "calm", "calmly", "came", "camel", "camera", "camp", "campus", "can", "canada", "canal", "canary", "cancel", "cancer", "candid", "candle", "candy", "cane", "canine", "canoe", "canopy", "canvas", "canyon", "cap", "cape", "car", "carbon", "card", "care", "career", "caress", "cargo", "carl", "carnal", "carol", "carp", "carpet", "carrot", "carry", "cart", "cartel", "case", "cash", "cask", "cast", "castle", "casual", "cat", "catch", "cater", "cattle", "caught", "causal", "cause", "cave", "cease", "celery", "cell", "cellar", "celtic", "cement", "censor", "census", "cent", "cereal", "chain", "chair", "chalk", "chalky", "champ", "chance", "change", "chant", "chaos", "chap", "chapel", "charge", "charm", "chart", "chase", "chat", "cheap", "cheat", "check", "cheek", "cheeky", "cheer", "cheery", "cheese", "chef", "cheque", "cherry", "chess", "chest", "chew", "chic", "chick", "chief", "child", "chile", "chill", "chilly", "chin", "china", "chip", "choice", "choir", "choose", "chop", "choppy", "chord", "chorus", "chose", "chosen", "chris", "chrome", "chunk", "chunky", "church", "cider", "cigar", "cinema", "circa", "circle", "circus", "cite", "city", "civic", "civil", "clad", "claim", "clammy", "clan", "clap", "clash", "clasp", "class", "clause", "claw", "clay", "clean", "clear", "clergy", "clerk", "clever", "click", "client", "cliff", "climax", "climb", "clinch", "cling", "clinic", "clip", "cloak", "clock", "clone", "close", "closer", "closet", "cloth", "cloud", "cloudy", "clout", "clown", "club", "clue", "clumsy", "clung", "clutch", "coach", "coal", "coarse", "coast", "coat", "coax", "cobalt", "cobra", "coca", "cock", "cocoa", "code", "coffee", "coffin", "cohort", "coil", "coin", "coke", "cold", "collar", "colon", "colony", "colt", "column", "comb", "combat", "come", "comedy", "comic", "commit", "common", "compel", "comply", "concur", "cone", "confer", "congo", "consul", "convex", "convey", "convoy", "cook", "cool", "cope", "copper", "copy", "coral", "cord", "core", "cork", "corn", "corner", "corps", "corpse", "corpus", "cortex", "cosmic", "cosmos", "cost", "costly", "cotton", "couch", "cough", "could", "count", "county", "coup", "couple", "coupon", "course", "court", "cousin", "cove", "cover", "covert", "cow", "coward", "cowboy", "cozy", "crab", "crack", "cradle", "craft", "crafty", "crag", "crane", "crash", "crate", "crater", "crawl", "crazy", "creak", "cream", "creamy", "create", "credit", "creed", "creek", "creep", "creepy", "crept", "crest", "crew", "cried", "crime", "crisis", "crisp", "critic", "crook", "crop", "cross", "crow", "crowd", "crown", "crude", "cruel", "cruise", "crunch", "crush", "crust", "crux", "cry", "crypt", "cuba", "cube", "cubic", "cuckoo", "cuff", "cult", "cup", "curb", "cure", "curfew", "curl", "curry", "curse", "cursor", "curve", "cuss", "custom", "cut", "cute", "cycle", "cyclic", "cynic", "czech", "dad", "daddy", "dagger", "daily", "dairy", "daisy", "dale", "dam", "damage", "damp", "dampen", "dance", "danger", "danish", "dare", "dark", "darken", "darn", "dart", "dash", "data", "date", "david", "dawn", "day", "dead", "deadly", "deaf", "deal", "dealer", "dean", "dear", "death", "debate", "debit", "debris", "debt", "debtor", "decade", "decay", "decent", "decide", "deck", "decor", "decree", "deduce", "deed", "deep", "deeply", "deer", "defeat", "defect", "defend", "defer", "define", "defy", "degree", "deity", "delay", "delete", "delhi", "delta", "demand", "demise", "demo", "demure", "denial", "denote", "dense", "dental", "deny", "depart", "depend", "depict", "deploy", "depot", "depth", "deputy", "derive", "desert", "design", "desire", "desist", "desk", "detail", "detect", "deter", "detest", "detour", "device", "devise", "devoid", "devote", "devour", "dial", "diana", "diary", "dice", "dictum", "did", "die", "diesel", "diet", "differ", "dig", "digest", "digit", "dine", "dinghy", "dinner", "diode", "dip", "dire", "direct", "dirt", "dirty", "disc", "disco", "dish", "disk", "dismal", "dispel", "ditch", "dive", "divert", "divide", "divine", "dizzy", "docile", "dock", "doctor", "dog", "dogma", "dole", "doll", "dollar", "dolly", "domain", "dome", "domino", "donate", "done", "donkey", "donor", "doom", "door", "dorsal", "dose", "dot", "double", "doubt", "dough", "dour", "dove", "down", "dozen", "draft", "drag", "dragon", "drain", "drama", "drank", "draw", "drawer", "dread", "dream", "dreary", "dress", "drew", "dried", "drift", "drill", "drink", "drip", "drive", "driver", "drop", "drove", "drown", "drug", "drum", "drunk", "dry", "dual", "duck", "duct", "due", "duel", "duet", "duke", "dull", "duly", "dumb", "dummy", "dump", "dune", "dung", "duress", "during", "dusk", "dust", "dusty", "dutch", "duty", "dwarf", "dwell", "dyer", "dying", "dynamo", "each", "eager", "eagle", "ear", "earl", "early", "earn", "earth", "ease", "easel", "easily", "east", "easter", "easy", "eat", "eaten", "eater", "echo", "eddy", "eden", "edge", "edible", "edict", "edit", "editor", "eel", "eerie", "eerily", "effect", "effort", "egg", "ego", "eight", "eighth", "eighty", "either", "elbow", "elder", "eldest", "elect", "eleven", "elicit", "elite", "else", "elude", "elves", "embark", "emblem", "embryo", "emerge", "emit", "empire", "employ", "empty", "enable", "enamel", "end", "endure", "enemy", "energy", "engage", "engine", "enjoy", "enlist", "enough", "ensure", "entail", "enter", "entire", "entry", "envoy", "envy", "enzyme", "epic", "epoch", "equal", "equate", "equip", "equity", "era", "erect", "eric", "erode", "erotic", "errant", "error", "escape", "escort", "essay", "essex", "estate", "esteem", "ethic", "ethnic", "europe", "evade", "eve", "even", "event", "ever", "every", "evict", "evil", "evoke", "evolve", "exact", "exam", "exceed", "excel", "except", "excess", "excise", "excite", "excuse", "exempt", "exert", "exile", "exist", "exit", "exodus", "exotic", "expand", "expect", "expert", "expire", "export", "expose", "extend", "extra", "eye", "eyed", "fabric", "face", "facial", "fact", "factor", "fade", "fail", "faint", "fair", "fairly", "fairy", "faith", "fake", "falcon", "fall", "false", "falter", "fame", "family", "famine", "famous", "fan", "fancy", "far", "farce", "fare", "farm", "farmer", "fast", "fasten", "faster", "fat", "fatal", "fate", "father", "fatty", "fault", "faulty", "fauna", "fear", "feast", "feat", "fed", "fee", "feeble", "feed", "feel", "feet", "fell", "fellow", "felt", "female", "fence", "fend", "ferry", "fetal", "fetch", "feudal", "fever", "few", "fewer", "fiasco", "fiddle", "field", "fiend", "fierce", "fiery", "fifth", "fifty", "fig", "fight", "figure", "file", "fill", "filled", "filler", "film", "filter", "filth", "filthy", "final", "finale", "find", "fine", "finery", "finger", "finish", "finite", "fire", "firm", "firmly", "first", "fiscal", "fish", "fisher", "fist", "fit", "fitful", "five", "fix", "flag", "flair", "flak", "flame", "flank", "flap", "flare", "flash", "flask", "flat", "flavor", "flaw", "fled", "flee", "fleece", "fleet", "flesh", "fleshy", "flew", "flick", "flight", "flimsy", "flint", "flirt", "float", "flock", "flood", "floor", "floppy", "flora", "floral", "flour", "flow", "flower", "fluent", "fluffy", "fluid", "flung", "flurry", "flush", "flute", "flux", "fly", "flyer", "foal", "foam", "focal", "focus", "fog", "foil", "fold", "folk", "follow", "folly", "fond", "fondly", "font", "food", "fool", "foot", "for", "forbid", "force", "ford", "forest", "forge", "forget", "fork", "form", "formal", "format", "former", "fort", "forth", "forty", "forum", "fossil", "foster", "foul", "found", "four", "fourth", "fox", "foyer", "frail", "frame", "franc", "france", "frank", "fraud", "fred", "free", "freed", "freely", "freeze", "french", "frenzy", "fresh", "friar", "friday", "fridge", "fried", "friend", "fright", "fringe", "frock", "frog", "from", "front", "frost", "frosty", "frown", "frozen", "frugal", "fruit", "fry", "fudge", "fuel", "full", "fully", "fumes", "fun", "fund", "funny", "fur", "furry", "fury", "fuse", "fusion", "fuss", "fussy", "futile", "future", "fuzzy", "gadget", "gain", "gala", "galaxy", "gale", "gall", "galley", "gallon", "gallop", "gamble", "game", "gamma", "gandhi", "gang", "gap", "garage", "garden", "garlic", "gas", "gasp", "gate", "gather", "gauge", "gaunt", "gave", "gaze", "gear", "geese", "gem", "gemini", "gender", "gene", "geneva", "genial", "genius", "genre", "gentle", "gently", "gentry", "genus", "george", "germ", "get", "ghetto", "ghost", "giant", "gift", "giggle", "gill", "gilt", "ginger", "girl", "give", "given", "glad", "glade", "glance", "gland", "glare", "glass", "glassy", "gleam", "glee", "glide", "global", "globe", "gloom", "gloomy", "gloria", "glory", "gloss", "glossy", "glove", "glow", "glue", "gnat", "gnu", "goal", "goat", "gold", "golden", "golf", "gone", "gong", "goo", "good", "goose", "gore", "gorge", "gory", "gosh", "gospel", "gossip", "got", "gothic", "govern", "gown", "grab", "grace", "grade", "grail", "grain", "grand", "grant", "grape", "graph", "grasp", "grass", "grassy", "grate", "grave", "gravel", "gravy", "grease", "greasy", "great", "greece", "greed", "greedy", "greek", "green", "greet", "grew", "grey", "grid", "grief", "grill", "grim", "grin", "grind", "grip", "grit", "gritty", "groan", "groin", "groom", "groove", "gross", "ground", "group", "grove", "grow", "grown", "growth", "grudge", "grunt", "guard", "guess", "guest", "guide", "guild", "guilt", "guilty", "guise", "guitar", "gulf", "gully", "gun", "gunman", "guru", "gut", "guy", "gypsy", "habit", "hack", "had", "hail", "hair", "hairy", "haiti", "hale", "half", "hall", "halt", "hamlet", "hammer", "hand", "handle", "handy", "hang", "hangar", "hanoi", "happen", "happy", "harass", "harbor", "hard", "harder", "hardly", "hare", "harem", "harm", "harp", "harry", "harsh", "has", "hash", "hassle", "haste", "hasten", "hasty", "hat", "hatch", "hate", "haul", "haunt", "havana", "have", "haven", "havoc", "hawaii", "hawk", "hay", "hazard", "haze", "hazel", "hazy", "head", "heal", "health", "heap", "hear", "heard", "heart", "hearth", "hearty", "heat", "heater", "heaven", "heavy", "hebrew", "heck", "hectic", "hedge", "heel", "hefty", "height", "heir", "held", "helium", "helix", "hell", "hello", "helm", "helmet", "help", "hemp", "hence", "henry", "her", "herald", "herb", "herd", "here", "hereby", "hermes", "hernia", "hero", "heroic", "heroin", "hey", "heyday", "hick", "hidden", "hide", "high", "higher", "highly", "hill", "him", "hind", "hinder", "hint", "hippie", "hire", "his", "hiss", "hit", "hive", "hoard", "hoarse", "hobby", "hockey", "hold", "holder", "hole", "hollow", "holly", "holy", "home", "honest", "honey", "hood", "hook", "hope", "horn", "horrid", "horror", "horse", "hose", "host", "hot", "hotel", "hound", "hour", "house", "hover", "how", "huge", "hull", "human", "humane", "humble", "humid", "hung", "hunger", "hungry", "hunt", "hurdle", "hurl", "hurry", "hurt", "hush", "hut", "hybrid", "hymn", "hyphen", "ice", "icing", "icon", "idaho", "idea", "ideal", "idiom", "idiot", "idle", "idly", "idol", "ignite", "ignore", "ill", "image", "immune", "impact", "imply", "import", "impose", "inca", "incest", "inch", "income", "incur", "indeed", "index", "india", "indian", "indoor", "induce", "inept", "inert", "infant", "infect", "infer", "influx", "inform", "inject", "injure", "injury", "ink", "inlaid", "inland", "inlet", "inmate", "inn", "innate", "inner", "input", "insane", "insect", "insert", "inset", "inside", "insist", "insult", "insure", "intact", "intake", "intend", "inter", "into", "invade", "invent", "invest", "invite", "invoke", "inward", "iowa", "iran", "iraq", "irish", "iron", "ironic", "irony", "isaac", "isabel", "island", "isle", "israel", "issue", "italy", "itch", "item", "itself", "ivan", "ivory", "jack", "jacket", "jacob", "jade", "jaguar", "jail", "james", "jane", "japan", "jargon", "java", "jaw", "jazz", "jeep", "jelly", "jerky", "jest", "jet", "jewel", "jewish", "jim", "job", "jock", "jockey", "joe", "john", "join", "joint", "joke", "jolly", "jolt", "jordan", "joseph", "joy", "joyful", "joyous", "judge", "judy", "juice", "juicy", "july", "jumble", "jumbo", "jump", "june", "jungle", "junior", "junk", "junta", "jury", "just", "kansas", "karate", "karl", "keel", "keen", "keep", "keeper", "kenya", "kept", "kernel", "kettle", "key", "khaki", "kick", "kid", "kidnap", "kidney", "kill", "killer", "kin", "kind", "kindly", "king", "kiss", "kite", "kitten", "knack", "knee", "kneel", "knew", "knife", "knight", "knit", "knob", "knock", "knot", "know", "known", "koran", "korea", "kuwait", "label", "lace", "lack", "lad", "ladder", "laden", "lady", "lagoon", "laity", "lake", "lamb", "lame", "lamp", "lance", "land", "lane", "lap", "lapse", "large", "larval", "laser", "last", "latch", "late", "lately", "latent", "later", "latest", "latin", "latter", "laugh", "launch", "lava", "lavish", "law", "lawful", "lawn", "lawyer", "lay", "layer", "layman", "lazy", "lead", "leader", "leaf", "leafy", "league", "leak", "leaky", "lean", "leap", "learn", "lease", "leash", "least", "leave", "led", "ledge", "left", "leg", "legacy", "legal", "legend", "legion", "lemon", "lend", "length", "lens", "lent", "leo", "leper", "lesion", "less", "lessen", "lesser", "lesson", "lest", "let", "lethal", "letter", "level", "lever", "levy", "lewis", "liable", "liar", "libel", "libya", "lice", "lick", "lid", "lie", "lied", "lier", "life", "lift", "light", "like", "likely", "limb", "lime", "limit", "limp", "line", "linear", "linen", "linger", "link", "lint", "lion", "lip", "liquid", "liquor", "list", "listen", "lit", "live", "lively", "liver", "liz", "lizard", "load", "loaf", "loan", "lobby", "lobe", "local", "locate", "lock", "locus", "lodge", "loft", "lofty", "log", "logic", "logo", "london", "lone", "lonely", "long", "longer", "look", "loop", "loose", "loosen", "loot", "lord", "lorry", "lose", "loss", "lost", "lot", "lotion", "lotus", "loud", "loudly", "lounge", "lousy", "love", "lovely", "lover", "low", "lower", "lowest", "loyal", "lucid", "luck", "lucky", "lucy", "lull", "lump", "lumpy", "lunacy", "lunar", "lunch", "lung", "lure", "lurid", "lush", "lust", "lute", "luther", "luxury", "lying", "lymph", "lynch", "lyric", "macho", "macro", "mad", "madam", "made", "mafia", "magic", "magma", "magnet", "magnum", "magpie", "maid", "maiden", "mail", "main", "mainly", "major", "make", "maker", "male", "malice", "mall", "malt", "mammal", "manage", "mane", "mania", "manic", "manner", "manor", "mantle", "manual", "manure", "many", "map", "maple", "marble", "march", "mare", "margin", "maria", "marina", "mark", "market", "marry", "mars", "marsh", "martin", "martyr", "mary", "mask", "mason", "mass", "mast", "master", "mat", "match", "mate", "matrix", "matter", "mature", "maxim", "may", "maybe", "mayor", "maze", "mead", "meadow", "meal", "mean", "meant", "meat", "medal", "media", "median", "medic", "medium", "meet", "mellow", "melody", "melon", "melt", "member", "memo", "memory", "menace", "mend", "mental", "mentor", "menu", "mercy", "mere", "merely", "merge", "merger", "merit", "merry", "mesh", "mess", "messy", "met", "metal", "meter", "method", "methyl", "metric", "metro", "mexico", "miami", "mickey", "mid", "midday", "middle", "midst", "midway", "might", "mighty", "mild", "mildew", "mile", "milk", "milky", "mill", "mimic", "mince", "mind", "mine", "mini", "mink", "minor", "mint", "minus", "minute", "mire", "mirror", "mirth", "misery", "miss", "mist", "misty", "mite", "mix", "moan", "moat", "mob", "mobile", "mock", "mode", "model", "modem", "modern", "modest", "modify", "module", "moist", "molar", "mold", "mole", "molten", "moment", "monday", "money", "monk", "monkey", "month", "mood", "moody", "moon", "moor", "moral", "morale", "morbid", "more", "morgue", "mortal", "mortar", "mosaic", "moscow", "moses", "mosque", "moss", "most", "mostly", "moth", "mother", "motion", "motive", "motor", "mount", "mourn", "mouse", "mouth", "move", "movie", "mrs", "much", "muck", "mucus", "mud", "muddle", "muddy", "mule", "mummy", "munich", "murder", "murky", "murmur", "muscle", "museum", "music", "mussel", "must", "mutant", "mute", "mutiny", "mutter", "mutton", "mutual", "muzzle", "myopic", "myriad", "myself", "mystic", "myth", "nadir", "nail", "naked", "name", "namely", "nape", "napkin", "naples", "narrow", "nasal", "nasty", "nathan", "nation", "native", "nature", "nausea", "naval", "nave", "navy", "near", "nearer", "nearly", "neat", "neatly", "neck", "need", "needle", "needy", "negate", "neon", "nepal", "nephew", "nerve", "nest", "net", "neural", "never", "newly", "next", "nice", "nicely", "niche", "nickel", "niece", "night", "nile", "nimble", "nine", "ninety", "ninth", "nobel", "noble", "nobody", "node", "noise", "noisy", "none", "noon", "nor", "norm", "normal", "north", "norway", "nose", "nosy", "not", "note", "notice", "notify", "notion", "noun", "novel", "novice", "now", "nozzle", "null", "numb", "number", "nurse", "nut", "nylon", "nymph", "oak", "oar", "oasis", "oath", "obese", "obey", "object", "oblige", "oboe", "obtain", "obtuse", "occult", "occupy", "occur", "ocean", "octave", "odd", "off", "offend", "offer", "office", "offset", "often", "ohio", "oil", "oily", "okay", "old", "older", "oldest", "olive", "omega", "omen", "omit", "once", "one", "onion", "only", "onset", "onto", "onus", "onward", "opaque", "open", "openly", "opera", "opium", "oppose", "optic", "option", "oracle", "oral", "orange", "orbit", "orchid", "ordeal", "order", "organ", "orgasm", "orient", "origin", "ornate", "orphan", "oscar", "other", "otter", "ought", "ounce", "our", "out", "outer", "output", "outset", "oval", "oven", "over", "overt", "owe", "owing", "owl", "own", "owner", "oxford", "oxide", "oxygen", "oyster", "ozone", "pace", "pack", "packet", "pact", "pad", "paddle", "paddy", "pagan", "page", "paid", "pain", "paint", "pair", "palace", "pale", "palm", "pan", "panama", "panel", "panic", "papa", "papal", "paper", "parade", "parcel", "pardon", "parent", "paris", "parish", "park", "parody", "parrot", "part", "partly", "party", "pascal", "pass", "past", "paste", "pastel", "pastor", "pastry", "pat", "patch", "patent", "path", "patio", "patrol", "patron", "paul", "pause", "pave", "paw", "pawn", "pay", "peace", "peach", "peak", "pear", "pearl", "pedal", "peel", "peer", "peking", "pelvic", "pelvis", "pen", "penal", "pence", "pencil", "penny", "people", "pepper", "per", "perch", "peril", "period", "perish", "permit", "person", "peru", "pest", "pet", "peter", "petite", "petrol", "petty", "phase", "philip", "phone", "photo", "phrase", "piano", "pick", "picket", "picnic", "pie", "piece", "pier", "pierce", "piety", "pig", "pigeon", "piggy", "pike", "pile", "pill", "pillar", "pillow", "pilot", "pin", "pinch", "pine", "pink", "pint", "pious", "pipe", "pirate", "piss", "pistol", "piston", "pit", "pitch", "pity", "pivot", "pixel", "pizza", "place", "placid", "plague", "plain", "plan", "plane", "planet", "plank", "plant", "plasma", "plate", "play", "player", "plea", "plead", "please", "pledge", "plenty", "plight", "plot", "plough", "ploy", "plug", "plum", "plump", "plunge", "plural", "plus", "plush", "pocket", "poem", "poet", "poetic", "poetry", "point", "poison", "poland", "polar", "pole", "police", "policy", "polish", "polite", "poll", "pollen", "polo", "pond", "ponder", "pony", "pool", "poor", "poorly", "pop", "poppy", "pore", "pork", "port", "portal", "pose", "posh", "post", "postal", "pot", "potato", "potent", "pouch", "pound", "pour", "powder", "power", "praise", "pray", "prayer", "preach", "prefer", "prefix", "press", "pretty", "price", "pride", "priest", "primal", "prime", "prince", "print", "prior", "prism", "prison", "privy", "prize", "probe", "profit", "prompt", "prone", "proof", "propel", "proper", "prose", "proton", "proud", "prove", "proven", "proxy", "prune", "pry", "psalm", "pseudo", "psyche", "pub", "public", "puff", "pull", "pulp", "pulpit", "pulsar", "pulse", "pump", "punch", "punish", "punk", "pupil", "puppet", "puppy", "pure", "purely", "purge", "purify", "purple", "purse", "pursue", "push", "pushy", "put", "putt", "puzzle", "quaint", "quake", "quarry", "quart", "quartz", "quebec", "queen", "queer", "query", "quest", "queue", "quick", "quid", "quiet", "quilt", "quirk", "quit", "quite", "quiver", "quiz", "quota", "quote", "rabbit", "race", "racial", "racism", "rack", "racket", "radar", "radio", "radish", "radius", "raffle", "raft", "rage", "raid", "rail", "rain", "rainy", "raise", "rake", "rally", "ramp", "random", "range", "rank", "ransom", "rape", "rapid", "rare", "rarely", "rarity", "rash", "rat", "rate", "rather", "ratify", "ratio", "rattle", "rave", "raven", "raw", "ray", "razor", "reach", "react", "read", "reader", "ready", "real", "really", "realm", "reap", "rear", "reason", "rebel", "recall", "recent", "recess", "recipe", "reckon", "record", "recoup", "rector", "red", "redeem", "redo", "reduce", "reed", "reef", "reek", "refer", "reform", "refuge", "refuse", "regal", "regard", "regent", "regime", "region", "regret", "reign", "reject", "relate", "relax", "relay", "relic", "relief", "relish", "rely", "remain", "remark", "remedy", "remind", "remit", "remote", "remove", "renal", "render", "rent", "rental", "repair", "repeal", "repeat", "repent", "reply", "report", "rescue", "resent", "reside", "resign", "resin", "resist", "resort", "rest", "result", "resume", "retail", "retain", "retina", "retire", "return", "reveal", "review", "revise", "revive", "revolt", "reward", "rex", "rhine", "rhino", "rhyme", "rhythm", "ribbon", "rice", "rich", "rick", "rid", "ride", "rider", "ridge", "rife", "rifle", "rift", "right", "rigid", "rile", "rim", "ring", "rinse", "riot", "ripe", "ripen", "ripple", "rise", "risk", "risky", "rite", "ritual", "ritz", "rival", "river", "road", "roar", "roast", "rob", "robe", "robert", "robin", "robot", "robust", "rock", "rocket", "rocky", "rod", "rode", "rodent", "rogue", "role", "roll", "roman", "rome", "roof", "room", "root", "rope", "rose", "rosy", "rot", "rotate", "rotor", "rotten", "rouge", "rough", "round", "route", "rover", "row", "royal", "rub", "rubber", "rubble", "ruby", "rudder", "rude", "rug", "rugby", "ruin", "rule", "ruler", "rumble", "rump", "run", "rune", "rung", "runway", "rural", "rush", "russia", "rust", "rustic", "rusty", "sack", "sacred", "sad", "saddle", "sadism", "sadly", "safari", "safe", "safely", "safer", "safety", "saga", "sage", "sahara", "said", "sail", "sailor", "saint", "sake", "salad", "salary", "sale", "saline", "saliva", "salmon", "saloon", "salt", "salty", "salute", "sam", "same", "sample", "sand", "sandy", "sane", "sash", "satin", "satire", "saturn", "sauce", "saucer", "saudi", "sauna", "savage", "save", "saw", "say", "scale", "scalp", "scan", "scant", "scar", "scarce", "scare", "scarf", "scary", "scene", "scenic", "scent", "school", "scold", "scope", "score", "scorn", "scotch", "scott", "scout", "scrap", "scrape", "scream", "screen", "screw", "script", "scroll", "scrub", "scum", "sea", "seal", "seam", "seaman", "search", "season", "seat", "second", "secret", "sect", "sector", "secure", "see", "seed", "seeing", "seek", "seem", "seize", "seldom", "select", "self", "sell", "seller", "semi", "senate", "send", "senile", "senior", "sense", "sensor", "sent", "sentry", "seoul", "sequel", "serene", "serial", "series", "sermon", "serum", "serve", "server", "set", "settle", "seven", "severe", "sew", "sewage", "shabby", "shade", "shadow", "shady", "shaft", "shaggy", "shah", "shake", "shaky", "shall", "sham", "shame", "shape", "share", "shark", "sharp", "shawl", "she", "shear", "sheen", "sheep", "sheer", "sheet", "shelf", "shell", "sherry", "shield", "shift", "shine", "shiny", "ship", "shire", "shirk", "shirt", "shiver", "shock", "shoe", "shook", "shoot", "shop", "shore", "short", "shot", "should", "shout", "show", "shower", "shrank", "shrewd", "shrill", "shrimp", "shrine", "shrink", "shrub", "shrug", "shut", "shy", "shyly", "sick", "side", "siege", "sigh", "sight", "sigma", "sign", "signal", "silent", "silk", "silken", "silky", "sill", "silly", "silo", "silver", "simple", "simply", "since", "sinful", "sing", "singer", "single", "sink", "sir", "sire", "siren", "sister", "sit", "site", "sitter", "six", "sixth", "sixty", "size", "sketch", "skill", "skin", "skinny", "skip", "skirt", "skull", "sky", "slab", "slack", "slain", "slam", "slang", "slap", "slat", "slate", "slave", "sleek", "sleep", "sleepy", "sleeve", "slice", "slick", "slid", "slide", "slight", "slim", "slimy", "sling", "slip", "slit", "slogan", "slope", "sloppy", "slot", "slow", "slowly", "slug", "slum", "slump", "smack", "small", "smart", "smash", "smear", "smell", "smelly", "smelt", "smile", "smite", "smoke", "smoky", "smooth", "smug", "snack", "snail", "snake", "snap", "snatch", "sneak", "snow", "snowy", "snug", "soak", "soap", "sober", "soccer", "social", "sock", "socket", "socks", "soda", "sodden", "sodium", "sofa", "soft", "soften", "softly", "soggy", "soil", "solar", "sold", "sole", "solely", "solemn", "solid", "solo", "solve", "some", "son", "sonar", "sonata", "song", "sonic", "sony", "soon", "sooner", "soot", "soothe", "sordid", "sore", "sorrow", "sorry", "sort", "soul", "sound", "soup", "sour", "source", "soviet", "sow", "space", "spade", "spain", "span", "spare", "spark", "sparse", "spasm", "spat", "spate", "speak", "spear", "speech", "speed", "speedy", "spell", "spend", "sphere", "spice", "spicy", "spider", "spiky", "spill", "spin", "spinal", "spine", "spiral", "spirit", "spit", "spite", "splash", "split", "spoil", "spoke", "sponge", "spoon", "sport", "spot", "spouse", "spray", "spread", "spree", "spring", "sprint", "spur", "squad", "square", "squash", "squat", "squid", "stab", "stable", "stack", "staff", "stage", "stain", "stair", "stairs", "stake", "stale", "stall", "stamp", "stance", "stand", "staple", "star", "starch", "stare", "stark", "start", "starve", "state", "static", "statue", "status", "stay", "stead", "steady", "steak", "steal", "steam", "steel", "steep", "steer", "stem", "stench", "step", "stereo", "stern", "stew", "stick", "sticky", "stiff", "stifle", "stigma", "still", "sting", "stint", "stir", "stitch", "stock", "stocky", "stone", "stony", "stool", "stop", "store", "storm", "stormy", "story", "stout", "stove", "stow", "strain", "strait", "strand", "strap", "strata", "straw", "stray", "streak", "stream", "street", "stress", "strict", "stride", "strife", "strike", "string", "strip", "stripe", "strive", "stroke", "stroll", "strong", "stud", "studio", "study", "stuff", "stuffy", "stunt", "stupid", "sturdy", "style", "submit", "subtle", "subtly", "suburb", "such", "sudden", "sue", "suez", "suffer", "sugar", "suit", "suite", "suitor", "sullen", "sultan", "sum", "summer", "summit", "summon", "sun", "sunday", "sunny", "sunset", "super", "superb", "supper", "supple", "supply", "sure", "surely", "surf", "surge", "survey", "suture", "swamp", "swan", "swap", "swarm", "sway", "swear", "sweat", "sweaty", "sweden", "sweep", "sweet", "swell", "swift", "swim", "swine", "swing", "swirl", "swiss", "switch", "sword", "swore", "sydney", "symbol", "synod", "syntax", "syria", "syrup", "system", "table", "tablet", "taboo", "tacit", "tackle", "tact", "tactic", "tail", "tailor", "taiwan", "take", "tale", "talent", "talk", "tall", "tally", "tame", "tampa", "tan", "tandem", "tangle", "tank", "tap", "tape", "target", "tariff", "tarp", "tart", "tarzan", "task", "taste", "tasty", "tattoo", "taurus", "taut", "tavern", "tax", "taxi", "tea", "teach", "teak", "team", "tear", "tease", "tech", "teeth", "tell", "temper", "temple", "tempo", "tempt", "ten", "tenant", "tend", "tender", "tendon", "tennis", "tenor", "tense", "tent", "tenth", "tenure", "teresa", "term", "terror", "terse", "test", "texas", "text", "thank", "thaw", "them", "theme", "thence", "theory", "there", "these", "thesis", "they", "thick", "thief", "thigh", "thin", "thing", "think", "third", "thirst", "thirty", "this", "thomas", "thorn", "those", "though", "thread", "threat", "three", "thrill", "thrive", "throat", "throne", "throng", "throw", "thrust", "thud", "thug", "thumb", "thus", "thyme", "tibet", "tick", "ticket", "tidal", "tide", "tidy", "tie", "tier", "tiger", "tight", "tile", "till", "tilt", "timber", "time", "timid", "tin", "tiny", "tip", "tire", "tissue", "title", "toad", "toast", "today", "toe", "toilet", "token", "tokyo", "told", "toll", "tom", "tomato", "tomb", "tonal", "tone", "tongue", "tonic", "too", "took", "tool", "tooth", "top", "topaz", "topic", "torch", "torque", "torso", "tort", "toss", "total", "touch", "tough", "tour", "toward", "towel", "tower", "town", "toxic", "toxin", "toy", "trace", "track", "tract", "trade", "tragic", "trail", "train", "trait", "tram", "trance", "trap", "trauma", "travel", "tray", "tread", "treat", "treaty", "treble", "tree", "trek", "tremor", "trench", "trend", "trendy", "trial", "tribal", "tribe", "trick", "tricky", "tried", "trifle", "trim", "trio", "trip", "triple", "troop", "trophy", "trot", "trough", "trout", "truce", "truck", "true", "truly", "trunk", "trust", "truth", "try", "tube", "tumble", "tuna", "tundra", "tune", "tunic", "tunnel", "turban", "turf", "turk", "turkey", "turn", "turtle", "tutor", "tweed", "twelve", "twenty", "twice", "twin", "twist", "two", "tycoon", "tying", "type", "tyrant", "ugly", "ulcer", "ultra", "umpire", "unable", "uncle", "under", "uneasy", "unfair", "unify", "union", "unique", "unit", "unite", "unity", "unlike", "unrest", "unruly", "until", "update", "upheld", "uphill", "uphold", "upon", "upper", "uproar", "upset", "upshot", "uptake", "upturn", "upward", "urban", "urge", "urgent", "urging", "urine", "usable", "usage", "use", "useful", "user", "usual", "utmost", "utter", "vacant", "vacuum", "vague", "vain", "valet", "valid", "valley", "value", "valve", "van", "vanish", "vanity", "vary", "vase", "vast", "vat", "vault", "vector", "veil", "vein", "velvet", "vendor", "veneer", "venice", "venom", "vent", "venue", "venus", "verb", "verbal", "verge", "verify", "verity", "verse", "versus", "very", "vessel", "vest", "vet", "veto", "via", "viable", "vicar", "vice", "victim", "victor", "video", "vienna", "view", "vigil", "viking", "vile", "villa", "vine", "vinyl", "viola", "violet", "violin", "viral", "virgo", "virtue", "virus", "visa", "vision", "visit", "visual", "vital", "vivid", "vocal", "vodka", "vogue", "voice", "void", "volley", "volume", "vote", "vowel", "voyage", "vulgar", "wade", "wage", "waist", "wait", "waiter", "wake", "walk", "walker", "wall", "wallet", "walnut", "wander", "want", "war", "warden", "warm", "warmth", "warn", "warp", "warsaw", "wary", "was", "wash", "wasp", "waste", "watch", "water", "watery", "wave", "wax", "way", "weak", "weaken", "wealth", "weapon", "wear", "weary", "weave", "wedge", "wee", "weed", "week", "weekly", "weep", "weigh", "weight", "weird", "well", "were", "west", "wet", "whale", "wharf", "what", "wheat", "wheel", "when", "whence", "where", "which", "whiff", "while", "whim", "whip", "whisky", "white", "who", "whole", "wholly", "whom", "whose", "why", "wicked", "wide", "widely", "widen", "wider", "widow", "width", "wife", "wig", "wild", "wildly", "will", "willow", "wily", "win", "wind", "window", "windy", "wine", "wing", "wink", "winner", "winter", "wipe", "wire", "wisdom", "wise", "wish", "wit", "witch", "with", "within", "witty", "wizard", "woke", "wolf", "wolves", "woman", "womb", "won", "wonder", "wood", "wooden", "woods", "woody", "wool", "word", "work", "worker", "world", "worm", "worry", "worse", "worst", "worth", "worthy", "would", "wound", "wrap", "wrath", "wreath", "wreck", "wring", "wrist", "writ", "write", "writer", "wrong", "xerox", "yacht", "yale", "yard", "yarn", "yeah", "year", "yeard", "yeast", "yellow", "yet", "yield", "yogurt", "yolk", "you", "young", "your", "youth", "zaire", "zeal", "zebra", "zenith", "zero", "zeus", "zigzag", "zinc", "zombie", "zone"];
exports.default = _default;

/***/ }),

/***/ 7479:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 */
class Duration {
  /**
   * @param {Long | number} seconds
   */
  constructor(seconds) {
    /**
     * @readonly
     * @type {Long}
     */
    this.seconds = seconds instanceof _long.default ? seconds : _long.default.fromNumber(seconds);
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {proto.IDuration}
   */


  _toProtobuf() {
    return {
      seconds: this.seconds
    };
  }
  /**
   * @internal
   * @param {proto.IDuration} duration
   * @returns {Duration}
   */


  static _fromProtobuf(duration) {
    return new Duration(
    /** @type {Long} */
    duration.seconds);
  }

}

exports.default = Duration;

/***/ }),

/***/ 7237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.constructor = constructor;
exports.fromString = fromString;
exports.fromSolidityAddress = fromSolidityAddress;
exports._parseAddress = _parseAddress;
exports._checksum = _checksum;

var _long = _interopRequireDefault(__nccwpck_require__(492));

var hex = _interopRequireWildcard(__nccwpck_require__(819));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {object} IEntityId
 * @property {number | Long} num
 * @property {(number | Long)=} shard
 * @property {(number | Long)=} realm
 */

/**
 * @typedef {object} IEntityIdResult
 * @property {Long} shard
 * @property {Long} realm
 * @property {Long} num
 */

/**
 * @typedef {object} IEntityIdResultWithChecksum
 * @property {Long} shard
 * @property {Long} realm
 * @property {Long} num
 * @property {string | null} checksum
 */
const regex = RegExp("^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$");
/**
 * @param {number | Long | IEntityId} props
 * @param {(number | null | Long)=} realm
 * @param {(number | null | Long)=} num
 * @returns {IEntityIdResult}
 */

function constructor(props, realm, num) {
  let shard_ = _long.default.ZERO;
  let realm_ = _long.default.ZERO;
  let num_ = _long.default.ZERO;

  if (typeof props === "number" || _long.default.isLong(props)) {
    if (realm == null || typeof realm === "string") {
      num_ = _long.default.fromValue(props);
    } else {
      shard_ = _long.default.fromValue(props);
      realm_ = _long.default.fromValue(realm);
      num_ = num != null ? _long.default.fromValue(num) : _long.default.ZERO;
    }
  } else {
    shard_ = _long.default.fromValue(props.shard != null ? props.shard : 0);
    realm_ = _long.default.fromValue(props.realm != null ? props.realm : 0);
    num_ = _long.default.fromValue(props.num != null ? props.num : 0);
  }

  if (shard_.isNegative() || realm_.isNegative() || num_.isNegative()) {
    throw new Error("negative numbers are not allowed in IDs");
  }

  return {
    shard: shard_,
    realm: realm_,
    num: num_
  };
}
/**
 * @typedef {object} ParseAddressResult
 * @property {number} status
 * @property {Long} [num1]
 * @property {Long} [num2]
 * @property {Long} [num3]
 * @property {string} [correctChecksum]
 * @property {string} [givenChecksum]
 * @property {string} [noChecksumFormat]
 * @property {string} [withChecksumFormat]
 */

/**
 * @param {string} text
 * @returns {IEntityIdResultWithChecksum}
 */


function fromString(text) {
  const [id, checksum] = text.split("-");
  const parts = id.split(".");

  for (const part of parts) {
    if (part === "") {
      throw new Error("invalid format for entity ID");
    }
  }

  const components = parts.map(Number);

  for (const component of components) {
    if (Number.isNaN(component)) {
      throw new Error("invalid format for entity ID");
    }
  }

  let shard = _long.default.ZERO;
  let realm = _long.default.ZERO;
  let num;

  if (components.length === 1) {
    num = _long.default.fromNumber(components[0]);
  } else if (components.length === 3) {
    shard = _long.default.fromNumber(components[0]);
    realm = _long.default.fromNumber(components[1]);
    num = _long.default.fromNumber(components[2]);
  } else {
    throw new Error("invalid format for entity ID");
  }

  return {
    shard,
    realm,
    num,
    checksum
  };
}
/**
 * @param {string} address
 * @returns {[Long, Long, Long]}
 */


function fromSolidityAddress(address) {
  const addr = address.startsWith("0x") ? hex.decode(address.slice(2)) : hex.decode(address);

  if (addr.length !== 20) {
    throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
  }

  const shard = _long.default.fromBytesBE(Array.from(addr.slice(0, 4)));

  const realm = _long.default.fromBytesBE(Array.from(addr.slice(4, 12)));

  const num = _long.default.fromBytesBE(Array.from(addr.slice(12, 20)));

  return [shard, realm, num];
} // /**
//  * Check that the checksum in box withChecksum is correct
//  *
//  * @param {number} status
//  */
// function _verify(status) {
//     switch (status) {
//         case 0: // Syntax error
//             throw new Error(
//                 "Invalid ID: format should look like 0.0.123 or 0.0.123-vfmkw"
//             );
//         case 1: // An invalid with-checksum address
//             throw new Error("Invalid ID: checksum does not match");
//         case 2: // A valid no-checksum address
//         case 3: // A valid with-checksum address
//             break;
//     }
// }

/**
 * Parse the address string addr and return an object with the results (8 fields).
 * The first four fields are numbers, which could be implemented as signed 32 bit
 * integers, and the last four are strings.
 *
 *   status;  //the status of the parsed address
 *            //   0 = syntax error
 *            //   1 = an invalid with-checksum address (bad checksum)
 *            //   2 = a valid no-checksum address
 *            //   3 = a valid with-checksum address
 *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed
 *   num2;
 *   num3;
 *   correctchecksum;    //the correct checksum
 *   givenChecksum;      //the checksum in the address that was parsed
 *   noChecksumFormat;   //the address in no-checksum format
 *   withChecksumFormat; //the address in with-checksum format
 *
 * @param {string} ledgerId
 * @param {string} addr
 * @returns {ParseAddressResult}
 */


function _parseAddress(ledgerId, addr) {
  let match = regex.exec(addr);

  if (match === null) {
    let result = {
      status: 0
    }; // When status == 0, the rest of the fields should be ignored

    return result;
  }

  let a = [_long.default.fromString(match[1]), _long.default.fromString(match[2]), _long.default.fromString(match[3])];
  let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;

  let c = _checksum(ledgerId, ad);

  let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //the status

  let result = {
    status: s,
    num1: a[0],
    num2: a[1],
    num3: a[2],
    givenChecksum: match[4],
    correctChecksum: c,
    noChecksumFormat: ad,
    withChecksumFormat: `${ad}-${c}`
  };
  return result;
}
/**
 * Given an address like "0.0.123", return a checksum like "laujm"
 *
 * @param {string} ledgerId
 * @param {string} addr
 * @returns {string}
 */


function _checksum(ledgerId, addr) {
  let answer = "";
  let d = []; // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]

  let s0 = 0; // Sum of even positions (mod 11)

  let s1 = 0; // Sum of odd positions (mod 11)

  let s = 0; // Weighted sum of all positions (mod p3)

  let sh = 0; // Hash of the ledger ID

  let c = 0; // The checksum, as a single number

  const p3 = 26 * 26 * 26; // 3 digits in base 26

  const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26

  const ascii_a = "a".charCodeAt(0); // 97

  const m = 1000003; // Min prime greater than a million. Used for the final permutation.

  const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.

  let id = ledgerId + "000000000000";
  let h = [];

  for (var i = 0; i < id.length; i += 2) {
    h.push(parseInt(id.substr(i, 2), 16));
  }

  for (let i = 0; i < addr.length; i++) {
    d.push(addr[i] === "." ? 10 : parseInt(addr[i], 10));
  }

  for (let i = 0; i < d.length; i++) {
    s = (w * s + d[i]) % p3;

    if (i % 2 === 0) {
      s0 = (s0 + d[i]) % 11;
    } else {
      s1 = (s1 + d[i]) % 11;
    }
  }

  for (let i = 0; i < h.length; i++) {
    sh = (w * sh + h[i]) % p5;
  }

  c = (((addr.length % 5 * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
  c = c * m % p5;

  for (let i = 0; i < 5; i++) {
    answer = String.fromCharCode(ascii_a + c % 26) + answer;
    c /= 26;
  }

  return answer;
}

/***/ }),

/***/ 7344:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ExchangeRate {
  /**
   * @private
   * @param {object} props
   * @param {number} props.hbars
   * @param {number} props.cents
   * @param {Date} props.expirationTime
   */
  constructor(props) {
    /**
     * Denotes Hbar equivalent to cents (USD)
     *
     * @readonly
     * @type {number}
     */
    this.hbars = props.hbars;
    /**
     * Denotes cents (USD) equivalent to Hbar
     *
     * @readonly
     * @type {number}
     */

    this.cents = props.cents;
    /**
     * Expiration time of this exchange rate
     *
     * @readonly
     * @type {Date}
     */

    this.expirationTime = props.expirationTime;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {import("@hashgraph/proto").IExchangeRate} rate
   * @returns {ExchangeRate}
   */


  static _fromProtobuf(rate) {
    return new ExchangeRate({
      hbars:
      /** @type {number} */
      rate.hbarEquiv,
      cents:
      /** @type {number} */
      rate.centEquiv,
      expirationTime: new Date(rate.expirationTime != null ? rate.expirationTime.seconds != null ? rate.expirationTime.seconds instanceof _long.default ? rate.expirationTime.seconds.toInt() : rate.expirationTime.seconds : 0 * 1000 : 0 * 1000)
    });
  }
  /**
   * @internal
   * @returns {import("@hashgraph/proto").IExchangeRate}
   */


  _toProtobuf() {
    return {
      hbarEquiv: this.hbars,
      centEquiv: this.cents,
      expirationTime: {
        seconds: _long.default.fromNumber(this.expirationTime.getSeconds())
      }
    };
  }

}

exports.default = ExchangeRate;

/***/ }),

/***/ 1128:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.RST_STREAM = exports.ExecutionState = void 0;

var _GrpcServiceError = _interopRequireDefault(__nccwpck_require__(9115));

var _GrpcStatus = _interopRequireDefault(__nccwpck_require__(3374));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */

/**
 * @enum {string}
 */
const ExecutionState = {
  Finished: "Finished",
  Retry: "Retry",
  Error: "Error"
};
exports.ExecutionState = ExecutionState;
const RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/gi;
/**
 * @abstract
 * @internal
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 */

exports.RST_STREAM = RST_STREAM;

class Executable {
  constructor() {
    /**
     * The number of times we can retry the grpc call
     *
     * @private
     * @type {number}
     */
    this._maxRetries = 10;
    /**
     * The index of the next transaction to be executed.
     *
     * @protected
     * @type {number}
     */

    this._nextNodeIndex = 0;
    /**
     * List of node account IDs for each transaction that has been
     * built.
     *
     * @internal
     * @type {AccountId[]}
     */

    this._nodeIds = [];
  }
  /**
   * @returns {?AccountId[]}
   */


  get nodeAccountIds() {
    return this._nodeIds.length != 0 ? this._nodeIds : null;
  }
  /**
   * @param {AccountId[]} nodeIds
   * @returns {this}
   */


  setNodeAccountIds(nodeIds) {
    this._nodeIds = nodeIds;
    return this;
  }
  /**
   * @returns {number}
   */


  get maxRetries() {
    return this._maxRetries;
  }
  /**
   * @param {number} maxRetries
   * @returns {this}
   */


  setMaxRetries(maxRetries) {
    this._maxRetries = maxRetries;
    return this;
  }
  /**
   * @abstract
   * @protected
   * @param {import("./client/Client.js").default<Channel, *>} client
   * @returns {Promise<void>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _beforeExecute(client) {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @protected
   * @returns {Promise<RequestT>}
   */


  _makeRequestAsync() {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @internal
   * @param {RequestT} request
   * @param {ResponseT} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @protected
   * @param {ResponseT} response
   * @param {AccountId} nodeAccountId
   * @param {RequestT} request
   * @param {string | null} ledgerId
   * @returns {Promise<OutputT>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @internal
   * @param {Channel} channel
   * @param {RequestT} request
   * @returns {Promise<ResponseT>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _execute(channel, request) {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @protected
   * @returns {AccountId}
   */


  _getNodeAccountId() {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @protected
   * @returns {TransactionId}
   */


  _getTransactionId() {
    throw new Error("not implemented");
  }
  /**
   * @protected
   * @returns {void}
   */


  _advanceRequest() {
    // each time we move our cursor to the next transaction
    // wrapping around to ensure we are cycling
    this._nextNodeIndex = (this._nextNodeIndex + 1) % this._nodeIds.length;
  }
  /**
   * @abstract
   * @protected
   * @param {RequestT} request
   * @param {ResponseT} response
   * @returns {ExecutionState}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _shouldRetry(request, response) {
    throw new Error("not implemented");
  }
  /**
   * @protected
   * @param {GrpcServiceError} error
   * @returns {boolean}
   */


  _shouldRetryExceptionally(error) {
    return error.status === _GrpcStatus.default.Unavailable || error.status === _GrpcStatus.default.ResourceExhausted || error.status === _GrpcStatus.default.Internal && RST_STREAM.test(error.message);
  }
  /**
   * @template {Channel} ChannelT
   * @template MirrorChannelT
   * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
   * @returns {Promise<OutputT>}
   */


  async execute(client) {
    await this._beforeExecute(client);

    for (let attempt = 1
    /* loop forever */
    ;; attempt += 1) {
      const nodeAccountId = this._getNodeAccountId();

      const node = client._network.networkNodes.get(nodeAccountId.toString());

      if (node == null) {
        throw new Error(`NodeAccountId not recognized: ${nodeAccountId.toString()}`);
      }

      node.inUse();
      const channel = node.channel;
      const request = await this._makeRequestAsync(); // advance the internal index
      // non-free queries and transactions map to more than 1 actual transaction and this will cause
      // the next invocation of makeRequest to return the _next_ transaction

      this._advanceRequest();

      let response;

      if (!node.isHealthy()) {
        await node.wait();
      }

      try {
        response = await this._execute(channel, request);
      } catch (err) {
        const error = _GrpcServiceError.default._fromResponse(err);

        if (error instanceof _GrpcServiceError.default && this._shouldRetryExceptionally(error) && attempt <= this._maxRetries) {
          node.increaseDelay();
          continue;
        }

        throw err;
      }

      node.decreaseDelay();

      switch (this._shouldRetry(request, response)) {
        case ExecutionState.Retry:
          await delayForAttempt(attempt);
          continue;

        case ExecutionState.Finished:
          return this._mapResponse(response, nodeAccountId, request, client._network._ledgerId);

        case ExecutionState.Error:
          throw this._mapStatusError(request, response, client._network._ledgerId);

        default:
          throw new Error("(BUG) non-exhuastive switch statement for `ExecutionState`");
      }
    }
  }

}
/**
 * @param {number} attempt
 * @returns {Promise<void>}
 */


exports.default = Executable;

function delayForAttempt(attempt) {
  // 0.1s, 0.2s, 0.4s, 0.8s, ...
  const ms = Math.floor(50 * Math.pow(2, attempt));
  return new Promise(resolve => setTimeout(resolve, ms));
}

/***/ }),

/***/ 3826:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

var _long = __nccwpck_require__(4218);

var _HbarUnit = _interopRequireDefault(__nccwpck_require__(7190));

var _long2 = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./long.js").LongObject} LongObject
 */
class Hbar {
  /**
   * @param {number | string | Long | LongObject | BigNumber} amount
   * @param {HbarUnit=} unit
   */
  constructor(amount, unit = _HbarUnit.default.Hbar) {
    if (unit === _HbarUnit.default.Tinybar) {
      this._valueInTinybar = (0, _long.valueToLong)(amount);
    } else {
      /** @type {BigNumber} */
      let bigAmount;

      if (_long2.default.isLong(amount)) {
        bigAmount = new _bignumber.default(amount.toString(10));
      } else if (_bignumber.default.isBigNumber(amount) || typeof amount === "string" || typeof amount === "number") {
        bigAmount = new _bignumber.default(amount);
      } else {
        bigAmount = new _bignumber.default(0);
      }
      /**
       * @type {BigNumber}
       */


      this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
    }
  }
  /**
   * @param {number | Long | BigNumber} amount
   * @param {HbarUnit} unit
   * @returns {Hbar}
   */


  static from(amount, unit) {
    return new Hbar(amount, unit);
  }
  /**
   * @param {number | Long | string | BigNumber} amount
   * @returns {Hbar}
   */


  static fromTinybars(amount) {
    if (typeof amount === "string") {
      return this.fromString(amount, _HbarUnit.default.Tinybar);
    }

    return new Hbar(amount, _HbarUnit.default.Tinybar);
  }
  /**
   * @param {string} str
   * @param {HbarUnit=} unit
   * @returns {Hbar}
   */


  static fromString(str, unit = _HbarUnit.default.Hbar) {
    return new Hbar(new _bignumber.default(str), unit);
  }
  /**
   * @param {HbarUnit} unit
   * @returns {BigNumber}
   */


  to(unit) {
    return this._valueInTinybar.dividedBy(unit._tinybar);
  }
  /**
   * @returns {BigNumber}
   */


  toBigNumber() {
    return this.to(_HbarUnit.default.Hbar);
  }
  /**
   * @returns {Long}
   */


  toTinybars() {
    return _long2.default.fromValue(this._valueInTinybar.toFixed());
  }
  /**
   * @returns {Hbar}
   */


  negated() {
    return Hbar.fromTinybars(this._valueInTinybar.negated());
  }
  /**
   * @override
   * @param {HbarUnit=} unit
   * @returns {string}
   */


  toString(unit) {
    if (unit != null) {
      return `${this._valueInTinybar.dividedBy(unit._tinybar).toString()} ${unit._symbol}`;
    }

    if (this._valueInTinybar.isLessThan(10000) && this._valueInTinybar.isGreaterThan(-10000)) {
      return `${this._valueInTinybar.toFixed()} ${_HbarUnit.default.Tinybar._symbol}`;
    }

    return `${this.to(_HbarUnit.default.Hbar).toString()} ${_HbarUnit.default.Hbar._symbol}`;
  }

}

exports.default = Hbar;

/***/ }),

/***/ 7190:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HbarUnit {
  /**
   * @internal
   * @param {string} name
   * @param {string} symbol
   * @param {BigNumber} tinybar
   */
  constructor(name, symbol, tinybar) {
    /**
     * @internal
     * @readonly
     */
    this._name = name;
    /**
     * @internal
     * @readonly
     */

    this._symbol = symbol;
    /**
     * @internal
     * @readonly
     */

    this._tinybar = tinybar;
    Object.freeze(this);
  }

}

exports.default = HbarUnit;
HbarUnit.Tinybar = new HbarUnit("tinybar", "t", new _bignumber.default(1));
HbarUnit.Microbar = new HbarUnit("microbar", "", new _bignumber.default(100));
HbarUnit.Millibar = new HbarUnit("millibar", "m", new _bignumber.default(100000));
HbarUnit.Hbar = new HbarUnit("hbar", "", new _bignumber.default("100000000"));
HbarUnit.Kilobar = new HbarUnit("kilobar", "k", new _bignumber.default(1000).multipliedBy(new _bignumber.default("100000000")));
HbarUnit.Megabar = new HbarUnit("megabar", "M", new _bignumber.default(1000000).multipliedBy(new _bignumber.default("100000000")));
HbarUnit.Gigabar = new HbarUnit("gigabar", "G", new _bignumber.default("1000000000").multipliedBy(new _bignumber.default("100000000")));

/***/ }),

/***/ 4190:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @abstract
 * @template {Channel | MirrorChannel} ChannelT
 */
class ManagedNode {
  /**
   * @param {string} address
   * @param {(address: string) => ChannelT} channelInitFunction
   */
  constructor(address, channelInitFunction) {
    this.address = address;
    /** @type {ChannelT | null} */

    this._channel = null;
    /** @type {(address: string) => ChannelT} */

    this._channelInitFunction = channelInitFunction;
  }

  get channel() {
    if (this._channel != null) {
      return this._channel;
    }

    this._channel = this._channelInitFunction(this.address);
    return this._channel;
  }

  close() {
    if (this._channel != null) {
      this._channel.close();
    }

    this._channel = null;
  }

}

exports.default = ManagedNode;

/***/ }),

/***/ 3672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @typedef {import("./Hbar.js").default} Hbar
 */
class MaxQueryPaymentExceeded extends Error {
  /**
   * @param {Hbar} queryCost
   * @param {Hbar} maxQueryPayment
   */
  constructor(queryCost, maxQueryPayment) {
    super();
    this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
    this.name = "MaxQueryPaymentExceededError";
    this.queryCost = queryCost;
    this.maxQueryPayment = maxQueryPayment;
  }

}

exports.default = MaxQueryPaymentExceeded;

/***/ }),

/***/ 8998:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 */
class MirrorNode {
  /**
   * @param {string} address
   * @param {(address: string) => MirrorChannel} channelInitFunction
   */
  constructor(address, channelInitFunction) {
    this.address = address;
    this._channelInitFunction = channelInitFunction;
  }

  get channel() {
    if (this._channel != null) {
      return this._channel;
    }

    this._channel = this._channelInitFunction(this.address);
    return this._channel;
  }

  close() {
    if (this._channel != null) {
      this._channel.close();
    }

    this._channel = null;
  }

}

exports.default = MirrorNode;

/***/ }),

/***/ 8986:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._ledgerIdToLedgerId = _ledgerIdToLedgerId;
exports._ledgerIdToNetworkName = _ledgerIdToNetworkName;
exports.default = exports._networkIds = void 0;

/**
 * @typedef {object} NetworkNameType
 * @property {string} Mainnet
 * @property {string} Testnet
 * @property {string} Previewnet
 */

/**
 * @type {NetworkNameType}
 */
const NetworkName = {
  Mainnet: "mainnet",
  Testnet: "testnet",
  Previewnet: "previewnet"
};
/** @type {[string, string, string]} */

const _networkIds = ["0", "1", "2"];
/**
 * @param {string} networkName
 * @returns {string}
 */

exports._networkIds = _networkIds;

function _ledgerIdToLedgerId(networkName) {
  switch (networkName) {
    case NetworkName.Mainnet:
      return _networkIds[0];

    case NetworkName.Testnet:
      return _networkIds[1];

    case NetworkName.Previewnet:
      return _networkIds[2];

    default:
      throw new Error(`unrecognized network name, expected "mainnet", "testnet", or "previewnet"`);
  }
}
/**
 * @param {string} ledgerId
 * @returns {string}
 */


function _ledgerIdToNetworkName(ledgerId) {
  switch (ledgerId) {
    case "0":
      return NetworkName.Mainnet;

    case "1":
      return NetworkName.Mainnet;

    case "2":
      return NetworkName.Mainnet;

    default:
      throw new Error(`unrecognized ledgerId, expected "0", "1", or "2"`);
  }
}

var _default = NetworkName;
exports.default = _default;

/***/ }),

/***/ 4952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ManagedNode = _interopRequireDefault(__nccwpck_require__(4190));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 */

/**
 * @template {Channel} ChannelT
 * @augments {ManagedNode<ChannelT>}
 */
class Node extends _ManagedNode.default {
  /**
   * @param {AccountId} accountId
   * @param {string} address
   * @param {(address: string) => ChannelT} channelInitFunction
   */
  constructor(accountId, address, channelInitFunction) {
    super(address, channelInitFunction);
    this.accountId = accountId;
    /** @type {number} */

    this.delay = 250;
    /** @type {number} */

    this.lastUsed = Date.now();
    /** @type {number} */

    this.delayUntil = Date.now();
    /** @type {number} */

    this.useCount = 0;
  }

  inUse() {
    this.useCount++;
    this.lastUsed = Date.now();
  }
  /**
   * Determines if this node is healthy by checking if this node hasn't been
   * in use for a the required `delay` period. Since this looks at `this.lastUsed`
   * and that value is only set in the `wait()` method, any node that has not
   * returned a bad gRPC status will always be considered healthy.
   *
   * @returns {boolean}
   */


  isHealthy() {
    return this.delayUntil <= Date.now();
  }

  increaseDelay() {
    this.delay = Math.min(this.delay * 2, 8000);
    this.delayUntil = Date.now() + this.delay;
  }

  decreaseDelay() {
    this.delay = Math.max(this.delay / 2, 250);
  }
  /**
   * This is only ever called if the node itself is down.
   * A node returning a transaction with a bad status code does not indicate
   * the node is down, and hence this method will not be called.
   *
   * @returns {Promise<void>}
   */


  wait() {
    const delay = this.delayUntil - this.lastUsed;
    return new Promise(resolve => setTimeout(resolve, delay));
  }
  /**
   * @param {Node<*>} node
   * @returns {number}
   */


  compare(node) {
    if (this.isHealthy() && node.isHealthy()) {
      if (this.useCount < node.useCount) {
        return -1;
      } else if (this.useCount > node.useCount) {
        return 1;
      } else {
        if (this.lastUsed < node.lastUsed) {
          return -1;
        } else if (this.lastUsed > node.lastUsed) {
          return 1;
        } else {
          return 0;
        }
      }
    } else if (this.isHealthy() && !node.isHealthy()) {
      return -1;
    } else if (!this.isHealthy() && node.isHealthy()) {
      return 1;
    } else {
      if (this.useCount < node.useCount) {
        return -1;
      } else if (this.useCount > node.useCount) {
        return 1;
      } else {
        if (this.lastUsed < node.lastUsed) {
          return -1;
        } else if (this.lastUsed > node.lastUsed) {
          return 1;
        } else {
          return 0;
        }
      }
    }
  }

}

exports.default = Node;

/***/ }),

/***/ 5835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @abstract
 * @template {{ toString(): string }} KeyT
 * @template {{ toString(): string }} ValueT
 */
class ObjectMap {
  /**
   * @param {(s: string) => KeyT} fromString
   */
  constructor(fromString) {
    /** @type {Map<string, ValueT>} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    this._map = new Map();
    /** @type {Map<KeyT, ValueT>} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    this.__map = new Map();
    this._fromString = fromString;
  }
  /**
   * @param {KeyT | string} key
   * @returns {?ValueT}
   */


  get(key) {
    const k = typeof key === "string" ? key : key.toString();

    const value = this._map.get(k);

    return value != null ? value : null;
  }
  /**
   * @internal
   * @param {KeyT} key
   * @param {ValueT} value
   */


  _set(key, value) {
    const k = typeof key === "string" ? key : key.toString();

    this._map.set(k, value);

    this.__map.set(typeof k === "string" ? this._fromString(k) : k, value);
  }
  /**
   * @returns {IterableIterator<ValueT>}
   */


  values() {
    return this._map.values();
  }
  /**
   * @returns {number}
   */


  get size() {
    return this._map.size;
  }
  /**
   * @returns {IterableIterator<KeyT>}
   */


  keys() {
    return this.__map.keys();
  }
  /**
   * @returns {IterableIterator<[KeyT, ValueT]>}
   */


  [Symbol.iterator]() {
    return this.__map[Symbol.iterator]();
  }
  /**
   * @returns {string}
   */


  toString() {
    /** @type {Object.<string, string>} */
    const map = {};

    for (const [key, value] of this._map) {
      map[key] = value.toString();
    }

    return JSON.stringify(map);
  }

}

exports.default = ObjectMap;

/***/ }),

/***/ 3553:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _StatusError = _interopRequireDefault(__nccwpck_require__(3325));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */
class PrecheckStatusError extends _StatusError.default {
  /**
   * @param {object} props
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    super(props, `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()}`);
  }

}

exports.default = PrecheckStatusError;

/***/ }),

/***/ 7852:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _StatusError = _interopRequireDefault(__nccwpck_require__(3325));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 */
class ReceiptStatusError extends _StatusError.default {
  /**
   * @param {object} props
   * @param {TransactionReceipt} props.transactionReceipt
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    super(props, `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`);
    /**
     * @type {TransactionReceipt}
     * @readonly
     */

    this.transactionReceipt = props.transactionReceipt;
  }

}

exports.default = ReceiptStatusError;

/***/ }),

/***/ 1108:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */
class Status {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    /** @readonly */
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @returns {string}
   */


  toString() {
    switch (this) {
      case Status.Ok:
        return "OK";

      case Status.InvalidTransaction:
        return "INVALID_TRANSACTION";

      case Status.PayerAccountNotFound:
        return "PAYER_ACCOUNT_NOT_FOUND";

      case Status.InvalidNodeAccount:
        return "INVALID_NODE_ACCOUNT";

      case Status.TransactionExpired:
        return "TRANSACTION_EXPIRED";

      case Status.InvalidTransactionStart:
        return "INVALID_TRANSACTION_START";

      case Status.InvalidTransactionDuration:
        return "INVALID_TRANSACTION_DURATION";

      case Status.InvalidSignature:
        return "INVALID_SIGNATURE";

      case Status.MemoTooLong:
        return "MEMO_TOO_LONG";

      case Status.InsufficientTxFee:
        return "INSUFFICIENT_TX_FEE";

      case Status.InsufficientPayerBalance:
        return "INSUFFICIENT_PAYER_BALANCE";

      case Status.DuplicateTransaction:
        return "DUPLICATE_TRANSACTION";

      case Status.Busy:
        return "BUSY";

      case Status.NotSupported:
        return "NOT_SUPPORTED";

      case Status.InvalidFileId:
        return "INVALID_FILE_ID";

      case Status.InvalidAccountId:
        return "INVALID_ACCOUNT_ID";

      case Status.InvalidContractId:
        return "INVALID_CONTRACT_ID";

      case Status.InvalidTransactionId:
        return "INVALID_TRANSACTION_ID";

      case Status.ReceiptNotFound:
        return "RECEIPT_NOT_FOUND";

      case Status.RecordNotFound:
        return "RECORD_NOT_FOUND";

      case Status.InvalidSolidityId:
        return "INVALID_SOLIDITY_ID";

      case Status.Unknown:
        return "UNKNOWN";

      case Status.Success:
        return "SUCCESS";

      case Status.FailInvalid:
        return "FAIL_INVALID";

      case Status.FailFee:
        return "FAIL_FEE";

      case Status.FailBalance:
        return "FAIL_BALANCE";

      case Status.KeyRequired:
        return "KEY_REQUIRED";

      case Status.BadEncoding:
        return "BAD_ENCODING";

      case Status.InsufficientAccountBalance:
        return "INSUFFICIENT_ACCOUNT_BALANCE";

      case Status.InvalidSolidityAddress:
        return "INVALID_SOLIDITY_ADDRESS";

      case Status.InsufficientGas:
        return "INSUFFICIENT_GAS";

      case Status.ContractSizeLimitExceeded:
        return "CONTRACT_SIZE_LIMIT_EXCEEDED";

      case Status.LocalCallModificationException:
        return "LOCAL_CALL_MODIFICATION_EXCEPTION";

      case Status.ContractRevertExecuted:
        return "CONTRACT_REVERT_EXECUTED";

      case Status.ContractExecutionException:
        return "CONTRACT_EXECUTION_EXCEPTION";

      case Status.InvalidReceivingNodeAccount:
        return "INVALID_RECEIVING_NODE_ACCOUNT";

      case Status.AccountUpdateFailed:
        return "ACCOUNT_UPDATE_FAILED";

      case Status.InvalidKeyEncoding:
        return "INVALID_KEY_ENCODING";

      case Status.NullSolidityAddress:
        return "NULL_SOLIDITY_ADDRESS";

      case Status.ContractUpdateFailed:
        return "CONTRACT_UPDATE_FAILED";

      case Status.InvalidQueryHeader:
        return "INVALID_QUERY_HEADER";

      case Status.InvalidFeeSubmitted:
        return "INVALID_FEE_SUBMITTED";

      case Status.InvalidPayerSignature:
        return "INVALID_PAYER_SIGNATURE";

      case Status.KeyNotProvided:
        return "KEY_NOT_PROVIDED";

      case Status.InvalidExpirationTime:
        return "INVALID_EXPIRATION_TIME";

      case Status.NoWaclKey:
        return "NO_WACL_KEY";

      case Status.FileContentEmpty:
        return "FILE_CONTENT_EMPTY";

      case Status.InvalidAccountAmounts:
        return "INVALID_ACCOUNT_AMOUNTS";

      case Status.EmptyTransactionBody:
        return "EMPTY_TRANSACTION_BODY";

      case Status.InvalidTransactionBody:
        return "INVALID_TRANSACTION_BODY";

      case Status.InvalidSignatureTypeMismatchingKey:
        return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";

      case Status.InvalidSignatureCountMismatchingKey:
        return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";

      case Status.EmptyLiveHashBody:
        return "EMPTY_LIVE_HASH_BODY";

      case Status.EmptyLiveHash:
        return "EMPTY_LIVE_HASH";

      case Status.EmptyLiveHashKeys:
        return "EMPTY_LIVE_HASH_KEYS";

      case Status.InvalidLiveHashSize:
        return "INVALID_LIVE_HASH_SIZE";

      case Status.EmptyQueryBody:
        return "EMPTY_QUERY_BODY";

      case Status.EmptyLiveHashQuery:
        return "EMPTY_LIVE_HASH_QUERY";

      case Status.LiveHashNotFound:
        return "LIVE_HASH_NOT_FOUND";

      case Status.AccountIdDoesNotExist:
        return "ACCOUNT_ID_DOES_NOT_EXIST";

      case Status.LiveHashAlreadyExists:
        return "LIVE_HASH_ALREADY_EXISTS";

      case Status.InvalidFileWacl:
        return "INVALID_FILE_WACL";

      case Status.SerializationFailed:
        return "SERIALIZATION_FAILED";

      case Status.TransactionOversize:
        return "TRANSACTION_OVERSIZE";

      case Status.TransactionTooManyLayers:
        return "TRANSACTION_TOO_MANY_LAYERS";

      case Status.ContractDeleted:
        return "CONTRACT_DELETED";

      case Status.PlatformNotActive:
        return "PLATFORM_NOT_ACTIVE";

      case Status.KeyPrefixMismatch:
        return "KEY_PREFIX_MISMATCH";

      case Status.PlatformTransactionNotCreated:
        return "PLATFORM_TRANSACTION_NOT_CREATED";

      case Status.InvalidRenewalPeriod:
        return "INVALID_RENEWAL_PERIOD";

      case Status.InvalidPayerAccountId:
        return "INVALID_PAYER_ACCOUNT_ID";

      case Status.AccountDeleted:
        return "ACCOUNT_DELETED";

      case Status.FileDeleted:
        return "FILE_DELETED";

      case Status.AccountRepeatedInAccountAmounts:
        return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";

      case Status.SettingNegativeAccountBalance:
        return "SETTING_NEGATIVE_ACCOUNT_BALANCE";

      case Status.ObtainerRequired:
        return "OBTAINER_REQUIRED";

      case Status.ObtainerSameContractId:
        return "OBTAINER_SAME_CONTRACT_ID";

      case Status.ObtainerDoesNotExist:
        return "OBTAINER_DOES_NOT_EXIST";

      case Status.ModifyingImmutableContract:
        return "MODIFYING_IMMUTABLE_CONTRACT";

      case Status.FileSystemException:
        return "FILE_SYSTEM_EXCEPTION";

      case Status.AutorenewDurationNotInRange:
        return "AUTORENEW_DURATION_NOT_IN_RANGE";

      case Status.ErrorDecodingBytestring:
        return "ERROR_DECODING_BYTESTRING";

      case Status.ContractFileEmpty:
        return "CONTRACT_FILE_EMPTY";

      case Status.ContractBytecodeEmpty:
        return "CONTRACT_BYTECODE_EMPTY";

      case Status.InvalidInitialBalance:
        return "INVALID_INITIAL_BALANCE";

      case Status.InvalidReceiveRecordThreshold:
        return "INVALID_RECEIVE_RECORD_THRESHOLD";

      case Status.InvalidSendRecordThreshold:
        return "INVALID_SEND_RECORD_THRESHOLD";

      case Status.AccountIsNotGenesisAccount:
        return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";

      case Status.PayerAccountUnauthorized:
        return "PAYER_ACCOUNT_UNAUTHORIZED";

      case Status.InvalidFreezeTransactionBody:
        return "INVALID_FREEZE_TRANSACTION_BODY";

      case Status.FreezeTransactionBodyNotFound:
        return "FREEZE_TRANSACTION_BODY_NOT_FOUND";

      case Status.TransferListSizeLimitExceeded:
        return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";

      case Status.ResultSizeLimitExceeded:
        return "RESULT_SIZE_LIMIT_EXCEEDED";

      case Status.NotSpecialAccount:
        return "NOT_SPECIAL_ACCOUNT";

      case Status.ContractNegativeGas:
        return "CONTRACT_NEGATIVE_GAS";

      case Status.ContractNegativeValue:
        return "CONTRACT_NEGATIVE_VALUE";

      case Status.InvalidFeeFile:
        return "INVALID_FEE_FILE";

      case Status.InvalidExchangeRateFile:
        return "INVALID_EXCHANGE_RATE_FILE";

      case Status.InsufficientLocalCallGas:
        return "INSUFFICIENT_LOCAL_CALL_GAS";

      case Status.EntityNotAllowedToDelete:
        return "ENTITY_NOT_ALLOWED_TO_DELETE";

      case Status.AuthorizationFailed:
        return "AUTHORIZATION_FAILED";

      case Status.FileUploadedProtoInvalid:
        return "FILE_UPLOADED_PROTO_INVALID";

      case Status.FileUploadedProtoNotSavedToDisk:
        return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";

      case Status.FeeScheduleFilePartUploaded:
        return "FEE_SCHEDULE_FILE_PART_UPLOADED";

      case Status.ExchangeRateChangeLimitExceeded:
        return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";

      case Status.MaxContractStorageExceeded:
        return "MAX_CONTRACT_STORAGE_EXCEEDED";

      case Status.TransferAccountSameAsDeleteAccount:
        return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";

      case Status.TotalLedgerBalanceInvalid:
        return "TOTAL_LEDGER_BALANCE_INVALID";

      case Status.ExpirationReductionNotAllowed:
        return "EXPIRATION_REDUCTION_NOT_ALLOWED";

      case Status.MaxGasLimitExceeded:
        return "MAX_GAS_LIMIT_EXCEEDED";

      case Status.MaxFileSizeExceeded:
        return "MAX_FILE_SIZE_EXCEEDED";

      case Status.InvalidTopicId:
        return "INVALID_TOPIC_ID";

      case Status.InvalidAdminKey:
        return "INVALID_ADMIN_KEY";

      case Status.InvalidSubmitKey:
        return "INVALID_SUBMIT_KEY";

      case Status.Unauthorized:
        return "UNAUTHORIZED";

      case Status.InvalidTopicMessage:
        return "INVALID_TOPIC_MESSAGE";

      case Status.InvalidAutorenewAccount:
        return "INVALID_AUTORENEW_ACCOUNT";

      case Status.AutorenewAccountNotAllowed:
        return "AUTORENEW_ACCOUNT_NOT_ALLOWED";

      case Status.TopicExpired:
        return "TOPIC_EXPIRED";

      case Status.InvalidChunkNumber:
        return "INVALID_CHUNK_NUMBER";

      case Status.InvalidChunkTransactionId:
        return "INVALID_CHUNK_TRANSACTION_ID";

      case Status.AccountFrozenForToken:
        return "ACCOUNT_FROZEN_FOR_TOKEN";

      case Status.TokensPerAccountLimitExceeded:
        return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";

      case Status.InvalidTokenId:
        return "INVALID_TOKEN_ID";

      case Status.InvalidTokenDecimals:
        return "INVALID_TOKEN_DECIMALS";

      case Status.InvalidTokenInitialSupply:
        return "INVALID_TOKEN_INITIAL_SUPPLY";

      case Status.InvalidTreasuryAccountForToken:
        return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";

      case Status.InvalidTokenSymbol:
        return "INVALID_TOKEN_SYMBOL";

      case Status.TokenHasNoFreezeKey:
        return "TOKEN_HAS_NO_FREEZE_KEY";

      case Status.TransfersNotZeroSumForToken:
        return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";

      case Status.MissingTokenSymbol:
        return "MISSING_TOKEN_SYMBOL";

      case Status.TokenSymbolTooLong:
        return "TOKEN_SYMBOL_TOO_LONG";

      case Status.AccountKycNotGrantedForToken:
        return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";

      case Status.TokenHasNoKycKey:
        return "TOKEN_HAS_NO_KYC_KEY";

      case Status.InsufficientTokenBalance:
        return "INSUFFICIENT_TOKEN_BALANCE";

      case Status.TokenWasDeleted:
        return "TOKEN_WAS_DELETED";

      case Status.TokenHasNoSupplyKey:
        return "TOKEN_HAS_NO_SUPPLY_KEY";

      case Status.TokenHasNoWipeKey:
        return "TOKEN_HAS_NO_WIPE_KEY";

      case Status.InvalidTokenMintAmount:
        return "INVALID_TOKEN_MINT_AMOUNT";

      case Status.InvalidTokenBurnAmount:
        return "INVALID_TOKEN_BURN_AMOUNT";

      case Status.TokenNotAssociatedToAccount:
        return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";

      case Status.CannotWipeTokenTreasuryAccount:
        return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";

      case Status.InvalidKycKey:
        return "INVALID_KYC_KEY";

      case Status.InvalidWipeKey:
        return "INVALID_WIPE_KEY";

      case Status.InvalidFreezeKey:
        return "INVALID_FREEZE_KEY";

      case Status.InvalidSupplyKey:
        return "INVALID_SUPPLY_KEY";

      case Status.MissingTokenName:
        return "MISSING_TOKEN_NAME";

      case Status.TokenNameTooLong:
        return "TOKEN_NAME_TOO_LONG";

      case Status.InvalidWipingAmount:
        return "INVALID_WIPING_AMOUNT";

      case Status.TokenIsImmutable:
        return "TOKEN_IS_IMMUTABLE";

      case Status.TokenAlreadyAssociatedToAccount:
        return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";

      case Status.TransactionRequiresZeroTokenBalances:
        return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";

      case Status.AccountIsTreasury:
        return "ACCOUNT_IS_TREASURY";

      case Status.TokenIdRepeatedInTokenList:
        return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";

      case Status.TokenTransferListSizeLimitExceeded:
        return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";

      case Status.EmptyTokenTransferBody:
        return "EMPTY_TOKEN_TRANSFER_BODY";

      case Status.EmptyTokenTransferAccountAmounts:
        return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";

      case Status.InvalidScheduleId:
        return "INVALID_SCHEDULE_ID";

      case Status.ScheduleIsImmutable:
        return "SCHEDULE_IS_IMMUTABLE";

      case Status.InvalidSchedulePayerId:
        return "INVALID_SCHEDULE_PAYER_ID";

      case Status.InvalidScheduleAccountId:
        return "INVALID_SCHEDULE_ACCOUNT_ID";

      case Status.NoNewValidSignatures:
        return "NO_NEW_VALID_SIGNATURES";

      case Status.UnresolvableRequiredSigners:
        return "UNRESOLVABLE_REQUIRED_SIGNERS";

      case Status.UnparseableScheduledTransaction:
        return "UNPARSEABLE_SCHEDULED_TRANSACTION";

      case Status.UnschedulableTransaction:
        return "UNSCHEDULABLE_TRANSACTION";

      case Status.SomeSignaturesWereInvalid:
        return "SOME_SIGNATURES_WERE_INVALID";

      case Status.TransactionIdFieldNotAllowed:
        return "TRANSACTION_ID_FIELD_NOT_ALLOWED";

      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @internal
   * @param {number} code
   * @returns {Status}
   */


  static _fromCode(code) {
    switch (code) {
      case 0:
        return Status.Ok;

      case 1:
        return Status.InvalidTransaction;

      case 2:
        return Status.PayerAccountNotFound;

      case 3:
        return Status.InvalidNodeAccount;

      case 4:
        return Status.TransactionExpired;

      case 5:
        return Status.InvalidTransactionStart;

      case 6:
        return Status.InvalidTransactionDuration;

      case 7:
        return Status.InvalidSignature;

      case 8:
        return Status.MemoTooLong;

      case 9:
        return Status.InsufficientTxFee;

      case 10:
        return Status.InsufficientPayerBalance;

      case 11:
        return Status.DuplicateTransaction;

      case 12:
        return Status.Busy;

      case 13:
        return Status.NotSupported;

      case 14:
        return Status.InvalidFileId;

      case 15:
        return Status.InvalidAccountId;

      case 16:
        return Status.InvalidContractId;

      case 17:
        return Status.InvalidTransactionId;

      case 18:
        return Status.ReceiptNotFound;

      case 19:
        return Status.RecordNotFound;

      case 20:
        return Status.InvalidSolidityId;

      case 21:
        return Status.Unknown;

      case 22:
        return Status.Success;

      case 23:
        return Status.FailInvalid;

      case 24:
        return Status.FailFee;

      case 25:
        return Status.FailBalance;

      case 26:
        return Status.KeyRequired;

      case 27:
        return Status.BadEncoding;

      case 28:
        return Status.InsufficientAccountBalance;

      case 29:
        return Status.InvalidSolidityAddress;

      case 30:
        return Status.InsufficientGas;

      case 31:
        return Status.ContractSizeLimitExceeded;

      case 32:
        return Status.LocalCallModificationException;

      case 33:
        return Status.ContractRevertExecuted;

      case 34:
        return Status.ContractExecutionException;

      case 35:
        return Status.InvalidReceivingNodeAccount;

      case 37:
        return Status.AccountUpdateFailed;

      case 38:
        return Status.InvalidKeyEncoding;

      case 39:
        return Status.NullSolidityAddress;

      case 40:
        return Status.ContractUpdateFailed;

      case 41:
        return Status.InvalidQueryHeader;

      case 42:
        return Status.InvalidFeeSubmitted;

      case 43:
        return Status.InvalidPayerSignature;

      case 44:
        return Status.KeyNotProvided;

      case 45:
        return Status.InvalidExpirationTime;

      case 46:
        return Status.NoWaclKey;

      case 47:
        return Status.FileContentEmpty;

      case 48:
        return Status.InvalidAccountAmounts;

      case 49:
        return Status.EmptyTransactionBody;

      case 50:
        return Status.InvalidTransactionBody;

      case 51:
        return Status.InvalidSignatureTypeMismatchingKey;

      case 52:
        return Status.InvalidSignatureCountMismatchingKey;

      case 53:
        return Status.EmptyLiveHashBody;

      case 54:
        return Status.EmptyLiveHash;

      case 55:
        return Status.EmptyLiveHashKeys;

      case 56:
        return Status.InvalidLiveHashSize;

      case 57:
        return Status.EmptyQueryBody;

      case 58:
        return Status.EmptyLiveHashQuery;

      case 59:
        return Status.LiveHashNotFound;

      case 60:
        return Status.AccountIdDoesNotExist;

      case 61:
        return Status.LiveHashAlreadyExists;

      case 62:
        return Status.InvalidFileWacl;

      case 63:
        return Status.SerializationFailed;

      case 64:
        return Status.TransactionOversize;

      case 65:
        return Status.TransactionTooManyLayers;

      case 66:
        return Status.ContractDeleted;

      case 67:
        return Status.PlatformNotActive;

      case 68:
        return Status.KeyPrefixMismatch;

      case 69:
        return Status.PlatformTransactionNotCreated;

      case 70:
        return Status.InvalidRenewalPeriod;

      case 71:
        return Status.InvalidPayerAccountId;

      case 72:
        return Status.AccountDeleted;

      case 73:
        return Status.FileDeleted;

      case 74:
        return Status.AccountRepeatedInAccountAmounts;

      case 75:
        return Status.SettingNegativeAccountBalance;

      case 76:
        return Status.ObtainerRequired;

      case 77:
        return Status.ObtainerSameContractId;

      case 78:
        return Status.ObtainerDoesNotExist;

      case 79:
        return Status.ModifyingImmutableContract;

      case 80:
        return Status.FileSystemException;

      case 81:
        return Status.AutorenewDurationNotInRange;

      case 82:
        return Status.ErrorDecodingBytestring;

      case 83:
        return Status.ContractFileEmpty;

      case 84:
        return Status.ContractBytecodeEmpty;

      case 85:
        return Status.InvalidInitialBalance;

      case 86:
        return Status.InvalidReceiveRecordThreshold;

      case 87:
        return Status.InvalidSendRecordThreshold;

      case 88:
        return Status.AccountIsNotGenesisAccount;

      case 89:
        return Status.PayerAccountUnauthorized;

      case 90:
        return Status.InvalidFreezeTransactionBody;

      case 91:
        return Status.FreezeTransactionBodyNotFound;

      case 92:
        return Status.TransferListSizeLimitExceeded;

      case 93:
        return Status.ResultSizeLimitExceeded;

      case 94:
        return Status.NotSpecialAccount;

      case 95:
        return Status.ContractNegativeGas;

      case 96:
        return Status.ContractNegativeValue;

      case 97:
        return Status.InvalidFeeFile;

      case 98:
        return Status.InvalidExchangeRateFile;

      case 99:
        return Status.InsufficientLocalCallGas;

      case 100:
        return Status.EntityNotAllowedToDelete;

      case 101:
        return Status.AuthorizationFailed;

      case 102:
        return Status.FileUploadedProtoInvalid;

      case 103:
        return Status.FileUploadedProtoNotSavedToDisk;

      case 104:
        return Status.FeeScheduleFilePartUploaded;

      case 105:
        return Status.ExchangeRateChangeLimitExceeded;

      case 106:
        return Status.MaxContractStorageExceeded;

      case 107:
        return Status.TransferAccountSameAsDeleteAccount;

      case 108:
        return Status.TotalLedgerBalanceInvalid;

      case 110:
        return Status.ExpirationReductionNotAllowed;

      case 111:
        return Status.MaxGasLimitExceeded;

      case 112:
        return Status.MaxFileSizeExceeded;

      case 150:
        return Status.InvalidTopicId;

      case 155:
        return Status.InvalidAdminKey;

      case 156:
        return Status.InvalidSubmitKey;

      case 157:
        return Status.Unauthorized;

      case 158:
        return Status.InvalidTopicMessage;

      case 159:
        return Status.InvalidAutorenewAccount;

      case 160:
        return Status.AutorenewAccountNotAllowed;

      case 162:
        return Status.TopicExpired;

      case 163:
        return Status.InvalidChunkNumber;

      case 164:
        return Status.InvalidChunkTransactionId;

      case 165:
        return Status.AccountFrozenForToken;

      case 166:
        return Status.TokensPerAccountLimitExceeded;

      case 167:
        return Status.InvalidTokenId;

      case 168:
        return Status.InvalidTokenDecimals;

      case 169:
        return Status.InvalidTokenInitialSupply;

      case 170:
        return Status.InvalidTreasuryAccountForToken;

      case 171:
        return Status.InvalidTokenSymbol;

      case 172:
        return Status.TokenHasNoFreezeKey;

      case 173:
        return Status.TransfersNotZeroSumForToken;

      case 174:
        return Status.MissingTokenSymbol;

      case 175:
        return Status.TokenSymbolTooLong;

      case 176:
        return Status.AccountKycNotGrantedForToken;

      case 177:
        return Status.TokenHasNoKycKey;

      case 178:
        return Status.InsufficientTokenBalance;

      case 179:
        return Status.TokenWasDeleted;

      case 180:
        return Status.TokenHasNoSupplyKey;

      case 181:
        return Status.TokenHasNoWipeKey;

      case 182:
        return Status.InvalidTokenMintAmount;

      case 183:
        return Status.InvalidTokenBurnAmount;

      case 184:
        return Status.TokenNotAssociatedToAccount;

      case 185:
        return Status.CannotWipeTokenTreasuryAccount;

      case 186:
        return Status.InvalidKycKey;

      case 187:
        return Status.InvalidWipeKey;

      case 188:
        return Status.InvalidFreezeKey;

      case 189:
        return Status.InvalidSupplyKey;

      case 190:
        return Status.MissingTokenName;

      case 191:
        return Status.TokenNameTooLong;

      case 192:
        return Status.InvalidWipingAmount;

      case 193:
        return Status.TokenIsImmutable;

      case 194:
        return Status.TokenAlreadyAssociatedToAccount;

      case 195:
        return Status.TransactionRequiresZeroTokenBalances;

      case 196:
        return Status.AccountIsTreasury;

      case 197:
        return Status.TokenIdRepeatedInTokenList;

      case 198:
        return Status.TokenTransferListSizeLimitExceeded;

      case 199:
        return Status.EmptyTokenTransferBody;

      case 200:
        return Status.EmptyTokenTransferAccountAmounts;

      case 201:
        return Status.InvalidScheduleId;

      case 202:
        return Status.ScheduleIsImmutable;

      case 203:
        return Status.InvalidSchedulePayerId;

      case 204:
        return Status.InvalidScheduleAccountId;

      case 205:
        return Status.NoNewValidSignatures;

      case 206:
        return Status.UnresolvableRequiredSigners;

      case 207:
        return Status.UnparseableScheduledTransaction;

      case 208:
        return Status.UnschedulableTransaction;

      case 209:
        return Status.SomeSignaturesWereInvalid;

      case 210:
        return Status.TransactionIdFieldNotAllowed;
    }

    throw new Error(`(BUG) Status.fromCode() does not handle code: ${code}`);
  }
  /**
   * @returns {proto.ResponseCodeEnum}
   */


  valueOf() {
    return this._code;
  }

}
/*
 * The transaction passed the precheck validations.
 */


exports.default = Status;
Status.Ok = new Status(0);
/*
 * For any error not handled by specific error codes listed below.
 */

Status.InvalidTransaction = new Status(1);
/*
 * Payer account does not exist.
 */

Status.PayerAccountNotFound = new Status(2);
/*
 * Node Account provided does not match the node account of the node the
 * transaction was submitted to.
 */

Status.InvalidNodeAccount = new Status(3);
/*
 * Pre-Check error when TransactionValidStart + transactionValidDuration is
 * less than current consensus time.
 */

Status.TransactionExpired = new Status(4);
/*
 * Transaction start time is greater than current consensus time
 */

Status.InvalidTransactionStart = new Status(5);
/*
 * Valid transaction duration is a positive non zero number that does not
 * exceed 120 seconds
 */

Status.InvalidTransactionDuration = new Status(6);
/*
 * The transaction signature is not valid
 */

Status.InvalidSignature = new Status(7);
/*
 * Transaction memo size exceeded 100 bytes
 */

Status.MemoTooLong = new Status(8);
/*
 * The fee provided in the transaction is insufficient for this
 * type of transaction
 */

Status.InsufficientTxFee = new Status(9);
/*
 * The payer account has insufficient cryptocurrency to pay the
 * transaction fee
 */

Status.InsufficientPayerBalance = new Status(10);
/*
 * This transaction ID is a duplicate of one that was submitted to this node
 * Or reached consensus in the last 180 seconds (receipt period)
 */

Status.DuplicateTransaction = new Status(11);
/*
 * If API is throttled out
 */

Status.Busy = new Status(12);
/*
 * The API is not currently supported
 */

Status.NotSupported = new Status(13);
/*
 * The file id is invalid or does not exist
 */

Status.InvalidFileId = new Status(14);
/*
 * The account id is invalid or does not exist
 */

Status.InvalidAccountId = new Status(15);
/*
 * The contract id is invalid or does not exist
 */

Status.InvalidContractId = new Status(16);
/*
 * Transaction id is not valid
 */

Status.InvalidTransactionId = new Status(17);
/*
 * Receipt for given transaction id does not exist
 */

Status.ReceiptNotFound = new Status(18);
/*
 * Record for given transaction id does not exist
 */

Status.RecordNotFound = new Status(19);
/*
 * The solidity id is invalid or entity with this solidity id does not exist
 */

Status.InvalidSolidityId = new Status(20);
/*
 * The responding node has submitted the transaction to the network.
 * its final status is still unknown.
 */

Status.Unknown = new Status(21);
/*
 * The transaction succeeded
 */

Status.Success = new Status(22);
/*
 * There was a system error and the transaction failed because of invalid
 * request parameters.
 */

Status.FailInvalid = new Status(23);
/*
 * There was a system error while performing fee calculation,
 * reserved for future.
 */

Status.FailFee = new Status(24);
/*
 * There was a system error while performing balance checks,
 * reserved for future.
 */

Status.FailBalance = new Status(25);
/*
 * Key not provided in the transaction body
 */

Status.KeyRequired = new Status(26);
/*
 * Unsupported algorithm/encoding used for keys in the transaction
 */

Status.BadEncoding = new Status(27);
/*
 * When the account balance is not sufficient for the transfer
 */

Status.InsufficientAccountBalance = new Status(28);
/*
 * During an update transaction when the system is not able to find the
 * users Solidity address
 */

Status.InvalidSolidityAddress = new Status(29);
/*
 * Not enough gas was supplied to execute transaction
 */

Status.InsufficientGas = new Status(30);
/*
 * Contract byte code size is over the limit
 */

Status.ContractSizeLimitExceeded = new Status(31);
/*
 * Local execution (query) is requested for a function which changes state
 */

Status.LocalCallModificationException = new Status(32);
/*
 * Contract REVERT OPCODE executed
 */

Status.ContractRevertExecuted = new Status(33);
/*
 * For any contract execution related error not handled by specific error
 * Codes listed above.
 */

Status.ContractExecutionException = new Status(34);
/*
 * In Query validation, account with +ve(amount) value should be receiving
 * node account, the receiver account should be only one account in the list
 */

Status.InvalidReceivingNodeAccount = new Status(35);
/*
 * Header is missing in Query request
 */

Status.MissingQueryHeader = new Status(36);
/*
 * The update of the account failed
 */

Status.AccountUpdateFailed = new Status(37);
/*
 * Provided key encoding was not supported by the system
 */

Status.InvalidKeyEncoding = new Status(38);
/*
 * Null solidity address
 */

Status.NullSolidityAddress = new Status(39);
/*
 * Update of the contract failed
 */

Status.ContractUpdateFailed = new Status(40);
/*
 * The query header is invalid
 */

Status.InvalidQueryHeader = new Status(41);
/*
 * Invalid fee submitted
 */

Status.InvalidFeeSubmitted = new Status(42);
/*
 * Payer signature is invalid
 */

Status.InvalidPayerSignature = new Status(43);
/*
 * The keys were not provided in the request.
 */

Status.KeyNotProvided = new Status(44);
/*
 * Expiration time provided in the transaction was invalid.
 */

Status.InvalidExpirationTime = new Status(45);
/*
 * WriteAccess Control Keys are not provided for the file
 */

Status.NoWaclKey = new Status(46);
/*
 * The contents of file are provided as empty.
 */

Status.FileContentEmpty = new Status(47);
/*
 * The crypto transfer credit and debit do not sum equal to 0
 */

Status.InvalidAccountAmounts = new Status(48);
/*
 * Transaction body provided is empty
 */

Status.EmptyTransactionBody = new Status(49);
/*
 * Invalid transaction body provided
 */

Status.InvalidTransactionBody = new Status(50);
/*
 * The type of key (base ed25519 key, KeyList, or ThresholdKey) does not
 * match the type of signature (base ed25519 signature, SignatureList, or
 * ThresholdKeySignature)
 */

Status.InvalidSignatureTypeMismatchingKey = new Status(51);
/*
 * The number of key (KeyList, or ThresholdKey) does not match that of
 * signature (SignatureList, or ThresholdKeySignature). e.g. if a keyList
 * has 3 base keys, then the corresponding signatureList should also have 3
 * base signatures.
 */

Status.InvalidSignatureCountMismatchingKey = new Status(52);
/*
 * The livehash body is empty
 */

Status.EmptyLiveHashBody = new Status(53);
/*
 * The livehash data is missing
 */

Status.EmptyLiveHash = new Status(54);
/*
 * The keys for a livehash are missing
 */

Status.EmptyLiveHashKeys = new Status(55);
/*
 * The livehash data is not the output of a SHA-384 digest
 */

Status.InvalidLiveHashSize = new Status(56);
/*
 * The query body is empty
 */

Status.EmptyQueryBody = new Status(57);
/*
 * The crypto livehash query is empty
 */

Status.EmptyLiveHashQuery = new Status(58);
/*
 * The livehash is not present
 */

Status.LiveHashNotFound = new Status(59);
/*
 * The account id passed has not yet been created.
 */

Status.AccountIdDoesNotExist = new Status(60);
/*
 * The livehash already exists for a given account
 */

Status.LiveHashAlreadyExists = new Status(61);
/*
 * File WACL keys are invalid
 */

Status.InvalidFileWacl = new Status(62);
/*
 * Serialization failure
 */

Status.SerializationFailed = new Status(63);
/*
 * The size of the Transaction is greater than transactionMaxBytes
 */

Status.TransactionOversize = new Status(64);
/*
 * The Transaction has more than 50 levels
 */

Status.TransactionTooManyLayers = new Status(65);
/*
 * Contract is marked as deleted
 */

Status.ContractDeleted = new Status(66);
/*
 * The platform node is either disconnected or lagging behind.
 */

Status.PlatformNotActive = new Status(67);
/*
 * One public key matches more than one prefixes on the signature map
 */

Status.KeyPrefixMismatch = new Status(68);
/*
 * Transaction not created by platform due to large backlog
 */

Status.PlatformTransactionNotCreated = new Status(69);
/*
 * Auto renewal period is not a positive number of seconds
 */

Status.InvalidRenewalPeriod = new Status(70);
/*
 * The response code when a smart contract id is passed for a
 * crypto API request
 */

Status.InvalidPayerAccountId = new Status(71);
/*
 * The account has been marked as deleted
 */

Status.AccountDeleted = new Status(72);
/*
 * The file has been marked as deleted
 */

Status.FileDeleted = new Status(73);
/*
 * Same accounts repeated in the transfer account list
 */

Status.AccountRepeatedInAccountAmounts = new Status(74);
/*
 * Attempting to set negative balance value for crypto account
 */

Status.SettingNegativeAccountBalance = new Status(75);
/*
 * When deleting smart contract that has crypto balance either transfer
 * account or transfer smart contract is required
 */

Status.ObtainerRequired = new Status(76);
/*
 * When deleting smart contract that has crypto balance you can not use the
 * same contract id as transferContractId as the one being deleted
 */

Status.ObtainerSameContractId = new Status(77);
/*
 * TransferAccountId or transferContractId specified for contract delete
 * does not exist
 */

Status.ObtainerDoesNotExist = new Status(78);
/*
 * Attempting to modify (update or delete a immutable smart contract, i.e.
 * one created without a admin key)
 */

Status.ModifyingImmutableContract = new Status(79);
/*
 * Unexpected exception thrown by file system functions
 */

Status.FileSystemException = new Status(80);
/*
 * The duration is not a subset of
 * [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
 */

Status.AutorenewDurationNotInRange = new Status(81);
/*
 * Decoding the smart contract binary to a byte array failed.
 * Check that the input is a valid hex string.
 */

Status.ErrorDecodingBytestring = new Status(82);
/*
 * File to create a smart contract was of length zero
 */

Status.ContractFileEmpty = new Status(83);
/*
 * Bytecode for smart contract is of length zero
 */

Status.ContractBytecodeEmpty = new Status(84);
/*
 * Attempt to set negative initial balance
 */

Status.InvalidInitialBalance = new Status(85);
/*
 * [Deprecated]. attempt to set negative receive record threshold
 */

Status.InvalidReceiveRecordThreshold = new Status(86);
/*
 * [Deprecated]. attempt to set negative send record threshold
 */

Status.InvalidSendRecordThreshold = new Status(87);
/*
 * Special Account Operations should be performed by only Genesis account,
 * return this code if it is not Genesis Account
 */

Status.AccountIsNotGenesisAccount = new Status(88);
/*
 * The fee payer account doesn't have permission to submit such Transaction
 */

Status.PayerAccountUnauthorized = new Status(89);
/*
 * FreezeTransactionBody is invalid
 */

Status.InvalidFreezeTransactionBody = new Status(90);
/*
 * FreezeTransactionBody does not exist
 */

Status.FreezeTransactionBodyNotFound = new Status(91);
/*
 * Exceeded the number of accounts (both from and to) allowed for
 * crypto transfer list
 */

Status.TransferListSizeLimitExceeded = new Status(92);
/*
 * Smart contract result size greater than specified maxResultSize
 */

Status.ResultSizeLimitExceeded = new Status(93);
/*
 * The payer account is not a special account(account 0.0.55)
 */

Status.NotSpecialAccount = new Status(94);
/*
 * Negative gas was offered in smart contract call
 */

Status.ContractNegativeGas = new Status(95);
/*
 * Negative value / initial balance was specified in a
 * smart contract call / create
 */

Status.ContractNegativeValue = new Status(96);
/*
 * Failed to update fee file
 */

Status.InvalidFeeFile = new Status(97);
/*
 * Failed to update exchange rate file
 */

Status.InvalidExchangeRateFile = new Status(98);
/*
 * Payment tendered for contract local call cannot cover both the
 * fee and the gas
 */

Status.InsufficientLocalCallGas = new Status(99);
/*
 * Entities with Entity ID below 1000 are not allowed to be deleted
 */

Status.EntityNotAllowedToDelete = new Status(100);
/*
 * Violating one of these rules:
 * 1) treasury account can update all entities below 0.0.1000,
 * 2) account 0.0.50 can update all entities from 0.0.51 - 0.0.80,
 * 3) Network Function Master Account A/c 0.0.50
 *    - Update all Network Function accounts & perform all the Network
 *      Functions listed below,
 * 4) Network Function Accounts:
 *   i) A/c 0.0.55
 *     - Update Address Book files (0.0.101/102),
 *   ii) A/c 0.0.56
 *     - Update Fee schedule (0.0.111),
 *   iii) A/c 0.0.57
 *     - Update Exchange Rate (0.0.112).
 */

Status.AuthorizationFailed = new Status(101);
/*
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */

Status.FileUploadedProtoInvalid = new Status(102);
/*
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */

Status.FileUploadedProtoNotSavedToDisk = new Status(103);
/*
 * Fee Schedule Proto File Part uploaded
 */

Status.FeeScheduleFilePartUploaded = new Status(104);
/*
 * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
 */

Status.ExchangeRateChangeLimitExceeded = new Status(105);
/*
 * Contract permanent storage exceeded the currently allowable limit
 */

Status.MaxContractStorageExceeded = new Status(106);
/*
 * Transfer Account should not be same as Account to be deleted
 */

Status.TransferAccountSameAsDeleteAccount = new Status(107);
Status.TotalLedgerBalanceInvalid = new Status(108);
/*
 * The expiration date/time on a smart contract may not be reduced
 */

Status.ExpirationReductionNotAllowed = new Status(110);
/*
 * Gas exceeded currently allowable gas limit per transaction
 */

Status.MaxGasLimitExceeded = new Status(111);
/*
 * File size exceeded the currently allowable limit
 */

Status.MaxFileSizeExceeded = new Status(112);
/*
 * The Topic ID specified is not in the system.
 */

Status.InvalidTopicId = new Status(150);
/*
 * A provided admin key was invalid.
 */

Status.InvalidAdminKey = new Status(155);
/*
 * A provided submit key was invalid.
 */

Status.InvalidSubmitKey = new Status(156);
/*
 * An attempted operation was not authorized (ie - a deleteTopic for a topic
 * with no adminKey).
 */

Status.Unauthorized = new Status(157);
/*
 * A ConsensusService message is empty.
 */

Status.InvalidTopicMessage = new Status(158);
/*
 * The autoRenewAccount specified is not a valid, active account.
 */

Status.InvalidAutorenewAccount = new Status(159);
/*
 * An adminKey was not specified on the topic, so there must not be an
 * autoRenewAccount.
 */

Status.AutorenewAccountNotAllowed = new Status(160);
/*
 * The topic has expired, was not automatically renewed, and is in a 7 day
 * grace period before the topic will be Deleted unrecoverably. This error
 * response code will not be returned until autoRenew functionality is
 * supported By HAPI.
 */

Status.TopicExpired = new Status(162);
/*
 * Chunk number must be from 1 to total (chunks) inclusive.
 */

Status.InvalidChunkNumber = new Status(163);
/*
 * For every chunk, the payer account that is part of initialTransactionID
 * must match the Payer Account of this transaction. The entire
 * initialTransactionID should match the transactionID of the first chunk,
 * but this is not checked or enforced by Hedera except when the chunk
 * number is 1.
 */

Status.InvalidChunkTransactionId = new Status(164);
/*
 * Account is frozen and cannot transact with the token
 */

Status.AccountFrozenForToken = new Status(165);
/*
 * An involved account already has more than <tt>tokens.maxPerAccount</tt>
 * associations with non-deleted tokens.
 */

Status.TokensPerAccountLimitExceeded = new Status(166);
/*
 * The token is invalid or does not exist
 */

Status.InvalidTokenId = new Status(167);
/*
 * Invalid token decimals
 */

Status.InvalidTokenDecimals = new Status(168);
/*
 * Invalid token initial supply
 */

Status.InvalidTokenInitialSupply = new Status(169);
/*
 * Treasury Account does not exist or is deleted
 */

Status.InvalidTreasuryAccountForToken = new Status(170);
/*
 * Token Symbol is not UTF-8 capitalized alphabetical string
 */

Status.InvalidTokenSymbol = new Status(171);
/*
 * Freeze key is not set on token
 */

Status.TokenHasNoFreezeKey = new Status(172);
/*
 * Amounts in transfer list are not net zero
 */

Status.TransfersNotZeroSumForToken = new Status(173);
/*
 * A token symbol was not provided
 */

Status.MissingTokenSymbol = new Status(174);
/*
 * The provided token symbol was too long
 */

Status.TokenSymbolTooLong = new Status(175);
/*
 * KYC must be granted and account does not have KYC granted
 */

Status.AccountKycNotGrantedForToken = new Status(176);
/*
 * KYC key is not set on token
 */

Status.TokenHasNoKycKey = new Status(177);
/*
 * Token balance is not sufficient for the transaction
 */

Status.InsufficientTokenBalance = new Status(178);
/*
 * Token transactions cannot be executed on deleted token
 */

Status.TokenWasDeleted = new Status(179);
/*
 * Supply key is not set on token
 */

Status.TokenHasNoSupplyKey = new Status(180);
/*
 * Wipe key is not set on token
 */

Status.TokenHasNoWipeKey = new Status(181);
/*
 * The requested token mint amount would cause an invalid total supply
 */

Status.InvalidTokenMintAmount = new Status(182);
/*
 * The requested token burn amount would cause an invalid total supply
 */

Status.InvalidTokenBurnAmount = new Status(183);
/*
 * A required token-account relationship is missing
 */

Status.TokenNotAssociatedToAccount = new Status(184);
/*
 * The target of a wipe operation was the token treasury account
 */

Status.CannotWipeTokenTreasuryAccount = new Status(185);
/*
 * The provided KYC key was invalid.
 */

Status.InvalidKycKey = new Status(186);
/*
 * The provided wipe key was invalid.
 */

Status.InvalidWipeKey = new Status(187);
/*
 * The provided freeze key was invalid.
 */

Status.InvalidFreezeKey = new Status(188);
/*
 * The provided supply key was invalid.
 */

Status.InvalidSupplyKey = new Status(189);
/*
 * Token Name is not provided
 */

Status.MissingTokenName = new Status(190);
/*
 * Token Name is too long
 */

Status.TokenNameTooLong = new Status(191);
/*
 * The provided wipe amount must not be negative, zero or bigger than the
 * token holder balance
 */

Status.InvalidWipingAmount = new Status(192);
/*
 * Token does not have Admin key set, thus update/delete transactions cannot
 * be performed
 */

Status.TokenIsImmutable = new Status(193);
/*
 * An <tt>associateToken</tt> operation specified a token already associated
 * to the account
 */

Status.TokenAlreadyAssociatedToAccount = new Status(194);
/*
 * An attempted operation is invalid until all token balances for the target
 * account are zero
 */

Status.TransactionRequiresZeroTokenBalances = new Status(195);
/*
 * An attempted operation is invalid because the account is a treasury
 */

Status.AccountIsTreasury = new Status(196);
/*
 * Same TokenIDs present in the token list
 */

Status.TokenIdRepeatedInTokenList = new Status(197);
/*
 * Exceeded the number of token transfers (both from and to) allowed for
 * token transfer list
 */

Status.TokenTransferListSizeLimitExceeded = new Status(198);
/*
 * TokenTransfersTransactionBody has no TokenTransferList
 */

Status.EmptyTokenTransferBody = new Status(199);
/*
 * TokenTransfersTransactionBody has a TokenTransferList with
 * no AccountAmounts
 */

Status.EmptyTokenTransferAccountAmounts = new Status(200);
/*
 * The Scheduled entity does not exist; or has now expired, been deleted, or
 * been executed
 */

Status.InvalidScheduleId = new Status(201);
/*
 * The Scheduled entity cannot be modified. Admin key not set
 */

Status.ScheduleIsImmutable = new Status(202);
/*
 * The provided Scheduled Payer does not exist
 */

Status.InvalidSchedulePayerId = new Status(203);
/*
 * The Schedule Create Transaction TransactionID account does not exist
 */

Status.InvalidScheduleAccountId = new Status(204);
/*
 * The provided sig map did not contain any new valid signatures from
 * required signers of the scheduled transaction
 */

Status.NoNewValidSignatures = new Status(205);
/*
 * The required signers for a scheduled transaction cannot be resolved, for
 * example because they do not exist or have been deleted
 */

Status.UnresolvableRequiredSigners = new Status(206);
/*
 * The bytes allegedly representing a transaction to be scheduled could not
 * be parsed
 */

Status.UnparseableScheduledTransaction = new Status(207);
/*
 * ScheduleCreate and ScheduleSign transactions cannot be scheduled
 */

Status.UnschedulableTransaction = new Status(208);
/*
 * At least one of the signatures in the provided sig map did not represent
 * a valid signature for any required signer
 */

Status.SomeSignaturesWereInvalid = new Status(209);
/*
 * The <tt>scheduled</tt> and <tt>nonce</tt> fields in the
 * <tt>TransactionID</tt> may not be set in a top-level transaction
 */

Status.TransactionIdFieldNotAllowed = new Status(210);

/***/ }),

/***/ 3325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */
class StatusError extends Error {
  /**
   * @param {object} props
   * @param {Status} props.status
   * @param {TransactionId} props.transactionId
   * @param {string} message
   */
  constructor(props, message) {
    super(message);
    this.name = "StatusError";
    this.status = props.status;
    this.transactionId = props.transactionId;
    this.message = message;

    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, StatusError);
    }
  }

}

exports.default = StatusError;

/***/ }),

/***/ 351:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 */
const MAX_NS = _long.default.fromNumber(1000000000);

class Timestamp {
  /**
   * @param {Long | number} seconds
   * @param {Long | number} nanos
   */
  constructor(seconds, nanos) {
    /**
     * @readonly
     * @type {Long}
     */
    this.seconds = seconds instanceof _long.default ? seconds : _long.default.fromNumber(seconds);
    /**
     * @readonly
     * @type {Long}
     */

    this.nanos = nanos instanceof _long.default ? nanos : _long.default.fromNumber(nanos);
    Object.freeze(this);
  }
  /**
   * @returns {Timestamp}
   */


  static generate() {
    const jitter = Math.floor(Math.random() * 5000) + 8000;
    const now = Date.now() - jitter;
    const seconds = Math.floor(now / 1000);
    const nanos = Math.floor(now % 1000) * 1000000 + Math.floor(Math.random() * 1000000);
    return new Timestamp(seconds, nanos);
  }
  /**
   * @param {string | number | Date} date
   * @returns {Timestamp}
   */


  static fromDate(date) {
    let ms;

    if (typeof date === "number") {
      ms = date;
    } else if (typeof date === "string") {
      ms = Date.parse(date);
    } else if (date instanceof Date) {
      ms = date.getTime();
    } else {
      throw new TypeError(`invalid type '${typeof date}' for 'data', expected 'Date'`);
    }

    const seconds = Math.floor(ms / 1000);
    const nanos = Math.floor(ms % 1000) * 1000000;
    return new Timestamp(seconds, nanos);
  }
  /**
   * @returns {Date}
   */


  toDate() {
    return new Date(this.seconds.toInt() * 1000 + Math.floor(this.nanos.toInt() / 1000000));
  }
  /**
   * @param {Long | number} nanos
   * @returns {Timestamp}
   */


  plusNanos(nanos) {
    const ns = this.nanos.add(nanos);
    return new Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
  }
  /**
   * @internal
   * @returns {proto.ITimestamp}
   */


  _toProtobuf() {
    return {
      seconds: this.seconds,
      nanos: this.nanos.toInt()
    };
  }
  /**
   * @internal
   * @param {proto.ITimestamp} timestamp
   * @returns {Timestamp}
   */


  static _fromProtobuf(timestamp) {
    return new Timestamp(timestamp.seconds instanceof _long.default ? timestamp.seconds.toInt() : timestamp.seconds != null ? timestamp.seconds : 0, timestamp.nanos != null ? timestamp.nanos : 0);
  }

}

exports.default = Timestamp;

/***/ }),

/***/ 5199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("long")} Long
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
class Transfer {
  /**
   * @internal
   * @param {object} props
   * @param {AccountId | string} props.accountId
   * @param {number | string | Long | BigNumber | Hbar} props.amount
   */
  constructor(props) {
    /**
     * The Account ID that sends or receives cryptocurrency.
     *
     * @readonly
     */
    this.accountId = props.accountId instanceof _AccountId.default ? props.accountId : _AccountId.default.fromString(props.accountId);
    /**
     * The amount of tinybars that the account sends(negative) or receives(positive).
     *
     * @readonly
     */

    this.amount = props.amount instanceof _Hbar.default ? props.amount : new _Hbar.default(props.amount);
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IAccountAmount} transfer
   * @param {(string | null)=} ledgerId
   * @returns {Transfer}
   */


  static _fromProtobuf(transfer, ledgerId) {
    return new Transfer({
      accountId: _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      transfer.accountID, ledgerId),
      amount: _Hbar.default.fromTinybars(transfer.amount != null ? transfer.amount : 0)
    });
  }
  /**
   * @internal
   * @returns {proto.IAccountAmount}
   */


  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars()
    };
  }

}

exports.default = Transfer;

/***/ }),

/***/ 4140:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _TokenBalanceMap = _interopRequireDefault(__nccwpck_require__(9641));

var _TokenDecimalMap = _interopRequireDefault(__nccwpck_require__(6880));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceResponse} proto.ICryptoGetAccountBalanceResponse
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 */

/**
 * @typedef {object} TokenBalanceJson
 * @property {string} tokenId
 * @property {string} balance
 * @property {number} decimals
 */

/**
 * @typedef {object} AccountBalanceJson
 * @property {string} hbars
 * @property {TokenBalanceJson[]} tokens
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */
class AccountBalance {
  /**
   * @private
   * @param {object} props
   * @param {Hbar} props.hbars
   * @param {?TokenBalanceMap} props.tokens
   * @param {?TokenDecimalMap} props.tokenDecimals
   */
  constructor(props) {
    /**
     * The account ID for which this balancermation applies.
     *
     * @readonly
     */
    this.hbars = props.hbars;
    /** @readonly */

    this.tokens = props.tokens;
    /** @readonly */

    this.tokenDecimals = props.tokenDecimals;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.ICryptoGetAccountBalanceResponse} accountBalance
   * @param {(string | null)=} ledgerId
   * @returns {AccountBalance}
   */


  static _fromProtobuf(accountBalance, ledgerId) {
    const tokenBalances = new _TokenBalanceMap.default();
    const tokenDecimals = new _TokenDecimalMap.default();

    if (accountBalance.tokenBalances != null) {
      for (const balance of accountBalance.tokenBalances) {
        const tokenId = _TokenId.default._fromProtobuf(
        /** @type {proto.ITokenID} */
        balance.tokenId, ledgerId);

        tokenDecimals._set(tokenId, balance.decimals != null ? balance.decimals : 0);

        tokenBalances._set(tokenId, _long.default.fromValue(
        /** @type {Long} */
        balance.balance));
      }
    }

    return new AccountBalance({
      hbars: _Hbar.default.fromTinybars(
      /** @type {Long} */
      accountBalance.balance),
      tokens: tokenBalances,
      tokenDecimals
    });
  }
  /**
   * @returns {proto.ICryptoGetAccountBalanceResponse}
   */


  _toProtobuf() {
    /** @type {proto.ITokenBalance[]} */
    const list = [];

    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      list.push({
        tokenId: key._toProtobuf(),
        balance: value,
        decimals: this.tokenDecimals != null ? this.tokenDecimals.get(key) : null
      });
    }

    return {
      balance: this.hbars.toTinybars(),
      tokenBalances: list
    };
  }
  /**
   * @returns {string}
   */


  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @returns {AccountBalanceJson}
   */


  toJSON() {
    const tokens = [];

    for (const [key, value] of this.tokens != null ? this.tokens : []) {
      const decimals = this.tokenDecimals != null ? this.tokenDecimals.get(key) : null;
      tokens.push({
        tokenId: key.toString(),
        balance: value.toString(),
        decimals: decimals != null ? decimals : 0
      });
    }

    return {
      hbars: this.hbars.toString(),
      tokens
    };
  }

}

exports.default = AccountBalance;

/***/ }),

/***/ 7757:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _AccountBalance = _interopRequireDefault(__nccwpck_require__(4140));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceQuery} proto.ICryptoGetAccountBalanceQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceResponse} proto.ICryptoGetAccountBalanceResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get the balance of a Hedera crypto-currency account.
 *
 * This returns only the balance, so its a smaller and faster reply
 * than AccountInfoQuery.
 *
 * This query is free.
 *
 * @augments {Query<AccountBalance>}
 */
class AccountBalanceQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?AccountId}
     * @private
     */

    this._accountId = null;
    /**
     * @type {?ContractId}
     * @private
     */

    this._contractId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {AccountBalanceQuery}
   */


  static _fromProtobuf(query) {
    const balance =
    /** @type {proto.ICryptoGetAccountBalanceQuery} */
    query.cryptogetAccountBalance;
    return new AccountBalanceQuery({
      accountId: balance.accountID != null ? _AccountId.default._fromProtobuf(balance.accountID) : undefined,
      contractId: balance.contractID != null ? _ContractId.default._fromProtobuf(balance.contractID) : undefined
    });
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the balance is being requested.
   *
   * This is mutually exclusive with `setContractId`.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the balance is being requested.
   *
   * This is mutually exclusive with `setAccountId`.
   *
   * @param {ContractId | string} contractId
   * @returns {this}
   */


  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @protected
   * @override
   * @returns {boolean}
   */


  _isPaymentRequired() {
    return false;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }

    if (this._contractId != null) {
      this._contractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.cryptoGetBalance(request);
  }
  /**
   * @override
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const cryptogetAccountBalance =
    /** @type {proto.ICryptoGetAccountBalanceResponse} */
    response.cryptogetAccountBalance;
    return (
      /** @type {proto.IResponseHeader} */
      cryptogetAccountBalance.header
    );
  }
  /**
   * @override
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<AccountBalance>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const cryptogetAccountBalance =
    /** @type {proto.ICryptoGetAccountBalanceResponse} */
    response.cryptogetAccountBalance;
    return Promise.resolve(_AccountBalance.default._fromProtobuf(cryptogetAccountBalance, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      cryptogetAccountBalance: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }

}

exports.default = AccountBalanceQuery;

_Query.QUERY_REGISTRY.set("cryptogetAccountBalance", // eslint-disable-next-line @typescript-eslint/unbound-method
AccountBalanceQuery._fromProtobuf);

/***/ }),

/***/ 67:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoCreateTransactionBody} proto.ICryptoCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class AccountCreateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {Key} [props.key]
   * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
   * @param {boolean} [props.receiverSignatureRequired]
   * @param {AccountId} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.accountMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Key}
     */

    this._key = null;
    /**
     * @private
     * @type {?Hbar}
     */

    this._initialBalance = null;
    /**
     * @private
     * @type {Hbar}
     */

    this._sendRecordThreshold = _Transaction.DEFAULT_RECORD_THRESHOLD;
    /**
     * @private
     * @type {Hbar}
     */

    this._receiveRecordThreshold = _Transaction.DEFAULT_RECORD_THRESHOLD;
    /**
     * @private
     * @type {boolean}
     */

    this._receiverSignatureRequired = false;
    /**
     * @private
     * @type {?AccountId}
     */

    this._proxyAccountId = null;
    /**
     * @private
     * @type {Duration}
     */

    this._autoRenewPeriod = new _Duration.default(_Transaction.DEFAULT_AUTO_RENEW_PERIOD);
    /**
     * @private
     * @type {?string}
     */

    this._accountMemo = null;

    if (props.key != null) {
      this.setKey(props.key);
    }

    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }

    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }

    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {AccountCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.ICryptoCreateTransactionBody} */
    body.cryptoCreateAccount;
    return _Transaction.default._fromProtobufTransactions(new AccountCreateTransaction({
      key: create.key != null ? (0, _protobuf.keyFromProtobuf)(create.key) : undefined,
      initialBalance: create.initialBalance != null ? create.initialBalance : undefined,
      receiverSignatureRequired: create.receiverSigRequired != null ? create.receiverSigRequired : undefined,
      proxyAccountId: create.proxyAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      create.proxyAccountID) : undefined,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : undefined : undefined,
      accountMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?Key}
   */


  get key() {
    return this._key;
  }
  /**
   * Set the key for this account.
   *
   * This is the key that must sign each transfer out of the account.
   *
   * If `receiverSignatureRequired` is true, then the key must also sign
   * any transfer into the account.
   *
   * @param {Key} key
   * @returns {this}
   */


  setKey(key) {
    this._requireNotFrozen();

    this._key = key;
    return this;
  }
  /**
   * @returns {?Hbar}
   */


  get initialBalance() {
    return this._initialBalance;
  }
  /**
   * Set the initial amount to transfer into this account.
   *
   * @param {number | string | Long | BigNumber | Hbar} initialBalance
   * @returns {this}
   */


  setInitialBalance(initialBalance) {
    this._requireNotFrozen();

    this._initialBalance = initialBalance instanceof _Hbar.default ? initialBalance : new _Hbar.default(initialBalance);
    return this;
  }
  /**
   * @returns {boolean}
   */


  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  /**
   * Set to true to require the key for this account to sign any transfer of
   * hbars to this account.
   *
   * @param {boolean} receiverSignatureRequired
   * @returns {this}
   */


  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();

    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * Set the ID of the account to which this account is proxy staked.
   *
   * @param {AccountId} proxyAccountId
   * @returns {this}
   */


  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();

    this._proxyAccountId = proxyAccountId;
    return this;
  }
  /**
   * @returns {Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */


  get accountMemo() {
    return this._accountMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setAccountMemo(memo) {
    this._requireNotFrozen();

    this._accountMemo = memo;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._proxyAccountId != null) {
      this._proxyAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.createAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoCreateAccount";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoCreateTransactionBody}
   */


  _makeTransactionData() {
    return {
      key: this._key != null ? (0, _protobuf.keyToProtobuf)(this._key) : null,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
      sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
      receiverSigRequired: this._receiverSignatureRequired,
      memo: this._accountMemo
    };
  }

}

exports.default = AccountCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoCreateAccount", // eslint-disable-next-line @typescript-eslint/unbound-method
AccountCreateTransaction._fromProtobuf);

/***/ }),

/***/ 9913:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoDeleteTransactionBody} proto.ICryptoDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Marks an account as deleted, moving all its current hbars to another account.
 *
 * It will remain in the ledger, marked as deleted, until it expires.
 * Transfers into it a deleted account fail. But a deleted account can still have its
 * expiration extended in the normal way.
 */
class AccountDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {AccountId} [props.accountId]
   * @param {AccountId} [props.transferAccountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._transferAccountId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }

    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {AccountDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const accountDelete =
    /** @type {proto.ICryptoDeleteTransactionBody} */
    body.cryptoDelete;
    return _Transaction.default._fromProtobufTransactions(new AccountDeleteTransaction({
      accountId: accountDelete.deleteAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      accountDelete.deleteAccountID) : undefined,
      transferAccountId: accountDelete.transferAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      accountDelete.transferAccountID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID which is being deleted in this transaction.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountDeleteTransaction}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get transferAccountId() {
    return this._transferAccountId;
  }
  /**
   * Set the account ID which will receive all remaining hbars.
   *
   * @param {AccountId | string} transferAccountId
   * @returns {AccountDeleteTransaction}
   */


  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();

    this._transferAccountId = typeof transferAccountId === "string" ? _AccountId.default.fromString(transferAccountId) : transferAccountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }

    if (this._transferAccountId != null) {
      this._transferAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.cryptoDelete(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoDelete";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      deleteAccountID: this._accountId != null ? this._accountId._toProtobuf() : null,
      transferAccountID: this._transferAccountId != null ? this._transferAccountId._toProtobuf() : null
    };
  }

}

exports.default = AccountDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoDelete", // eslint-disable-next-line @typescript-eslint/unbound-method
AccountDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 7776:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency account on Hedera.
 */
class AccountId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {AccountId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new AccountId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.IAccountID} id
   * @param {(string | null)=} ledgerId
   * @returns {AccountId}
   */


  static _fromProtobuf(id, ledgerId) {
    const accountId = new AccountId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.accountNum != null ? id.accountNum : 0);

    if (ledgerId != null) {
      accountId._setNetwork(ledgerId);
    }

    return accountId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AccountId}
   */


  static fromBytes(bytes) {
    return AccountId._fromProtobuf(proto.AccountID.decode(bytes));
  }
  /**
   * @param {string} address
   * @returns {AccountId}
   */


  static fromSolidityAddress(address) {
    return new AccountId(...entity_id.fromSolidityAddress(address));
  }
  /**
   * @internal
   * @override
   * @returns {proto.IAccountID}
   */


  _toProtobuf() {
    return {
      accountNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.AccountID.encode(this._toProtobuf()).finish();
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @param {this} other
   * @returns {boolean}
   */


  equals(other) {
    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && this.num.eq(other.num);
  }
  /**
   * @returns {AccountId}
   */


  clone() {
    const id = new AccountId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = AccountId;

/***/ }),

/***/ 8065:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _LiveHash = _interopRequireDefault(__nccwpck_require__(9367));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _protobuf = __nccwpck_require__(223);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _TokenRelationshipMap = _interopRequireDefault(__nccwpck_require__(5985));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */

/**
 * Current information about an account, including the balance.
 */
class AccountInfo {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {?string} props.contractAccountId
   * @param {boolean} props.isDeleted
   * @param {?AccountId} props.proxyAccountId
   * @param {Hbar} props.proxyReceived
   * @param {Key} props.key
   * @param {Hbar} props.balance
   * @param {Hbar} props.sendRecordThreshold
   * @param {Hbar} props.receiveRecordThreshold
   * @param {boolean} props.isReceiverSignatureRequired
   * @param {Timestamp} props.expirationTime
   * @param {Duration} props.autoRenewPeriod
   * @param {LiveHash[]} props.liveHashes
   * @param {TokenRelationshipMap} props.tokenRelationships
   * @param {string} props.accountMemo
   */
  constructor(props) {
    /**
     * The account ID for which this information applies.
     *
     * @readonly
     */
    this.accountId = props.accountId;
    /**
     * The Contract Account ID comprising of both the contract instance and the cryptocurrency
     * account owned by the contract instance, in the format used by Solidity.
     *
     * @readonly
     */

    this.contractAccountId = props.contractAccountId;
    /**
     * If true, then this account has been deleted, it will disappear when it expires, and
     * all transactions for it will fail except the transaction to extend its expiration date.
     *
     * @readonly
     */

    this.isDeleted = props.isDeleted;
    /**
     * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
     * or is an invalid account, or is an account that isn't a node, then this account is
     * automatically proxy staked to a node chosen by the network, but without earning payments.
     * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
     * running a node, then it will behave as if proxyAccountID was null.
     *
     * @readonly
     */

    this.proxyAccountId = props.proxyAccountId;
    /**
     * The total number of tinybars proxy staked to this account.
     *
     * @readonly
     */

    this.proxyReceived = props.proxyReceived;
    /**
     * The key for the account, which must sign in order to transfer out, or to modify the account
     * in any way other than extending its expiration date.
     *
     * @readonly
     */

    this.key = props.key;
    /**
     * The current balance of account.
     *
     * @readonly
     */

    this.balance = props.balance;
    /**
     * The threshold amount (in tinybars) for which an account record is created (and this account
     * charged for them) for any send/withdraw transaction.
     *
     * @readonly
     */

    this.sendRecordThreshold = props.sendRecordThreshold;
    /**
     * The threshold amount (in tinybars) for which an account record is created
     * (and this account charged for them) for any transaction above this amount.
     *
     * @readonly
     */

    this.receiveRecordThreshold = props.receiveRecordThreshold;
    /**
     * If true, no transaction can transfer to this account unless signed by this account's key.
     *
     * @readonly
     */

    this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;
    /**
     * The TimeStamp time at which this account is set to expire.
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     * The duration for expiration time will extend every this many seconds. If there are
     * insufficient funds, then it extends as long as possible. If it is empty when it
     * expires, then it is deleted.
     *
     * @readonly
     */

    this.autoRenewPeriod = props.autoRenewPeriod;
    /** @readonly */

    this.liveHashes = props.liveHashes;
    /** @readonly */

    this.tokenRelationships = props.tokenRelationships;
    this.accountMemo = props.accountMemo;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IAccountInfo} info
   * @param {(string | null)=} ledgerId
   * @returns {AccountInfo}
   */


  static _fromProtobuf(info, ledgerId) {
    return new AccountInfo({
      accountId: _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      info.accountID, ledgerId),
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : null,
      isDeleted: info.deleted != null ? info.deleted : false,
      key: (0, _protobuf.keyFromProtobuf)(
      /** @type {proto.IKey} */
      info.key, ledgerId),
      balance: _Hbar.default.fromTinybars(info.balance != null ? info.balance : 0),
      sendRecordThreshold: _Hbar.default.fromTinybars(info.generateSendRecordThreshold != null ? info.generateSendRecordThreshold : 0),
      receiveRecordThreshold: _Hbar.default.fromTinybars(info.generateReceiveRecordThreshold != null ? info.generateReceiveRecordThreshold : 0),
      isReceiverSignatureRequired: info.receiverSigRequired != null ? info.receiverSigRequired : false,
      expirationTime: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.expirationTime),
      autoRenewPeriod: info.autoRenewPeriod != null ? new _Duration.default(
      /** @type {Long} */
      info.autoRenewPeriod.seconds) : new _Duration.default(0),
      proxyAccountId: info.proxyAccountID != null && _long.default.fromValue(
      /** @type {Long | number} */
      info.proxyAccountID.shardNum).toInt() !== 0 && _long.default.fromValue(
      /** @type {Long | number} */
      info.proxyAccountID.realmNum).toInt() !== 0 && _long.default.fromValue(
      /** @type {Long | number} */
      info.proxyAccountID.accountNum).toInt() !== 0 ? _AccountId.default._fromProtobuf(info.proxyAccountID, ledgerId) : null,
      proxyReceived: _Hbar.default.fromTinybars(info.proxyReceived != null ? info.proxyReceived : 0),
      liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(hash => _LiveHash.default._fromProtobuf(hash, ledgerId)),
      tokenRelationships: _TokenRelationshipMap.default._fromProtobuf(info.tokenRelationships != null ? info.tokenRelationships : [], ledgerId),
      accountMemo: info.memo != null ? info.memo : ""
    });
  }
  /**
   * @returns {proto.IAccountInfo}
   */


  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      deleted: this.isDeleted,
      proxyAccountID: this.proxyAccountId != null ? this.proxyAccountId._toProtobuf() : null,
      proxyReceived: this.proxyReceived.toTinybars(),
      key: (0, _protobuf.keyToProtobuf)(this.key),
      balance: this.balance.toTinybars(),
      generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
      generateReceiveRecordThreshold: this.receiveRecordThreshold.toTinybars(),
      receiverSigRequired: this.isReceiverSignatureRequired,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
      liveHashes: this.liveHashes.map(hash => hash._toProtobuf()),
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null,
      memo: this.accountMemo
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AccountInfo}
   */


  static fromBytes(bytes) {
    return AccountInfo._fromProtobuf(proto.CryptoGetInfoResponse.AccountInfo.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.CryptoGetInfoResponse.AccountInfo.encode(this._toProtobuf()).finish();
  }

}

exports.default = AccountInfo;

/***/ }),

/***/ 6985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _AccountInfo = _interopRequireDefault(__nccwpck_require__(8065));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IAccountInfo} proto.IAccountInfo
 * @typedef {import("@hashgraph/proto").ICryptoGetInfoQuery} proto.ICryptoGetInfoQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetInfoResponse} proto.ICryptoGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<AccountInfo>}
 */
class AccountInfoQuery extends _Query.default {
  /**
   * @param {object} props
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {AccountInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.ICryptoGetInfoQuery} */
    query.cryptoGetInfo;
    return new AccountInfoQuery({
      accountId: info.accountID != null ? _AccountId.default._fromProtobuf(info.accountID) : undefined
    });
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the info is being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountInfoQuery}
   */


  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getAccountInfo(request);
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const cryptoGetInfo =
    /** @type {proto.ICryptoGetInfoResponse} */
    response.cryptoGetInfo;
    return (
      /** @type {proto.IResponseHeader} */
      cryptoGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<AccountInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const info =
    /** @type {proto.ICryptoGetInfoResponse} */
    response.cryptoGetInfo;
    return Promise.resolve(_AccountInfo.default._fromProtobuf(
    /** @type {proto.IAccountInfo} */
    info.accountInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      cryptoGetInfo: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = AccountInfoQuery;

_Query.QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);

/***/ }),

/***/ 3472:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _TransactionRecord = _interopRequireDefault(__nccwpck_require__(1155));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountRecordsQuery} proto.ICryptoGetAccountRecordsQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountRecordsResponse} proto.ICryptoGetAccountRecordsResponse
 * @typedef {import("@hashgraph/proto").ITransactionRecord} proto.ITransactionRecord
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get all the records for an account for any transfers into it and out of it,
 * that were above the threshold, during the last 25 hours.
 *
 * @augments {Query<TransactionRecord[]>}
 */
class AccountRecordsQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?AccountId}
     * @private
     */

    this._accountId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {AccountRecordsQuery}
   */


  static _fromProtobuf(query) {
    const records =
    /** @type {proto.ICryptoGetAccountRecordsQuery} */
    query.cryptoGetAccountRecords;
    return new AccountRecordsQuery({
      accountId: records.accountID != null ? _AccountId.default._fromProtobuf(records.accountID) : undefined
    });
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the records are being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getAccountRecords(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const cryptoGetAccountRecords =
    /** @type {proto.ICryptoGetAccountRecordsResponse} */
    response.cryptoGetAccountRecords;
    return (
      /** @type {proto.IResponseHeader} */
      cryptoGetAccountRecords.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<TransactionRecord[]>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const cryptoGetAccountRecords =
    /** @type {proto.ICryptoGetAccountRecordsResponse} */
    response.cryptoGetAccountRecords;
    const records =
    /** @type {proto.ITransactionRecord[]} */
    cryptoGetAccountRecords.records;
    return Promise.resolve(records.map(record => _TransactionRecord.default._fromProtobuf(record, ledgerId)));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      cryptoGetAccountRecords: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }

}

exports.default = AccountRecordsQuery;

_Query.QUERY_REGISTRY.set("cryptoGetAccountRecords", // eslint-disable-next-line @typescript-eslint/unbound-method
AccountRecordsQuery._fromProtobuf);

/***/ }),

/***/ 9016:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _ProxyStaker = _interopRequireDefault(__nccwpck_require__(2843));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetStakersQuery} proto.ICryptoGetStakersQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetStakersResponse} proto.ICryptoGetStakersResponse
 * @typedef {import("@hashgraph/proto").IAllProxyStakers} proto.IAllProxyStakers
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get all the accounts that are proxy staking to this account.
 * For each of them, give the amount currently staked.
 *
 * This is not yet implemented, but will be in a future version of the API.
 *
 * @augments {Query<ProxyStaker[]>}
 */
class AccountStakersQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {(AccountId | string)=} props.accountId
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?AccountId}
     * @private
     */

    this._accountId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {AccountStakersQuery}
   */


  static _fromProtobuf(query) {
    const stakers =
    /** @type {proto.ICryptoGetStakersQuery} */
    query.cryptoGetProxyStakers;
    return new AccountStakersQuery({
      accountId: stakers.accountID != null ? _AccountId.default._fromProtobuf(stakers.accountID) : undefined
    });
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account ID for which the stakers are being requested.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getStakersByAccountID(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const cryptoGetProxyStakers =
    /** @type {proto.ICryptoGetStakersResponse} */
    response.cryptoGetProxyStakers;
    return (
      /** @type {proto.IResponseHeader} */
      cryptoGetProxyStakers.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<ProxyStaker[]>}
   */


  _mapResponse(response) {
    const cryptoGetProxyStakers =
    /** @type {proto.ICryptoGetStakersResponse} */
    response.cryptoGetProxyStakers;
    const stakers =
    /** @type {proto.IAllProxyStakers} */
    cryptoGetProxyStakers.stakers;
    return Promise.resolve((stakers.proxyStaker != null ? stakers.proxyStaker : []).map(staker => _ProxyStaker.default._fromProtobuf(staker)));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      cryptoGetProxyStakers: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }

} // @ts-ignore
// eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = AccountStakersQuery;

_Query.QUERY_REGISTRY.set("cryptoGetProxyStakers", AccountStakersQuery._fromProtobuf);

/***/ }),

/***/ 2927:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoUpdateTransactionBody} proto.ICryptoUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Change properties for the given account.
 */
class AccountUpdateTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {AccountId} [props.accountId]
   * @param {Key} [props.key]
   * @param {boolean} [props.receiverSignatureRequired]
   * @param {AccountId} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {string} [props.accountMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;
    /**
     * @private
     * @type {?Key}
     */

    this._key = null;
    /**
     * @private
     * @type {boolean}
     */

    this._receiverSignatureRequired = false;
    /**
     * @private
     * @type {?AccountId}
     */

    this._proxyAccountId = null;
    /**
     * @private
     * @type {?Duration}
     */

    this._autoRenewPeriod = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;
    /**
     * @private
     * @type {?string}
     */

    this._accountMemo = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }

    if (props.key != null) {
      this.setKey(props.key);
    }

    if (props.receiverSignatureRequired != null) {
      this.setReceiverSignatureRequired(props.receiverSignatureRequired);
    }

    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.accountMemo != null) {
      this.setAccountMemo(props.accountMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {AccountUpdateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update =
    /** @type {proto.ICryptoUpdateTransactionBody} */
    body.cryptoUpdateAccount;
    return _Transaction.default._fromProtobufTransactions(new AccountUpdateTransaction({
      accountId: update.accountIDToUpdate != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      update.accountIDToUpdate) : undefined,
      key: update.key != null ? (0, _protobuf.keyFromProtobuf)(update.key) : undefined,
      receiverSignatureRequired: update.receiverSigRequired != null ? update.receiverSigRequired : undefined,
      proxyAccountId: update.proxyAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      update.proxyAccountID) : undefined,
      autoRenewPeriod: update.autoRenewPeriod != null ? update.autoRenewPeriod.seconds != null ? update.autoRenewPeriod.seconds : undefined : undefined,
      expirationTime: update.expirationTime != null ? _Timestamp.default._fromProtobuf(update.expirationTime) : undefined,
      accountMemo: update.memo != null ? update.memo.value != null ? update.memo.value : undefined : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Sets the account ID which is being updated in this transaction.
   *
   * @param {AccountId | string} accountId
   * @returns {AccountUpdateTransaction}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */


  get key() {
    return this._key;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setKey(key) {
    this._requireNotFrozen();

    this._key = key;
    return this;
  }
  /**
   * @returns {boolean}
   */


  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  /**
   * @param {boolean} receiverSignatureRequired
   * @returns {this}
   */


  setReceiverSignatureRequired(receiverSignatureRequired) {
    this._requireNotFrozen();

    this._receiverSignatureRequired = receiverSignatureRequired;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @param {AccountId} proxyAccountId
   * @returns {this}
   */


  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();

    this._proxyAccountId = proxyAccountId;
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */


  setExpirationTime(expirationTime) {
    this._requireNotFrozen();

    this._expirationTime = expirationTime instanceof Date ? _Timestamp.default.fromDate(expirationTime) : expirationTime;
    return this;
  }
  /**
   * @returns {?string}
   */


  get accountMemo() {
    return this._accountMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setAccountMemo(memo) {
    this._requireNotFrozen();

    this._accountMemo = memo;
    return this;
  }
  /**
   * @returns {this}
   */


  clearAccountMemo() {
    this._requireNotFrozen();

    this._accountMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }

    if (this._proxyAccountId != null) {
      this._proxyAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.updateAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoUpdateAccount";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoUpdateTransactionBody}
   */


  _makeTransactionData() {
    return {
      accountIDToUpdate: this._accountId != null ? this._accountId._toProtobuf() : null,
      key: this._key != null ? (0, _protobuf.keyToProtobuf)(this._key) : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      receiverSigRequiredWrapper: this._receiverSignatureRequired == null ? null : {
        value: this._receiverSignatureRequired
      },
      memo: this._accountMemo != null ? {
        value: this._accountMemo
      } : null
    };
  }

}

exports.default = AccountUpdateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoUpdateAccount", // eslint-disable-next-line @typescript-eslint/unbound-method
AccountUpdateTransaction._fromProtobuf);

/***/ }),

/***/ 2072:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransferList} proto.ITransferList
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @augments {ObjectMap<AccountId, Hbar>}
 */
class HbarTransferMap extends _ObjectMap.default {
  constructor() {
    super(s => _AccountId.default.fromString(s));
  }
  /**
   * @param {proto.ITransferList} transfers
   * @returns {HbarTransferMap}
   */


  static _fromProtobuf(transfers) {
    const accountTransfers = new HbarTransferMap();

    for (const transfer of transfers.accountAmounts != null ? transfers.accountAmounts : []) {
      const account = _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      transfer.accountID);

      accountTransfers._set(account, _Hbar.default.fromTinybars(
      /** @type {Long} */
      transfer.amount));
    }

    return accountTransfers;
  }

}

exports.default = HbarTransferMap;

/***/ }),

/***/ 9367:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _cryptography = __nccwpck_require__(7410);

var _protobuf = __nccwpck_require__(223);

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 */

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class LiveHash {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {Uint8Array} props.hash
   * @param {KeyList} props.keys
   * @param {Duration} props.duration
   */
  constructor(props) {
    /** @readonly */
    this.accountId = props.accountId;
    /** @readonly */

    this.hash = props.hash;
    /** @readonly */

    this.keys = props.keys;
    /** @readonly */

    this.duration = props.duration;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.ILiveHash} liveHash
   * @param {(string | null)=} ledgerId
   * @returns {LiveHash}
   */


  static _fromProtobuf(liveHash, ledgerId) {
    const liveHash_ =
    /** @type {proto.ILiveHash} */
    liveHash;
    return new LiveHash({
      accountId: _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      liveHash_.accountId, ledgerId),
      hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
      keys: liveHash_.keys != null ? (0, _protobuf.keyListFromProtobuf)(liveHash_.keys) : new _cryptography.KeyList(),
      duration: _Duration.default._fromProtobuf(
      /** @type {proto.IDuration} */
      liveHash_.duration)
    });
  }
  /**
   * @internal
   * @returns {proto.ILiveHash}
   */


  _toProtobuf() {
    return {
      accountId: this.accountId._toProtobuf(),
      hash: this.hash,
      keys: (0, _protobuf.keyListToProtobuf)(this.keys),
      duration: this.duration._toProtobuf()
    };
  }

}

exports.default = LiveHash;

/***/ }),

/***/ 712:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _protobuf = __nccwpck_require__(223);

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

var _cryptography = __nccwpck_require__(7410);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoAddLiveHashTransactionBody} proto.ICryptoAddLiveHashTransactionBody
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class LiveHashAddTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.hash]
   * @param {Key[]} [props.keys]
   * @param {Duration | Long | number} [props.duration]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._hash = null;
    /**
     * @private
     * @type {?Key[]}
     */

    this._keys = null;
    /**
     * @private
     * @type {?Duration}
     */

    this._duration = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.hash != null) {
      this.setHash(props.hash);
    }

    if (props.keys != null) {
      this.setKeys(props.keys);
    }

    if (props.duration != null) {
      this.setDuration(props.duration);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {LiveHashAddTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes =
    /** @type {proto.ICryptoAddLiveHashTransactionBody} */
    body.cryptoAddLiveHash;
    const liveHash_ =
    /** @type {proto.ILiveHash} */
    hashes.liveHash;
    return _Transaction.default._fromProtobufTransactions(new LiveHashAddTransaction({
      hash: liveHash_.hash != null ? liveHash_.hash : undefined,
      keys: liveHash_.keys != null ? liveHash_.keys.keys != null ? liveHash_.keys.keys.map(key => (0, _protobuf.keyFromProtobuf)(key)) : undefined : undefined,
      duration: liveHash_.duration != null ? liveHash_.duration.seconds != null ? liveHash_.duration.seconds : undefined : undefined,
      accountId: liveHash_.accountId != null ? _AccountId.default._fromProtobuf(liveHash_.accountId) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?Uint8Array}
   */


  get hash() {
    return this._hash;
  }
  /**
   * @param {Uint8Array} hash
   * @returns {LiveHashAddTransaction}
   */


  setHash(hash) {
    this._requireNotFrozen();

    this._hash = hash;
    return this;
  }
  /**
   * @returns {?Key[]}
   */


  get keys() {
    return this._keys;
  }
  /**
   * @param {Key[] | KeyList} keys
   * @returns {LiveHashAddTransaction}
   */


  setKeys(keys) {
    this._requireNotFrozen();

    this._keys = keys instanceof _cryptography.KeyList ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get duration() {
    return this._duration;
  }
  /**
   * @param {Duration | Long | number} duration
   * @returns {LiveHashAddTransaction}
   */


  setDuration(duration) {
    this._requireNotFrozen();

    this._duration = duration instanceof _Duration.default ? duration : new _Duration.default(duration);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {LiveHashAddTransaction}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.addLiveHash(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoAddLiveHash";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoAddLiveHashTransactionBody}
   */


  _makeTransactionData() {
    return {
      liveHash: {
        hash: this._hash,
        keys: this._keys != null ? {
          keys: this._keys.map(key => (0, _protobuf.keyToProtobuf)(key))
        } : undefined,
        duration: this._duration != null ? this._duration._toProtobuf() : null,
        accountId: this._accountId != null ? this._accountId._toProtobuf() : null
      }
    };
  }

}

exports.default = LiveHashAddTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoAddLiveHash", // eslint-disable-next-line @typescript-eslint/unbound-method
LiveHashAddTransaction._fromProtobuf);

/***/ }),

/***/ 1160:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoDeleteLiveHashTransactionBody} proto.ICryptoDeleteLiveHashTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class LiveHashDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {Uint8Array} [props.hash]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._hash = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.hash != null) {
      this.setHash(props.hash);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {LiveHashDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const hashes =
    /** @type {proto.ICryptoDeleteLiveHashTransactionBody} */
    body.cryptoDeleteLiveHash;
    return _Transaction.default._fromProtobufTransactions(new LiveHashDeleteTransaction({
      hash: hashes.liveHashToDelete != null ? hashes.liveHashToDelete : undefined,
      accountId: hashes.accountOfLiveHash != null ? _AccountId.default._fromProtobuf(hashes.accountOfLiveHash) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?Uint8Array}
   */


  get hash() {
    return this._hash;
  }
  /**
   * @param {Uint8Array} hash
   * @returns {LiveHashDeleteTransaction}
   */


  setHash(hash) {
    this._requireNotFrozen();

    this._hash = hash;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {LiveHashDeleteTransaction}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.deleteLiveHash(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoDeleteLiveHash";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoDeleteLiveHashTransactionBody}
   */


  _makeTransactionData() {
    return {
      liveHashToDelete: this._hash,
      accountOfLiveHash: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = LiveHashDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoDeleteLiveHash", // eslint-disable-next-line @typescript-eslint/unbound-method
LiveHashDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 2513:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _LiveHash = _interopRequireDefault(__nccwpck_require__(9367));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetLiveHashQuery} proto.ICryptoGetLiveHashQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetLiveHashResponse} proto.ICryptoGetLiveHashResponse
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<LiveHash>}
 */
class LiveHashQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {AccountId | string} [props.accountId]
   * @param {Uint8Array} [props.hash]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?AccountId}
     * @private
     */

    this._accountId = null;

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
    /**
     * @type {?Uint8Array}
     * @private
     */


    this._hash = null;

    if (props.hash != null) {
      this.setHash(props.hash);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {LiveHashQuery}
   */


  static _fromProtobuf(query) {
    const hash =
    /** @type {proto.ICryptoGetLiveHashQuery} */
    query.cryptoGetLiveHash;
    return new LiveHashQuery({
      accountId: hash.accountID != null ? _AccountId.default._fromProtobuf(hash.accountID) : undefined,
      hash: hash.hash != null ? hash.hash : undefined
    });
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * Set the account to which the livehash is associated.
   *
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._accountId = accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get liveHash() {
    return this._hash;
  }
  /**
   * Set the SHA-384 data in the livehash.
   *
   * @param {Uint8Array} hash
   * @returns {this}
   */


  setHash(hash) {
    this._hash = hash;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getLiveHash(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const cryptoGetLiveHash =
    /** @type {proto.ICryptoGetLiveHashResponse} */
    response.cryptoGetLiveHash;
    return (
      /** @type {proto.IResponseHeader} */
      cryptoGetLiveHash.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<LiveHash>}
   */


  _mapResponse(response) {
    const hashes =
    /** @type {proto.ICryptoGetLiveHashResponse} */
    response.cryptoGetLiveHash;
    return Promise.resolve(_LiveHash.default._fromProtobuf(
    /** @type {proto.ILiveHash} */
    hashes.liveHash));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      cryptoGetLiveHash: {
        header,
        accountID: this._accountId != null ? this._accountId._toProtobuf() : null,
        hash: this._hash
      }
    };
  }

} // @ts-ignore
// eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = LiveHashQuery;

_Query.QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);

/***/ }),

/***/ 2843:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IProxyStaker} proto.IProxyStaker
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
class ProxyStaker {
  /**
   * @private
   * @param {object} props
   * @param {AccountId} props.accountId
   * @param {number | string | Long | BigNumber | Hbar} props.amount
   */
  constructor(props) {
    /**
     * The Account ID that sends or receives cryptocurrency.
     *
     * @readonly
     */
    this.accountId = props.accountId;
    /**
     * The amount of tinybars that the account sends(negative)
     * or receives(positive).
     *
     * @readonly
     */

    this.amount = props.amount instanceof _Hbar.default ? props.amount : new _Hbar.default(props.amount);
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IProxyStaker} transfer
   * @param {(string | null)=} ledgerId
   * @returns {ProxyStaker}
   */


  static _fromProtobuf(transfer, ledgerId) {
    return new ProxyStaker({
      accountId: _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      transfer.accountID, ledgerId),
      amount: _Hbar.default.fromTinybars(transfer.amount != null ? transfer.amount : 0)
    });
  }
  /**
   * @internal
   * @returns {proto.IProxyStaker}
   */


  _toProtobuf() {
    return {
      accountID: this.accountId._toProtobuf(),
      amount: this.amount.toTinybars()
    };
  }

}

exports.default = ProxyStaker;

/***/ }),

/***/ 9641:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, Long>}
 */
class TokenBalanceMap extends _ObjectMap.default {
  constructor() {
    super(s => _TokenId.default.fromString(s));
  }

}

exports.default = TokenBalanceMap;

/***/ }),

/***/ 6880:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @augments {ObjectMap<TokenId, number>}
 */
class TokenDecimalMap extends _ObjectMap.default {
  constructor() {
    super(s => _TokenId.default.fromString(s));
  }

}

exports.default = TokenDecimalMap;

/***/ }),

/***/ 586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenRelationship} proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").TokenKycStatus} proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").TokenFreezeStatus} proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * Token's information related to the given Account
 */
class TokenRelationship {
  /**
   * @param {object} props
   * @param {TokenId} props.tokenId
   * @param {string} props.symbol
   * @param {Long} props.balance
   * @param {boolean | null} props.isKycGranted
   * @param {boolean | null} props.isFrozen
   */
  constructor(props) {
    /**
     * The ID of the token
     *
     * @readonly
     */
    this.tokenId = props.tokenId;
    /**
     * The Symbol of the token
     *
     * @readonly
     */

    this.symbol = props.symbol;
    /**
     * The balance that the Account holds in the smallest denomination
     *
     * @readonly
     */

    this.balance = props.balance;
    /**
     * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does
     * not have KYC key, KycNotApplicable is returned
     *
     * @readonly
     */

    this.isKycGranted = props.isKycGranted;
    /**
     * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token
     * does not have Freeze key, FreezeNotApplicable is returned
     *
     * @readonly
     */

    this.isFrozen = props.isFrozen;
    Object.freeze(this);
  }
  /**
   * @param {proto.ITokenRelationship} relationship
   * @param {(string | null)=} ledgerId
   * @returns {TokenRelationship}
   */


  static _fromProtobuf(relationship, ledgerId) {
    const tokenId = _TokenId.default._fromProtobuf(
    /** @type {proto.ITokenID} */
    relationship.tokenId, ledgerId);

    const isKycGranted = relationship.kycStatus == null || relationship.kycStatus === 0 ? null : relationship.kycStatus === 1;
    const isFrozen = relationship.freezeStatus == null || relationship.freezeStatus === 0 ? null : relationship.freezeStatus === 1;
    return new TokenRelationship({
      tokenId,
      symbol:
      /** @type {string} */
      relationship.symbol,
      balance: relationship.balance != null ? relationship.balance instanceof _long.default ? relationship.balance : _long.default.fromValue(relationship.balance) : _long.default.ZERO,
      isKycGranted,
      isFrozen
    });
  }
  /**
   * @returns {proto.ITokenRelationship}
   */


  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      symbol: this.symbol,
      balance: this.balance,
      kycStatus: this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
      freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2
    };
  }

}

exports.default = TokenRelationship;

/***/ }),

/***/ 5985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _TokenRelationship = _interopRequireDefault(__nccwpck_require__(586));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenRelationship} proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, TokenRelationship>}
 */
class TokenRelationshipMap extends _ObjectMap.default {
  constructor() {
    super(s => _TokenId.default.fromString(s));
  }
  /**
   * @param {proto.ITokenRelationship[]} relationships
   * @param {(string | null)=} ledgerId
   * @returns {TokenRelationshipMap}
   */


  static _fromProtobuf(relationships, ledgerId) {
    const tokenRelationships = new TokenRelationshipMap();

    for (const relationship of relationships) {
      const tokenId = _TokenId.default._fromProtobuf(
      /** @type {proto.ITokenID} */
      relationship.tokenId, ledgerId);

      tokenRelationships._set(tokenId, _TokenRelationship.default._fromProtobuf(relationship, ledgerId));
    }

    return tokenRelationships;
  }
  /**
   * @returns {proto.ITokenRelationship[]}
   */


  _toProtobuf() {
    const list = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    for (const [_, relationship] of this) {
      list.push(relationship._toProtobuf());
    }

    return list;
  }

}

exports.default = TokenRelationshipMap;

/***/ }),

/***/ 4280:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @augments {ObjectMap<AccountId, Long>}
 */
class TokenTransferAccountMap extends _ObjectMap.default {
  constructor() {
    super(s => _AccountId.default.fromString(s));
  }

}

exports.default = TokenTransferAccountMap;

/***/ }),

/***/ 4363:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _TokenTransferAccountMap = _interopRequireDefault(__nccwpck_require__(4280));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @augments {ObjectMap<TokenId, TokenTransferAccountMap>}
 */
class TokenTransferMap extends _ObjectMap.default {
  constructor() {
    super(s => _TokenId.default.fromString(s));
  }
  /**
   * @internal
   * @param {TokenId} tokenId
   * @param {AccountId} accountId
   * @param {Long} amount
   */


  __set(tokenId, accountId, amount) {
    const token = tokenId.toString();

    let _map = this._map.get(token);

    if (_map == null) {
      _map = new _TokenTransferAccountMap.default();

      this._map.set(token, _map);

      this.__map.set(tokenId, _map);
    }

    _map._set(accountId, amount);
  }
  /**
   * @param {proto.ITokenTransferList[]} transfers
   * @param {(string | null)=} ledgerId
   * @returns {TokenTransferMap}
   */


  static _fromProtobuf(transfers, ledgerId) {
    const tokenTransfersMap = new TokenTransferMap();

    for (const transfer of transfers) {
      const token = _TokenId.default._fromProtobuf(
      /** @type {proto.ITokenID} */
      transfer.token, ledgerId);

      for (const aa of transfer.transfers != null ? transfer.transfers : []) {
        const account = _AccountId.default._fromProtobuf(
        /** @type {proto.IAccountID} */
        aa.accountID, ledgerId);

        tokenTransfersMap.__set(token, account,
        /** @type {Long} */
        aa.amount);
      }
    }

    return tokenTransfersMap;
  }
  /**
   * @returns {proto.ITokenTransferList[]}
   */


  _toProtobuf() {
    /** @type {proto.ITokenTransferList[]} */
    const tokenTransferList = [];

    for (const [tokenId, value] of this) {
      /** @type {proto.IAccountAmount[]} */
      const transfers = [];

      for (const [accountId, amount] of value) {
        transfers.push({
          accountID: accountId._toProtobuf(),
          amount: amount
        });
      }

      tokenTransferList.push({
        token: tokenId._toProtobuf(),
        transfers: transfers
      });
    }

    return tokenTransferList;
  }

}

exports.default = TokenTransferMap;

/***/ }),

/***/ 3007:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _TokenTransferMap = _interopRequireDefault(__nccwpck_require__(4363));

var _HbarTransferMap = _interopRequireDefault(__nccwpck_require__(2072));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoTransferTransactionBody} proto.ICryptoTransferTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} TransferTokensInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} accountId
 * @property {Long | number} amount
 */

/**
 * @typedef {object} TransferTokenObject
 * @property {TokenId} tokenId
 * @property {AccountId} accountId
 * @property {Long} amount
 */

/**
 * @typedef {object} TransferHbarInput
 * @property {AccountId | string} accountId
 * @property {number | string | Long | BigNumber | Hbar} amount
 */

/**
 * Transfers a new Hedera crypto-currency token.
 */
class TransferTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {(TransferTokensInput)[]} [props.tokenTransfers]
   * @param {(TransferHbarInput)[]} [props.hbarTransfers]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {TokenTransferMap}
     */

    this._tokenTransfers = new _TokenTransferMap.default();
    /**
     * @private
     * @type {HbarTransferMap}
     */

    this._hbarTransfers = new _HbarTransferMap.default();
    this.setMaxTransactionFee(new _Hbar.default(1));

    for (const transfer of props.tokenTransfers != null ? props.tokenTransfers : []) {
      this.addTokenTransfer(transfer.tokenId, transfer.accountId, transfer.amount);
    }

    for (const transfer of props.hbarTransfers != null ? props.hbarTransfers : []) {
      this.addHbarTransfer(transfer.accountId, transfer.amount);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TransferTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const cryptoTransfer =
    /** @type {proto.ICryptoTransferTransactionBody} */
    body.cryptoTransfer;
    const transfers = new TransferTransaction();

    for (const list of cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []) {
      const tokenId = _TokenId.default._fromProtobuf(
      /** @type {proto.ITokenID} */
      list.token);

      for (const transfer of list.transfers != null ? list.transfers : []) {
        transfers.addTokenTransfer(tokenId, _AccountId.default._fromProtobuf(
        /** @type {proto.IAccountID} */
        transfer.accountID),
        /** @type {Long} */
        transfer.amount);
      }
    }

    const accountAmounts = cryptoTransfer.transfers != null ? cryptoTransfer.transfers.accountAmounts != null ? cryptoTransfer.transfers.accountAmounts : [] : [];

    for (const aa of accountAmounts) {
      transfers.addHbarTransfer(_AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      aa.accountID), _Hbar.default.fromTinybars(
      /** @type {Long} */
      aa.amount));
    }

    return _Transaction.default._fromProtobufTransactions(transfers, transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {TokenTransferMap}
   */


  get tokenTransfers() {
    return this._tokenTransfers;
  }
  /**
   * @param {TokenId | string} tokenId
   * @param {AccountId | string} accountId
   * @param {number | Long} amount
   * @returns {this}
   */


  addTokenTransfer(tokenId, accountId, amount) {
    this._requireNotFrozen();

    this._tokenTransfers.__set(tokenId instanceof _TokenId.default ? tokenId : _TokenId.default.fromString(tokenId), accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId), amount instanceof _long.default ? amount : _long.default.fromNumber(amount));

    return this;
  }
  /**
   * @returns {HbarTransferMap}
   */


  get hbarTransfers() {
    return this._hbarTransfers;
  }
  /**
   * @internal
   * @param {AccountId | string} accountId
   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
   * @returns {TransferTransaction}
   */


  addHbarTransfer(accountId, amount) {
    this._requireNotFrozen();

    this._hbarTransfers._set(accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId), amount instanceof _Hbar.default ? amount : new _Hbar.default(amount));

    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [a, _] of this._hbarTransfers) {
      if (a != null) {
        a.validate(client);
      }
    }

    for (const [tokenId, transfers] of this._tokenTransfers) {
      if (tokenId != null) {
        tokenId.validate(client);
      } // eslint-disable-next-line @typescript-eslint/no-unused-vars


      for (const [a, _] of transfers) {
        if (a != null) {
          a.validate(client);
        }
      }
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.cryptoTransfer(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "cryptoTransfer";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ICryptoTransferTransactionBody}
   */


  _makeTransactionData() {
    const tokenTransfers = [];
    const hbarTransfers = [];

    for (const [tokenId, value] of this._tokenTransfers) {
      const transfers = [];

      for (const [accountId, amount] of value) {
        transfers.push({
          accountID: accountId._toProtobuf(),
          amount: amount
        });
      }

      tokenTransfers.push({
        token: tokenId._toProtobuf(),
        transfers
      });
    }

    for (const [accountId, value] of this._hbarTransfers) {
      hbarTransfers.push({
        accountID: accountId._toProtobuf(),
        amount: value.toTinybars()
      });
    }

    return {
      transfers: {
        accountAmounts: hbarTransfers
      },
      tokenTransfers
    };
  }

}

exports.default = TransferTransaction;

_Transaction.TRANSACTION_REGISTRY.set("cryptoTransfer", // eslint-disable-next-line @typescript-eslint/unbound-method
TransferTransaction._fromProtobuf);

/***/ }),

/***/ 9280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayEqual = arrayEqual;
exports.arrayStartsWith = arrayStartsWith;

/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }

  if (array1.byteLength !== array2.byteLength) {
    return false;
  }

  const view1 = new DataView(array1.buffer);
  const view2 = new DataView(array2.buffer);
  let i = array1.byteLength;

  while (i--) {
    if (view1.getUint8(i) !== view2.getUint8(i)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Uint8Array} array
 * @param {Uint8Array} arrayPrefix
 * @returns {boolean}
 */


function arrayStartsWith(array, arrayPrefix) {
  if (array.byteLength < arrayPrefix.byteLength) {
    return false;
  }

  let i = arrayPrefix.byteLength;

  while (i--) {
    if (array[i] !== arrayPrefix[i]) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ 1450:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encodeRequest = encodeRequest;
exports.decodeUnaryResponse = decodeUnaryResponse;
exports.default = void 0;

var _proto = __nccwpck_require__(973);

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @internal
 * @abstract
 */
class Channel {
  /**
   * @protected
   */
  constructor() {
    /**
     * @protected
     * @type {?CryptoService}
     */
    this._crypto = null;
    /**
     * @protected
     * @type {?SmartContractService}
     */

    this._smartContract = null;
    /**
     * @protected
     * @type {?FileService}
     */

    this._file = null;
    /**
     * @protected
     * @type {?ConsensusService}
     */

    this._consensus = null;
    /**
     * @protected
     * @type {?FreezeService}
     */

    this._freeze = null;
    /**
     * @protected
     * @type {?NetworkService}
     */

    this._network = null;
    /**
     * @protected
     * @type {?TokenService}
     */

    this._token = null;
    /**
     * @protected
     * @type {?ScheduleService}
     */

    this._schedule = null;
  }
  /**
   * @abstract
   * @returns {void}
   */


  close() {
    throw new Error("not implemented");
  }
  /**
   * @returns {CryptoService}
   */


  get crypto() {
    if (this._crypto != null) {
      return this._crypto;
    }

    this._crypto = _proto.CryptoService.create(this._createUnaryClient("CryptoService"));
    return this._crypto;
  }
  /**
   * @returns {SmartContractService}
   */


  get smartContract() {
    if (this._smartContract != null) {
      return this._smartContract;
    }

    this._smartContract = _proto.SmartContractService.create(this._createUnaryClient("SmartContractService"));
    return this._smartContract;
  }
  /**
   * @returns {FileService}
   */


  get file() {
    if (this._file != null) {
      return this._file;
    }

    this._file = _proto.FileService.create(this._createUnaryClient("FileService"));
    return this._file;
  }
  /**
   * @returns {ConsensusService}
   */


  get consensus() {
    if (this._consensus != null) {
      return this._consensus;
    }

    this._consensus = _proto.ConsensusService.create(this._createUnaryClient("ConsensusService"));
    return this._consensus;
  }
  /**
   * @returns {FreezeService}
   */


  get freeze() {
    if (this._freeze != null) {
      return this._freeze;
    }

    this._freeze = _proto.FreezeService.create(this._createUnaryClient("FreezeService"));
    return this._freeze;
  }
  /**
   * @returns {NetworkService}
   */


  get network() {
    if (this._network != null) {
      return this._network;
    }

    this._network = _proto.NetworkService.create(this._createUnaryClient("NetworkService"));
    return this._network;
  }
  /**
   * @returns {TokenService}
   */


  get token() {
    if (this._token != null) {
      return this._token;
    }

    this._token = _proto.TokenService.create(this._createUnaryClient("TokenService"));
    return this._token;
  }
  /**
   * @returns {ScheduleService}
   */


  get schedule() {
    if (this._schedule != null) {
      return this._schedule;
    }

    this._schedule = _proto.ScheduleService.create(this._createUnaryClient("ScheduleService"));
    return this._schedule;
  }
  /**
   * @abstract
   * @protected
   * @param {string} serviceName
   * @returns {import("protobufjs").RPCImpl}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _createUnaryClient(serviceName) {
    throw new Error("not implemented");
  }

} // grpc-web+proto is a series of data or trailer frames
// a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the
// length of the frame, followed by the frame data

/**
 * @param {Uint8Array} data
 * @returns {ArrayBuffer}
 */


exports.default = Channel;

function encodeRequest(data) {
  // for our requests, we want to transfer a single data frame
  const frame = new ArrayBuffer(data.byteLength + 5); // the frame type (data) is zero and can be left default-initialized
  // the length of the frame data

  new DataView(frame, 1, 4).setUint32(0, data.length); // copy in the frame data

  new Uint8Array(frame, 5).set(data);
  return frame;
}
/**
 * @param {ArrayBuffer} data
 * @returns {Uint8Array}
 */


function decodeUnaryResponse(data) {
  let dataOffset = 0;
  /** @type {?Uint8Array} */

  let unaryResponse = null; // 0 = successful

  let status = 0;

  while (dataOffset < data.byteLength) {
    const dataView = new DataView(data, dataOffset);
    const frameByte = dataView.getUint8(0);
    const frameType = frameByte >> 7;
    const frameByteLength = dataView.getUint32(1);
    const frameData = new Uint8Array(data, dataOffset + 5, frameByteLength);

    if (frameType === 0) {
      if (unaryResponse != null) {
        throw new Error("(BUG) unexpectedly received more than one data frame");
      }

      unaryResponse = frameData;
    } else if (frameType === 1) {
      const trailer = utf8.decode(frameData);
      const [trailerName, trailerValue] = trailer.split(":");

      if (trailerName === "grpc-status") {
        status = parseInt(trailerValue);
      } else {
        throw new Error(`(BUG) unhandled trailer, ${trailer}`);
      }
    } else {
      throw new Error(`(BUG) unexpected frame type: ${frameType}`);
    }

    dataOffset += frameByteLength + 5;
  }

  if (status !== 0) {
    throw new Error(`(BUG) unhandled grpc-status: ${status}`);
  }

  if (unaryResponse == null) {
    throw new Error("(BUG) unexpectedly received no response");
  }

  return unaryResponse;
}

/***/ }),

/***/ 1770:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * @typedef {object} MirrorError
 * @property {number} code
 * @property {string} details
 */

/**
 * @internal
 * @abstract
 */
class MirrorChannel {
  /**
   * @abstract
   * @returns {void}
   */
  close() {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @internal
   * @param {Uint8Array} requestData
   * @param {(data: Uint8Array) => void} callback
   * @param {(error: MirrorError | Error) => void} error
   * @param {() => void} end
   * @returns {() => void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  makeServerStreamRequest(requestData, callback, error, end) {
    throw new Error("not implemented");
  }

}

exports.default = MirrorChannel;

/***/ }),

/***/ 6735:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _grpcJs = __nccwpck_require__(3291);

var _Channel = _interopRequireDefault(__nccwpck_require__(1450));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @property {?proto.CryptoService} _crypto
 * @property {?proto.SmartContractService} _smartContract
 * @property {?proto.FileService} _file
 * @property {?proto.FreezeService} _freeze
 * @property {?proto.ConsensusService} _consensus
 * @property {?proto.NetworkService} _network
 */
class NodeChannel extends _Channel.default {
  /**
   * @internal
   * @param {string} address
   */
  constructor(address) {
    super();
    /**
     * @type {Client}
     * @private
     */

    this._client = new _grpcJs.Client(address, _grpcJs.credentials.createInsecure());
  }
  /**
   * @override
   * @returns {void}
   */


  close() {
    this._client.close();
  }
  /**
   * @override
   * @protected
   * @param {string} serviceName
   * @returns {import("protobufjs").RPCImpl}
   */


  _createUnaryClient(serviceName) {
    return (method, requestData, callback) => {
      this._client.makeUnaryRequest(`/proto.${serviceName}/${method.name}`, value => value, value => value, Buffer.from(requestData), callback);
    };
  }

}

exports.default = NodeChannel;

/***/ }),

/***/ 9479:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var grpc = _interopRequireWildcard(__nccwpck_require__(3291));

var _MirrorChannel = _interopRequireDefault(__nccwpck_require__(1770));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("./MirrorChannel.js").MirrorError} MirrorError
 */

/**
 * @internal
 */
class NodeMirrorChannel extends _MirrorChannel.default {
  /**
   * @internal
   * @param {string} address
   */
  constructor(address) {
    super();
    /**
     * @type {grpc.Client}
     * @private
     */

    this._client = new grpc.Client(address, address.endsWith(":50212") || address.endsWith(":443") ? grpc.credentials.createSsl() : grpc.credentials.createInsecure());
  }
  /**
   * @override
   * @returns {void}
   */


  close() {
    this._client.close();
  }
  /**
   * @override
   * @internal
   * @param {Uint8Array} requestData
   * @param {(data: Uint8Array) => void} callback
   * @param {(error: MirrorError | Error) => void} error
   * @param {() => void} end
   * @returns {() => void}
   */


  makeServerStreamRequest(requestData, callback, error, end) {
    const stream = this._client.makeServerStreamRequest( // `/proto.ConsensusService/SubscribeTopic`,
    "/com.hedera.mirror.api.proto.ConsensusService/subscribeTopic", value => value, value => value, Buffer.from(requestData)).on("data", (
    /** @type {Uint8Array} */
    data) => {
      callback(data);
    }).on("status", (
    /** @type {grpc.StatusObject} */
    status) => {
      if (status.code == 0) {
        end();
      } else {
        error(status);
      }
    }) // eslint-disable-next-line @typescript-eslint/no-unused-vars
    .on("error", (
    /** @type {grpc.StatusObject} */
    _) => {// Do nothing
    });

    return () => {
      stream.cancel();
    };
  }

}

exports.default = NodeMirrorChannel;

/***/ }),

/***/ 4198:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _AccountBalanceQuery = _interopRequireDefault(__nccwpck_require__(7757));

var _cryptography = __nccwpck_require__(7410);

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Network = _interopRequireDefault(__nccwpck_require__(6032));

var _MirrorNetwork = _interopRequireDefault(__nccwpck_require__(4773));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
 */

/**
 * @typedef {object} Operator
 * @property {string | PrivateKey} privateKey
 * @property {string | AccountId} accountId
 */

/**
 * @typedef {object} ClientOperator
 * @property {PublicKey} publicKey
 * @property {AccountId} accountId
 * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
 */

/**
 * @typedef {object} ClientConfiguration
 * @property {{[key: string]: (string | AccountId)} | NetworkName} network
 * @property {string[] | NetworkName | string} [mirrorNetwork]
 * @property {Operator} [operator]
 */

/**
 * @abstract
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 */
class Client {
  /**
   * @protected
   * @hideconstructor
   * @param {ClientConfiguration} [props]
   */
  constructor(props) {
    /**
     * List of mirror network URLs.
     *
     * @internal
     * @type {MirrorNetwork}
     */
    this._mirrorNetwork = new _MirrorNetwork.default(this._createMirrorNetworkChannel());
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @internal
     * @type {Network<ChannelT>}
     */

    this._network = new _Network.default(this._createNetworkChannel());
    /**
     * @internal
     * @type {?ClientOperator}
     */

    this._operator = null;
    /**
     * @private
     * @type {Hbar}
     */

    this._maxTransactionFee = new _Hbar.default(2);
    /**
     * @private
     * @type {Hbar}
     */

    this._maxQueryPayment = new _Hbar.default(1);

    if (props != null) {
      if (props.operator != null) {
        this.setOperator(props.operator.accountId, props.operator.privateKey);
      }
    }

    this._signOnDemand = false;
  }
  /**
   * @param {{[key: string]: (string | AccountId)} | NetworkName} network
   * @returns {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  setNetwork(network) {
    throw new Error("not implemented");
  }
  /**
   * @returns {{[key: string]: (string | AccountId)}}
   */


  get network() {
    return this._network.network;
  }
  /**
   * @param {string[] | string | NetworkName} mirrorNetwork
   * @returns {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  setMirrorNetwork(mirrorNetwork) {
    throw new Error("not implemented");
  }
  /**
   * @returns {string[]}
   */


  get mirrorNetwork() {
    return this._mirrorNetwork.network;
  }
  /**
   * @param {boolean} signOnDemand
   */


  setSignOnDemand(signOnDemand) {
    this._signOnDemand = signOnDemand;
  }
  /**
   * Set the account that will, by default, pay for transactions and queries built with this client.
   *
   * @param {AccountId | string} accountId
   * @param {PrivateKey | string} privateKey
   * @returns {this}
   */


  setOperator(accountId, privateKey) {
    const key = typeof privateKey === "string" ? _cryptography.PrivateKey.fromString(privateKey) : privateKey;
    return this.setOperatorWith(accountId, key.publicKey, message => Promise.resolve(key.sign(message)));
  }
  /**
   * Sets the account that will, by default, pay for transactions and queries built with
   * this client.
   *
   * @param {AccountId | string} accountId
   * @param {PublicKey | string} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {this}
   */


  setOperatorWith(accountId, publicKey, transactionSigner) {
    const accountId_ = accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId);
    accountId_.validate(this);
    this._operator = {
      transactionSigner,
      accountId: accountId_,
      publicKey: publicKey instanceof _cryptography.PublicKey ? publicKey : _cryptography.PublicKey.fromString(publicKey)
    };
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get operatorAccountId() {
    return this._operator != null ? this._operator.accountId : null;
  }
  /**
   * @returns {?PublicKey}
   */


  get operatorPublicKey() {
    return this._operator != null ? this._operator.publicKey : null;
  }
  /**
   * @returns {Hbar}
   */


  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  /**
   * Set the maximum fee to be paid for transactions
   * executed by this client.
   *
   * @param {Hbar} maxTransactionFee
   * @returns {this}
   */


  setMaxTransactionFee(maxTransactionFee) {
    this._maxTransactionFee = maxTransactionFee;
    return this;
  }
  /**
   * @returns {Hbar}
   */


  get maxQueryPayment() {
    return this._maxQueryPayment;
  }
  /**
   * Set the maximum payment allowable for queries.
   *
   * @param {Hbar} maxQueryPayment
   * @returns {Client<ChannelT, MirrorChannelT>}
   */


  setMaxQueryPayment(maxQueryPayment) {
    this._maxQueryPayment = maxQueryPayment;
    return this;
  }
  /**
   * @param {AccountId | string} accountId
   */


  async ping(accountId) {
    await new _AccountBalanceQuery.default({
      accountId
    }).setNodeAccountIds([accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId)]).execute(this);
  }
  /**
   * @returns {void}
   */


  close() {
    this._network.close();

    this._mirrorNetwork.close();
  }
  /**
   * @abstract
   * @returns {(address: string) => ChannelT}
   */


  _createNetworkChannel() {
    throw new Error("not implemented");
  }
  /**
   * @abstract
   * @returns {((address: string) => MirrorChannelT)?}
   */


  _createMirrorNetworkChannel() {
    // throw new Error("not implemented");
    return null;
  }

}

exports.default = Client;

/***/ }),

/***/ 4773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _MirrorNode = _interopRequireDefault(__nccwpck_require__(8998));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @typedef {import("./Client.js").NetworkName} NetworkName
 */
class MirrorNetwork {
  /**
   * @param {((address: string) => MirrorChannel)?} channelInitFunction
   */
  constructor(channelInitFunction) {
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @internal
     * @type {string[]}
     */
    this.network = [];
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @internal
     * @type {Map<string, MirrorNode>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    this.networkNodes = new Map();
    this.index = 0;
    /** @type {((address: string) => MirrorChannel)?} */

    this._channelInitFunction = channelInitFunction;
  }
  /**
   * @param {string[]} network
   */


  setMirrorNetwork(network) {
    if (this._channelInitFunction == null) {
      // silently fail on client boot if mirror network is not
      // supported
      return;
    }

    this.close();
    this.network = network;

    for (const address of this.network) {
      this.networkNodes.set(address, new _MirrorNode.default(address, this._channelInitFunction));
    }

    this.index = 0;
  }
  /**
   * @returns {MirrorNode}
   */


  getNextMirrorNode() {
    if (this._channelInitFunction == null) {
      throw new Error("mirror network not supported on browser");
    }

    const node = this.network[this.index];
    this.index = (this.index + 1) % this.network.length;
    return (
      /** @type {MirrorNode} */
      this.networkNodes.get(node)
    );
  }

  close() {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_, node] of this.networkNodes) {
      node.close();
    }

    this.networkNodes.clear();
    this.network = [];
  }

}

exports.default = MirrorNetwork;

/***/ }),

/***/ 6032:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Node = _interopRequireDefault(__nccwpck_require__(4952));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @typedef {import("./Client.js").NetworkName} NetworkName
 */

/**
 * @template {Channel} ChannelT
 */
class Network {
  /**
   * @param {(address: string) => ChannelT} createNetworkChannel
   */
  constructor(createNetworkChannel) {
    /**
     * @type {{[key: string]: (string | AccountId)}}
     */
    this.network = {};
    /**
     * Map of node account ID (as a string)
     * to the node URL.
     *
     * @internal
     * @type {Map<string, Node<ChannelT>>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    this.networkNodes = new Map();
    /**
     * List of node account IDs.
     *
     * @private
     * @type {Node<ChannelT>[]}
     */

    this.nodes = [];
    /** @type {(address: string) => ChannelT} */

    this.createNetworkChannel = createNetworkChannel;
    /** @type {string | null} */

    this._ledgerId = null;
  }
  /**
   * @param {{[key: string]: (string | AccountId)}} network
   */


  setNetwork(network) {
    const network_ = Object.entries(network);
    const thisNetwork_ = Object.entries(this.network); // Remove address that no longer exist

    for (const [url, accountId] of thisNetwork_) {
      const key = accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId); // eslint-disable-next-line ie11/no-loop-func,@typescript-eslint/no-unused-vars

      const index = network_.findIndex(([url_, _]) => url_ === url);

      if (index < 0) {
        const node = this.networkNodes.get(key.toString());

        if (node != null) {
          node.close();
        }

        this.networkNodes.delete(key.toString());
        const nodesIndex = this.nodes.findIndex( // eslint-disable-next-line ie11/no-loop-func
        node => node.address === url);

        if (nodesIndex >= 0) {
          this.nodes.splice(nodesIndex, 1);
        }
      }
    } // Add new address to the list


    for (const [url, accountId] of network_) {
      const key = accountId instanceof _AccountId.default ? accountId : _AccountId.default.fromString(accountId); // eslint-disable-next-line ie11/no-loop-func,@typescript-eslint/no-unused-vars

      const index = thisNetwork_.findIndex(([url_, _]) => url_ === url);

      if (index < 0) {
        const node = new _Node.default(key, url, this.createNetworkChannel);
        this.networkNodes.set(key.toString(), node);
        this.nodes.push(node);
      }
    }

    shuffle(this.nodes);
    this.network = network;
  }
  /**
   * @internal
   * @returns {number}
   */


  getNumberOfNodesForTransaction() {
    const count = this.nodes.map(node =>
    /** @type {number} */
    node.isHealthy() ? 1 : 0).reduce((sum, value) => sum += value);
    return (count + 3 - 1) / 3;
  }
  /**
   * @internal
   * @returns {AccountId[]}
   */


  getNodeAccountIdsForExecute() {
    this.nodes.sort((a, b) => a.compare(b));
    return this.nodes.slice(0, this.getNumberOfNodesForTransaction()).map(node => node.accountId);
  }

  close() {
    for (const node of this.nodes) {
      node.close();
    }

    this.networkNodes.clear();
    this.nodes = [];
    this.network = {};
  }

}
/**
 * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 *
 * @template T
 * @param {Array<T>} array
 */


exports.default = Network;

function shuffle(array) {
  var currentIndex = array.length,
      temporaryValue,
      randomIndex; // While there remain elements to shuffle...

  while (0 !== currentIndex) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1; // And swap it with the current element.

    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
}

/***/ }),

/***/ 5640:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.MirrorNetwork = exports.Network = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(5747));

var _util = _interopRequireDefault(__nccwpck_require__(1669));

var _Client = _interopRequireDefault(__nccwpck_require__(4198));

var _NodeChannel = _interopRequireDefault(__nccwpck_require__(6735));

var _NodeMirrorChannel = _interopRequireDefault(__nccwpck_require__(9479));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const readFileAsync = _util.default.promisify(_fs.default.readFile);
/**
 * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
 * @typedef {import("./Client.js").NetworkName} NetworkName
 */


const Network = {
  /**
   * @param {string} name
   * @returns {{[key: string]: (string | AccountId)}}
   */
  fromName(name) {
    switch (name) {
      case "mainnet":
        return Network.MAINNET;

      case "testnet":
        return Network.TESTNET;

      case "previewnet":
        return Network.PREVIEWNET;

      default:
        throw new Error(`unknown network name: ${name}`);
    }
  },

  MAINNET: {
    "35.237.200.180:50211": new _AccountId.default(3),
    "35.186.191.247:50211": new _AccountId.default(4),
    "35.192.2.25:50211": new _AccountId.default(5),
    "35.199.161.108:50211": new _AccountId.default(6),
    "35.203.82.240:50211": new _AccountId.default(7),
    "35.236.5.219:50211": new _AccountId.default(8),
    "35.197.192.225:50211": new _AccountId.default(9),
    "35.242.233.154:50211": new _AccountId.default(10),
    "35.240.118.96:50211": new _AccountId.default(11),
    "35.204.86.32:50211": new _AccountId.default(12),
    "35.234.132.107:50211": new _AccountId.default(13),
    "35.236.2.27:50211": new _AccountId.default(14),
    "35.228.11.53:50211": new _AccountId.default(15),
    "34.91.181.183:50211": new _AccountId.default(16),
    "34.86.212.247:50211": new _AccountId.default(17),
    "172.105.247.67:50211": new _AccountId.default(18),
    "34.89.87.138:50211": new _AccountId.default(19),
    "34.82.78.255:50211": new _AccountId.default(20)
  },
  TESTNET: {
    "0.testnet.hedera.com:50211": new _AccountId.default(3),
    "1.testnet.hedera.com:50211": new _AccountId.default(4),
    "2.testnet.hedera.com:50211": new _AccountId.default(5),
    "3.testnet.hedera.com:50211": new _AccountId.default(6),
    "4.testnet.hedera.com:50211": new _AccountId.default(7)
  },
  PREVIEWNET: {
    "0.previewnet.hedera.com:50211": new _AccountId.default(3),
    "1.previewnet.hedera.com:50211": new _AccountId.default(4),
    "2.previewnet.hedera.com:50211": new _AccountId.default(5),
    "3.previewnet.hedera.com:50211": new _AccountId.default(6),
    "4.previewnet.hedera.com:50211": new _AccountId.default(7)
  }
};
exports.Network = Network;
const MirrorNetwork = {
  /**
   * @param {string} name
   * @returns {string[]}
   */
  fromName(name) {
    switch (name) {
      case "mainnet":
        return MirrorNetwork.MAINNET;

      case "testnet":
        return MirrorNetwork.TESTNET;

      case "previewnet":
        return MirrorNetwork.PREVIEWNET;

      default:
        throw new Error(`unknown network name: ${name}`);
    }
  },

  MAINNET: ["hcs.mainnet.mirrornode.hedera.com:5600"],
  TESTNET: ["hcs.testnet.mirrornode.hedera.com:5600"],
  PREVIEWNET: ["hcs.previewnet.mirrornode.hedera.com:5600"]
};
/**
 * @augments {Client<NodeChannel, NodeMirrorChannel>}
 */

exports.MirrorNetwork = MirrorNetwork;

class NodeClient extends _Client.default {
  /**
   * @param {ClientConfiguration} [props]
   */
  constructor(props) {
    super(props);

    if (props != null) {
      if (typeof props.network === "string") {
        switch (props.network) {
          case "mainnet":
            this.setNetwork(Network.MAINNET);
            this.setMirrorNetwork(MirrorNetwork.MAINNET);
            this._network._ledgerId = "0";
            break;

          case "testnet":
            this.setNetwork(Network.TESTNET);
            this.setMirrorNetwork(MirrorNetwork.TESTNET);
            this._network._ledgerId = "1";
            break;

          case "previewnet":
            this.setNetwork(Network.PREVIEWNET);
            this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);
            this._network._ledgerId = "2";
            break;

          default:
            throw new Error( // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `unknown network: ${props.network}`);
        }
      } else if (props.network != null) {
        this.setNetwork(props.network);
      }

      if (typeof props.mirrorNetwork === "string") {
        switch (props.mirrorNetwork) {
          case "mainnet":
            this.setMirrorNetwork(MirrorNetwork.MAINNET);
            break;

          case "testnet":
            this.setMirrorNetwork(MirrorNetwork.TESTNET);
            break;

          case "previewnet":
            this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);
            break;

          default:
            this.setMirrorNetwork([props.mirrorNetwork]);
            break;
        }
      } else if (props.mirrorNetwork != null) {
        this.setMirrorNetwork(props.mirrorNetwork);
      }
    }
  }
  /**
   * @param {string | ClientConfiguration} data
   * @returns {NodeClient}
   */


  static fromConfig(data) {
    return new NodeClient(typeof data === "string" ? JSON.parse(data) : data);
  }
  /**
   * @param {string} filename
   * @returns {Promise<NodeClient>}
   */


  static async fromConfigFile(filename) {
    return NodeClient.fromConfig(await readFileAsync(filename, "utf8"));
  }
  /**
   * Construct a client for a specific network.
   *
   * It is the responsibility of the caller to ensure that all nodes in the map are part of the
   * same Hedera network. Failure to do so will result in undefined behavior.
   *
   * The client will load balance all requests to Hedera using a simple round-robin scheme to
   * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
   * tried.
   *
   * @param {{[key: string]: (string | AccountId)}} network
   * @returns {NodeClient}
   */


  static forNetwork(network) {
    return new NodeClient({
      network
    });
  }
  /**
   * @param {NetworkName} network
   * @returns {NodeClient}
   */


  static forName(network) {
    return new NodeClient({
      network
    });
  }
  /**
   * Construct a Hedera client pre-configured for Mainnet access.
   *
   * @returns {NodeClient}
   */


  static forMainnet() {
    return new NodeClient({
      network: "mainnet"
    });
  }
  /**
   * Construct a Hedera client pre-configured for Testnet access.
   *
   * @returns {NodeClient}
   */


  static forTestnet() {
    return new NodeClient({
      network: "testnet"
    });
  }
  /**
   * Construct a Hedera client pre-configured for Previewnet access.
   *
   * @returns {NodeClient}
   */


  static forPreviewnet() {
    return new NodeClient({
      network: "previewnet"
    });
  }
  /**
   * @param {{[key: string]: (string | AccountId)} | NetworkName} network
   * @returns {void}
   */


  setNetwork(network) {
    if (typeof network === "string") {
      switch (network) {
        case "previewnet":
          this._network.setNetwork(Network.PREVIEWNET);

          this._network._ledgerId = "2";
          break;

        case "testnet":
          this._network.setNetwork(Network.TESTNET);

          this._network._ledgerId = "1";
          break;

        case "mainnet":
          this._network.setNetwork(Network.MAINNET);

          this._network._ledgerId = "0";
      }
    } else {
      this._network.setNetwork(network);
    }
  }
  /**
   * @param {string[] | string | NetworkName} mirrorNetwork
   * @returns {void}
   */


  setMirrorNetwork(mirrorNetwork) {
    if (typeof mirrorNetwork === "string") {
      switch (mirrorNetwork) {
        case "previewnet":
          this._mirrorNetwork.setMirrorNetwork(MirrorNetwork.PREVIEWNET);

          break;

        case "testnet":
          this._mirrorNetwork.setMirrorNetwork(MirrorNetwork.TESTNET);

          break;

        case "mainnet":
          this._mirrorNetwork.setMirrorNetwork(MirrorNetwork.MAINNET);

          break;

        default:
          this._mirrorNetwork.setMirrorNetwork([mirrorNetwork]);

      }
    } else {
      this._mirrorNetwork.setMirrorNetwork(mirrorNetwork);
    }
  }
  /**
   * @override
   * @returns {(address: string) => NodeChannel}
   */


  _createNetworkChannel() {
    return address => new _NodeChannel.default(address);
  }
  /**
   * @override
   * @returns {(address: string) => NodeMirrorChannel}
   */


  _createMirrorNetworkChannel() {
    return address => new _NodeMirrorChannel.default(address);
  }

}

exports.default = NodeClient;

/***/ }),

/***/ 7781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractGetBytecodeQuery} proto.IContractGetBytecodeQuery
 * @typedef {import("@hashgraph/proto").IContractGetBytecodeResponse} proto.IContractGetBytecodeResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<Uint8Array>}
 */
class ContractByteCodeQuery extends _Query.default {
  /**
   * @param {object} props
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?ContractId}
     * @private
     */

    this._contractId = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {ContractByteCodeQuery}
   */


  static _fromProtobuf(query) {
    const bytecode =
    /** @type {proto.IContractGetBytecodeQuery} */
    query.contractGetBytecode;
    return new ContractByteCodeQuery({
      contractId: bytecode.contractID != null ? _ContractId.default._fromProtobuf(bytecode.contractID) : undefined
    });
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the info is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractByteCodeQuery}
   */


  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.contractGetBytecode(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const contractGetBytecodeResponse =
    /** @type {proto.IContractGetBytecodeResponse} */
    response.contractGetBytecodeResponse;
    return (
      /** @type {proto.IResponseHeader} */
      contractGetBytecodeResponse.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<Uint8Array>}
   */


  _mapResponse(response) {
    const contractGetBytecodeResponse =
    /** @type {proto.IContractGetBytecodeResponse} */
    response.contractGetBytecodeResponse;
    return Promise.resolve(contractGetBytecodeResponse.bytecode != null ? contractGetBytecodeResponse.bytecode : new Uint8Array());
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      contractGetBytecode: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = ContractByteCodeQuery;

_Query.QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);

/***/ }),

/***/ 8223:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _ContractFunctionParameters = _interopRequireDefault(__nccwpck_require__(3506));

var _ContractFunctionResult = _interopRequireDefault(__nccwpck_require__(5971));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractCallLocalQuery} proto.IContractCallLocalQuery
 * @typedef {import("@hashgraph/proto").IContractCallLocalResponse} proto.IContractCallLocalResponse
 * @typedef {import("@hashgraph/proto").IContractFunctionResult} proto.IContractFunctionResult
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @typedef {object} FunctionParameters
 * @property {ContractFunctionParameters} parameters
 * @property {string} name
 */

/**
 * @augments {Query<ContractFunctionResult>}
 */
class ContractCallQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {number | Long} [props.gas]
   * @param {FunctionParameters | Uint8Array} [props.functionParameters]
   * @param {number | Long} [props.maxResultSize]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
    /**
     * @private
     * @type {?Long}
     */


    this._gas = null;

    if (props.gas != null) {
      this.setGas(props.gas);
    }
    /**
     * @private
     * @type {?Uint8Array}
     */


    this._functionParameters = null;

    if (props.functionParameters != null) {
      if (props.functionParameters instanceof Uint8Array) {
        this.setFunctionParameters(props.functionParameters);
      } else {
        this.setFunction(props.functionParameters.name, props.functionParameters.parameters);
      }
    }
    /**
     * @private
     * @type {?Long}
     */


    this._maxResultSize = null;

    if (props.maxResultSize != null) {
      this.setMaxResultSize(props.maxResultSize);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {ContractCallQuery}
   */


  static _fromProtobuf(query) {
    const call =
    /** @type {proto.IContractCallLocalQuery} */
    query.contractCallLocal;
    return new ContractCallQuery({
      contractId: call.contractID != null ? _ContractId.default._fromProtobuf(call.contractID) : undefined,
      gas: call.gas != null ? call.gas : undefined,
      functionParameters: call.functionParameters != null ? call.functionParameters : undefined,
      maxResultSize: call.maxResultSize != null ? call.maxResultSize : undefined
    });
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the call is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractCallQuery}
   */


  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */


  get gas() {
    return this._gas;
  }
  /**
   * @param {number | Long} gas
   * @returns {ContractCallQuery}
   */


  setGas(gas) {
    this._gas = gas instanceof _long.default ? gas : _long.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get functionParameters() {
    return this._functionParameters;
  }
  /**
   * @param {Uint8Array} params
   * @returns {ContractCallQuery}
   */


  setFunctionParameters(params) {
    this._functionParameters = params;
    return this;
  }
  /**
   * @param {string} name
   * @param {?ContractFunctionParameters} [params]
   * @returns {ContractCallQuery}
   */


  setFunction(name, params) {
    this._functionParameters = (params != null ? params : new _ContractFunctionParameters.default())._build(name);
    return this;
  }
  /**
   * @param {number | Long} size
   * @returns {ContractCallQuery}
   */


  setMaxResultSize(size) {
    this._maxResultSize = size instanceof _long.default ? size : _long.default.fromValue(size);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.contractCallLocalMethod(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const contractCallLocal =
    /** @type {proto.IContractCallLocalResponse} */
    response.contractCallLocal;
    return (
      /** @type {proto.IResponseHeader} */
      contractCallLocal.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<ContractFunctionResult>}
   */


  _mapResponse(response) {
    const call =
    /**
     *@type {proto.IContractCallLocalResponse}
     */
    response.contractCallLocal;
    return Promise.resolve(_ContractFunctionResult.default._fromProtobuf(
    /**
     * @type {proto.IContractFunctionResult}
     */
    call.functionResult));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      contractCallLocal: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
        gas: this._gas,
        functionParameters: this._functionParameters,
        maxResultSize: this._maxResultSize
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = ContractCallQuery;

_Query.QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);

/***/ }),

/***/ 149:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _ContractFunctionParameters = _interopRequireDefault(__nccwpck_require__(3506));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractCreateTransactionBody} proto.IContractCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class ContractCreateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.bytecodeFileId]
   * @param {Key} [props.adminKey]
   * @param {number | Long} [props.gas]
   * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
   * @param {AccountId | string} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {Uint8Array} [props.constructorParameters]
   * @param {string} [props.contractMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._bytecodeFileId = null;
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?Long}
     */

    this._gas = null;
    /**
     * @private
     * @type {?Hbar}
     */

    this._initialBalance = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._proxyAccountId = null;
    /**
     * @private
     * @type {Duration}
     */

    this._autoRenewPeriod = new _Duration.default(_Transaction.DEFAULT_AUTO_RENEW_PERIOD);
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._constructorParameters = null;
    /**
     * @private
     * @type {?string}
     */

    this._contractMemo = null;
    this.setMaxTransactionFee(new _Hbar.default(20));

    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.gas != null) {
      this.setGas(props.gas);
    }

    if (props.initialBalance != null) {
      this.setInitialBalance(props.initialBalance);
    }

    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.constructorParameters != null) {
      this.setConstructorParameters(props.constructorParameters);
    }

    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ContractCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.IContractCreateTransactionBody} */
    body.contractCreateInstance;
    return _Transaction.default._fromProtobufTransactions(new ContractCreateTransaction({
      bytecodeFileId: create.fileID != null ? _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      create.fileID) : undefined,
      adminKey: create.adminKey != null ? (0, _protobuf.keyFromProtobuf)(create.adminKey) : undefined,
      gas: create.gas != null ? create.gas : undefined,
      initialBalance: create.initialBalance != null ? create.initialBalance : undefined,
      proxyAccountId: create.proxyAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      create.proxyAccountID) : undefined,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : undefined : undefined,
      constructorParameters: create.constructorParameters != null ? create.constructorParameters : undefined,
      contractMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?FileId}
   */


  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  /**
   * @param {FileId | string} bytecodeFileId
   * @returns {this}
   */


  setBytecodeFileId(bytecodeFileId) {
    this._requireNotFrozen();

    this._bytecodeFileId = typeof bytecodeFileId === "string" ? _FileId.default.fromString(bytecodeFileId) : bytecodeFileId.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */


  setAdminKey(adminKey) {
    this._requireNotFrozen();

    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {?Long}
   */


  get gas() {
    return this._gas;
  }
  /**
   * @param {number | Long} gas
   * @returns {this}
   */


  setGas(gas) {
    this._requireNotFrozen();

    this._gas = gas instanceof _long.default ? gas : _long.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?Hbar}
   */


  get initialBalance() {
    return this._initialBalance;
  }
  /**
   * Set the initial amount to transfer into this contract.
   *
   * @param {number | string | Long | BigNumber | Hbar} initialBalance
   * @returns {this}
   */


  setInitialBalance(initialBalance) {
    this._requireNotFrozen();

    this._initialBalance = initialBalance instanceof _Hbar.default ? initialBalance : new _Hbar.default(initialBalance);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @param {AccountId | string} proxyAccountId
   * @returns {this}
   */


  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();

    this._proxyAccountId = proxyAccountId instanceof _AccountId.default ? proxyAccountId : _AccountId.default.fromString(proxyAccountId);
    return this;
  }
  /**
   * @returns {Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get constructorParameters() {
    return this._constructorParameters;
  }
  /**
   * @param {Uint8Array | ContractFunctionParameters} constructorParameters
   * @returns {this}
   */


  setConstructorParameters(constructorParameters) {
    this._requireNotFrozen();

    this._constructorParameters = constructorParameters instanceof _ContractFunctionParameters.default ? constructorParameters._build() : constructorParameters;
    return this;
  }
  /**
   * @returns {?string}
   */


  get contractMemo() {
    return this._contractMemo;
  }
  /**
   * @param {string} contractMemo
   * @returns {this}
   */


  setContractMemo(contractMemo) {
    this._requireNotFrozen();

    this._contractMemo = contractMemo;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validate(client);
    }

    if (this._proxyAccountId != null) {
      this._proxyAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.createContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "contractCreateInstance";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IContractCreateTransactionBody}
   */


  _makeTransactionData() {
    return {
      fileID: this._bytecodeFileId != null ? this._bytecodeFileId._toProtobuf() : null,
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      gas: this._gas,
      initialBalance: this._initialBalance != null ? this._initialBalance.toTinybars() : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      constructorParameters: this._constructorParameters,
      memo: this._contractMemo
    };
  }

}

exports.default = ContractCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("contractCreateInstance", // eslint-disable-next-line @typescript-eslint/unbound-method
ContractCreateTransaction._fromProtobuf);

/***/ }),

/***/ 2139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractDeleteTransactionBody} proto.IContractDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class ContractDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {ContractId | string} [props.transferContractId]
   * @param {AccountId | string} [props.transferAccountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._transferAccountId = null;
    /**
     * @private
     * @type {?ContractId}
     */

    this._transferContractId = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }

    if (props.transferAccountId != null) {
      this.setTransferAccountId(props.transferAccountId);
    }

    if (props.transferContractId != null) {
      this.setTransferContractId(props.transferContractId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ContractDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const contractDelete =
    /** @type {proto.IContractDeleteTransactionBody} */
    body.contractDeleteInstance;
    return _Transaction.default._fromProtobufTransactions(new ContractDeleteTransaction({
      contractId: contractDelete.contractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      contractDelete.contractID) : undefined,
      transferAccountId: contractDelete.transferAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      contractDelete.transferAccountID) : undefined,
      transferContractId: contractDelete.transferContractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      contractDelete.transferContractID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractDeleteTransaction}
   */


  setContractId(contractId) {
    this._requireNotFrozen();

    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?ContractId}
   */


  get transferContractId() {
    return this._transferContractId;
  }
  /**
   * Sets the contract ID which will receive all remaining hbars.
   *
   * @param {ContractId | string} transferContractId
   * @returns {ContractDeleteTransaction}
   */


  setTransferContractId(transferContractId) {
    this._requireNotFrozen();

    this._transferContractId = transferContractId instanceof _ContractId.default ? transferContractId : _ContractId.default.fromString(transferContractId);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get transferAccountId() {
    return this._transferAccountId;
  }
  /**
   * Sets the account ID which will receive all remaining hbars.
   *
   * @param {AccountId | string} transferAccountId
   * @returns {ContractDeleteTransaction}
   */


  setTransferAccountId(transferAccountId) {
    this._requireNotFrozen();

    this._transferAccountId = transferAccountId instanceof _AccountId.default ? transferAccountId : _AccountId.default.fromString(transferAccountId);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }

    if (this._transferAccountId != null) {
      this._transferAccountId.validate(client);
    }

    if (this._transferContractId != null) {
      this._transferContractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.deleteContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "contractDeleteInstance";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IContractDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      transferAccountID: this._transferAccountId ? this._transferAccountId._toProtobuf() : null,
      transferContractID: this._transferContractId != null ? this._transferContractId._toProtobuf() : null
    };
  }

}

exports.default = ContractDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("contractDeleteInstance", // eslint-disable-next-line @typescript-eslint/unbound-method
ContractDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 6837:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _ContractFunctionParameters = _interopRequireDefault(__nccwpck_require__(3506));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractCallTransactionBody} proto.IContractCallTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} FunctionParameters
 * @property {string} name
 * @property {ContractFunctionParameters} parameters
 */
class ContractExecuteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   * @param {number | Long} [props.gas]
   * @param {number | string | Long | BigNumber | Hbar} [props.amount]
   * @param {Uint8Array} [props.functionParameters]
   * @param {FunctionParameters} [props.function]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;
    /**
     * @private
     * @type {?Long}
     */

    this._gas = null;
    /**
     * @private
     * @type {?Hbar}
     */

    this._amount = null;
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._functionParameters = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }

    if (props.gas != null) {
      this.setGas(props.gas);
    }

    if (props.amount != null) {
      this.setPayableAmount(props.amount);
    }

    if (props.functionParameters != null) {
      this.setFunctionParameters(props.functionParameters);
    } else if (props.function != null) {
      this.setFunction(props.function.name, props.function.parameters);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ContractExecuteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const call =
    /** @type {proto.IContractCallTransactionBody} */
    body.contractCall;
    return _Transaction.default._fromProtobufTransactions(new ContractExecuteTransaction({
      contractId: call.contractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      call.contractID) : undefined,
      gas: call.gas != null ? call.gas : undefined,
      amount: call.amount ? call.amount : undefined,
      functionParameters: call.functionParameters != null ? call.functionParameters : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being executed in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractExecuteTransaction}
   */


  setContractId(contractId) {
    this._requireNotFrozen();

    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */


  get gas() {
    return this._gas;
  }
  /**
   * Sets the contract ID which is being executed in this transaction.
   *
   * @param {number | Long} gas
   * @returns {ContractExecuteTransaction}
   */


  setGas(gas) {
    this._requireNotFrozen();

    this._gas = gas instanceof _long.default ? gas : _long.default.fromValue(gas);
    return this;
  }
  /**
   * @returns {?Hbar}
   */


  get payableAmount() {
    return this._amount;
  }
  /**
   * Sets the contract ID which is being executed in this transaction.
   *
   * @param {number | string | Long | BigNumber | Hbar} amount
   * @returns {ContractExecuteTransaction}
   */


  setPayableAmount(amount) {
    this._requireNotFrozen();

    this._amount = amount instanceof _Hbar.default ? amount : new _Hbar.default(amount);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get functionParameters() {
    return this._functionParameters;
  }
  /**
   * @param {Uint8Array} functionParameters
   */


  setFunctionParameters(functionParameters) {
    this._requireNotFrozen();

    this._functionParameters = functionParameters;
  }
  /**
   * @param {string} name
   * @param {ContractFunctionParameters} [functionParameters]
   * @returns {this}
   */


  setFunction(name, functionParameters) {
    this._requireNotFrozen();

    this._functionParameters = functionParameters != null ? functionParameters._build(name) : new _ContractFunctionParameters.default()._build(name);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.contractCallMethod(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "contractCall";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IContractCallTransactionBody}
   */


  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      gas: this._gas,
      amount: this._amount != null ? this._amount.toTinybars() : null,
      functionParameters: this._functionParameters
    };
  }

}

exports.default = ContractExecuteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("contractCall", // eslint-disable-next-line @typescript-eslint/unbound-method
ContractExecuteTransaction._fromProtobuf);

/***/ }),

/***/ 3506:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ContractFunctionSelector = _interopRequireWildcard(__nccwpck_require__(8347));

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var hex = _interopRequireWildcard(__nccwpck_require__(819));

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class ContractFunctionParameters {
  constructor() {
    /**
     * @type {ContractFunctionSelector}
     */
    this._selector = new _ContractFunctionSelector.default();
    /**
     * @type {import("./ContractFunctionSelector.js").Argument[]}
     */

    this._arguments = [];
  }
  /**
   * @param {string} value
   * @returns {ContractFunctionParameters}
   */


  addString(value) {
    this._selector.addString();

    return this._addParam(value, true);
  }
  /**
   * @param {string[]} value
   * @returns {ContractFunctionParameters}
   */


  addStringArray(value) {
    this._selector.addStringArray();

    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array} value
   * @returns {ContractFunctionParameters}
   */


  addBytes(value) {
    this._selector.addBytes();

    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array} value
   * @returns {ContractFunctionParameters}
   */


  addBytes32(value) {
    if (value.length !== 32) {
      throw new Error(`addBytes32 expected array to be of length 32, but received ${value.length}`);
    }

    this._selector.addBytes32();

    return this._addParam(value, false);
  }
  /**
   * @param {Uint8Array[]} value
   * @returns {ContractFunctionParameters}
   */


  addBytesArray(value) {
    this._selector.addBytesArray();

    return this._addParam(value, true);
  }
  /**
   * @param {Uint8Array[]} value
   * @returns {ContractFunctionParameters}
   */


  addBytes32Array(value) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_, entry] of value.entries()) {
      if (entry.length !== 32) {
        throw new Error(`addBytes32 expected array to be of length 32, but received ${entry.length}`);
      }
    }

    this._selector.addBytes32Array();

    return this._addParam(value, true);
  }
  /**
   * @param {boolean} value
   * @returns {ContractFunctionParameters}
   */


  addBool(value) {
    this._selector.addBool();

    return this._addParam(value, false);
  }
  /**
   * @param {number} value
   * @returns {ContractFunctionParameters}
   */


  addInt8(value) {
    this._selector.addInt8();

    return this._addParam(value, false);
  }
  /**
   * @param {number} value
   * @returns {ContractFunctionParameters}
   */


  addInt32(value) {
    this._selector.addInt32();

    return this._addParam(value, false);
  }
  /**
   * @param {BigNumber} value
   * @returns {ContractFunctionParameters}
   */


  addInt64(value) {
    this._selector.addInt64();

    return this._addParam(value, false);
  }
  /**
   * @param {BigNumber} value
   * @returns {ContractFunctionParameters}
   */


  addInt256(value) {
    this._selector.addInt256();

    return this._addParam(value, false);
  }
  /**
   * @param {number[]} value
   * @returns {ContractFunctionParameters}
   */


  addInt8Array(value) {
    this._selector.addInt8Array();

    return this._addParam(value, true);
  }
  /**
   * @param {number[]} value
   * @returns {ContractFunctionParameters}
   */


  addInt32Array(value) {
    this._selector.addInt32Array();

    return this._addParam(value, true);
  }
  /**
   * @param {BigNumber[]} value
   * @returns {ContractFunctionParameters}
   */


  addInt64Array(value) {
    this._selector.addInt64Array();

    return this._addParam(value, true);
  }
  /**
   * @param {BigNumber[]} value
   * @returns {ContractFunctionParameters}
   */


  addInt256Array(value) {
    this._selector.addInt256Array();

    return this._addParam(value, true);
  }
  /**
   * @param {number} value
   * @returns {ContractFunctionParameters}
   */


  addUint8(value) {
    this._selector.addUint8();

    return this._addParam(value, false);
  }
  /**
   * @param {number} value
   * @returns {ContractFunctionParameters}
   */


  addUint32(value) {
    this._selector.addUint32();

    return this._addParam(value, false);
  }
  /**
   * @param {BigNumber} value
   * @returns {ContractFunctionParameters}
   */


  addUint64(value) {
    this._selector.addUint64();

    return this._addParam(value, false);
  }
  /**
   * @param {BigNumber} value
   * @returns {ContractFunctionParameters}
   */


  addUint256(value) {
    this._selector.addUint256();

    return this._addParam(value, false);
  }
  /**
   * @param {number[]} value
   * @returns {ContractFunctionParameters}
   */


  addUint8Array(value) {
    this._selector.addUint8Array();

    return this._addParam(value, true);
  }
  /**
   * @param {number[]} value
   * @returns {ContractFunctionParameters}
   */


  addUint32Array(value) {
    this._selector.addUint32Array();

    return this._addParam(value, true);
  }
  /**
   * @param {BigNumber[]} value
   * @returns {ContractFunctionParameters}
   */


  addUint64Array(value) {
    this._selector.addUint64Array();

    return this._addParam(value, true);
  }
  /**
   * @param {BigNumber[]} value
   * @returns {ContractFunctionParameters}
   */


  addUint256Array(value) {
    this._selector.addUint256Array();

    return this._addParam(value, true);
  }
  /**
   * @param {string} value
   * @returns {ContractFunctionParameters}
   */


  addAddress(value) {
    // Allow `0x` prefix
    if (value.length !== 40 && value.length !== 42) {
      throw new Error("`address` type requires parameter to be 40 or 42 characters");
    }

    const par = value.length === 40 ? hex.decode(value) : hex.decode(value.substring(2));

    this._selector.addAddress();

    return this._addParam(par, false);
  }
  /**
   * @param {string[]} value
   * @returns {ContractFunctionParameters}
   */


  addAddressArray(value) {
    /**
     * @type {Uint8Array[]}
     */
    const par = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    for (const [_, entry] of value.entries()) {
      if (entry.length !== 40 && entry.length !== 42) {
        throw new Error("`address` type requires parameter to be 40 or 42 characters");
      }

      const buf = entry.length === 40 ? hex.decode(entry) : hex.decode(entry.substring(2));
      par.push(buf);
    }

    this._selector.addAddressArray();

    return this._addParam(par, true);
  }
  /**
   * @param {string} address
   * @param {ContractFunctionSelector} selector
   * @returns {ContractFunctionParameters}
   */


  addFunction(address, selector) {
    const addressParam = hex.decode(address);

    const functionSelector = selector._build();

    if (addressParam.length !== 20) {
      throw new Error("`function` type requires parameter `address` to be exactly 20 bytes");
    }

    this._selector.addFunction();

    const proto = new Uint8Array(24);
    proto.set(addressParam, 0);
    proto.set(functionSelector, 20);
    return this._addParam(proto, false);
  }
  /**
   * @internal
   * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
   * @param {boolean} dynamic
   * @returns {ContractFunctionParameters}
   */


  _addParam(param, dynamic) {
    const index = this._selector._paramTypes.length - 1;
    const value = argumentToBytes(param, this._selector._paramTypes[index]);

    this._arguments.push({
      dynamic,
      value
    });

    return this;
  }
  /**
   * @internal
   * @param {string=} name
   * @returns {Uint8Array}
   */


  _build(name) {
    const includeId = name != null;
    const nameOffset = includeId ? 4 : 0;
    const length = this._arguments.length === 0 ? nameOffset : this._arguments.length * 32 + this._arguments.map(arg => arg.dynamic ? arg.value.length : 0).reduce((sum, value) => sum + value) + nameOffset;
    const func = new Uint8Array(length);

    if (includeId) {
      func.set(this._selector._build(name), 0);
    }

    let offset = 32 * this._arguments.length;

    for (const [i, {
      dynamic,
      value
    }] of this._arguments.entries()) {
      if (dynamic) {
        const view = new DataView(func.buffer, nameOffset + i * 32 + 28);
        view.setUint32(0, offset);
        func.set(value, view.getUint32(0) + nameOffset);
        offset += value.length;
      } else {
        func.set(value, nameOffset + i * 32);
      }
    }

    return func;
  }

}
/**
 * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
 * @param {import("./ContractFunctionSelector.js").SolidityType} ty
 * @returns {Uint8Array}
 */


exports.default = ContractFunctionParameters;

function argumentToBytes(param, ty) {
  let value = new Uint8Array(32);
  let valueView = new DataView(value.buffer, 0);
  /** @type {Uint8Array} */

  let par;

  if (ty.array) {
    if (!Array.isArray(param)) {
      throw new TypeError("SolidityType indicates type is array, but parameter is not an array");
    }
    /**
     * @type {Uint8Array[]}
     */


    const values = []; // Generic over any type of array
    // Destructuring required so the first variable must be assigned
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

    for (const [_, p] of param.entries()) {
      const arg = argumentToBytes(p, {
        ty: ty.ty,
        array: false
      });
      values.push(arg);
    }

    const totalLengthOfValues = values.map(a => a.length).reduce((total, current) => total + current);

    switch (ty.ty) {
      case _ContractFunctionSelector.ArgumentType.uint8:
      case _ContractFunctionSelector.ArgumentType.int8:
      case _ContractFunctionSelector.ArgumentType.uint16:
      case _ContractFunctionSelector.ArgumentType.int16:
      case _ContractFunctionSelector.ArgumentType.uint32:
      case _ContractFunctionSelector.ArgumentType.int32:
      case _ContractFunctionSelector.ArgumentType.uint64:
      case _ContractFunctionSelector.ArgumentType.int64:
      case _ContractFunctionSelector.ArgumentType.uint256:
      case _ContractFunctionSelector.ArgumentType.int256:
      case _ContractFunctionSelector.ArgumentType.bool:
      case _ContractFunctionSelector.ArgumentType.bytes32:
      case _ContractFunctionSelector.ArgumentType.address:
      case _ContractFunctionSelector.ArgumentType.func:
        value = new Uint8Array(totalLengthOfValues + 32);
        break;

      case _ContractFunctionSelector.ArgumentType.bytes:
      case _ContractFunctionSelector.ArgumentType.string:
        value = new Uint8Array(values.length * 32 + totalLengthOfValues + 32);
        break;

      default:
        throw new TypeError(`Expected param type to be ArgumentType, but received ${ty.ty}`);
    }

    valueView = new DataView(value.buffer, 28);
    valueView.setUint32(0, values.length);
    let offset = 32 * values.length;

    for (const [i, e] of values.entries()) {
      switch (ty.ty) {
        case _ContractFunctionSelector.ArgumentType.uint8:
        case _ContractFunctionSelector.ArgumentType.int8:
        case _ContractFunctionSelector.ArgumentType.uint16:
        case _ContractFunctionSelector.ArgumentType.int16:
        case _ContractFunctionSelector.ArgumentType.uint32:
        case _ContractFunctionSelector.ArgumentType.int32:
        case _ContractFunctionSelector.ArgumentType.uint64:
        case _ContractFunctionSelector.ArgumentType.int64:
        case _ContractFunctionSelector.ArgumentType.uint256:
        case _ContractFunctionSelector.ArgumentType.int256:
        case _ContractFunctionSelector.ArgumentType.bool:
        case _ContractFunctionSelector.ArgumentType.bytes32:
        case _ContractFunctionSelector.ArgumentType.address:
        case _ContractFunctionSelector.ArgumentType.func:
          value.set(e, i * 32 + 32);
          break;

        case _ContractFunctionSelector.ArgumentType.bytes:
        case _ContractFunctionSelector.ArgumentType.string:
          // eslint-disable-next-line no-case-declarations
          const view = new DataView(value.buffer, (i + 1) * 32 + 28);
          view.setUint32(0, offset);
          value.set(e, view.getUint32(0) + 32);
          offset += e.length;
          break;

        default:
          throw new TypeError(`Expected param type to be ArgumentType, but received ${ty.ty}`);
      }
    }

    return value;
  }

  switch (ty.ty) {
    case _ContractFunctionSelector.ArgumentType.uint8:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 31, valueView.setUint8.bind(valueView));
      return value;

    case _ContractFunctionSelector.ArgumentType.int8:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 31, valueView.setInt8.bind(valueView));
      return value;

    case _ContractFunctionSelector.ArgumentType.uint16:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 30, valueView.setUint16.bind(valueView));
      return value;

    case _ContractFunctionSelector.ArgumentType.int16:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 30, valueView.setInt16.bind(valueView));
      return value;

    case _ContractFunctionSelector.ArgumentType.uint32:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 28, valueView.setUint32.bind(valueView));
      return value;

    case _ContractFunctionSelector.ArgumentType.int32:
      numberToBytes(
      /** @type {number | BigNumber } */
      param, 28, valueView.setInt32.bind(valueView));
      return value;
    // int64, uint64, and int256 both expect the parameter to be an Uint8Array instead of number

    case _ContractFunctionSelector.ArgumentType.uint64:
    case _ContractFunctionSelector.ArgumentType.int64:
      if (_bignumber.default.isBigNumber(param)) {
        // eslint-disable-next-line no-case-declarations
        let par = param.toString(16);

        if (par.length > 16) {
          throw new TypeError("uint64/int64 requires BigNumber to be less than or equal to 8 bytes");
        } else if (!param.isInteger()) {
          throw new TypeError("uint64/int64 requires BigNumber to be an integer");
        }

        if (par.length % 2 === 1) {
          par = `0${par}`;
        } // eslint-disable-next-line no-case-declarations


        const buf = hex.decode(par);
        value.set(buf, 32 - buf.length);
      }

      return value;

    case _ContractFunctionSelector.ArgumentType.int256:
    case _ContractFunctionSelector.ArgumentType.uint256:
      if (_bignumber.default.isBigNumber(param)) {
        let par = param.toString(16);

        if (par.length % 2 === 1) {
          par = `0${par}`;
        }

        const buf = hex.decode(par);
        value.set(buf, 32 - buf.length);
      }

      return value;

    case _ContractFunctionSelector.ArgumentType.address:
      value.set(
      /** @type {Uint8Array} */
      param, 32 - 20);
      return value;

    case _ContractFunctionSelector.ArgumentType.bool:
      value[31] =
      /** @type {boolean} */
      param ? 1 : 0;
      return value;

    case _ContractFunctionSelector.ArgumentType.func:
      value.set(
      /** @type {Uint8Array} */
      param, 32 - 24);
      return value;

    case _ContractFunctionSelector.ArgumentType.bytes32:
      value.set(
      /** @type {Uint8Array} */
      param, 0);
      return value;
    // Bytes should have not the length already encoded
    // JS String type is encoded as UTF-16 whilst Solidity `string` type is UTF-8 encoded.
    // So if will assume is already correctly updated to being a Uint8Array of UTF-8 string

    case _ContractFunctionSelector.ArgumentType.bytes:
    case _ContractFunctionSelector.ArgumentType.string:
      // If value is of type string, encode it in UTF-8 format and conver it to Uint8Array
      // Required because JS Strings are UTF-16
      // eslint-disable-next-line no-case-declarations
      par = param instanceof Uint8Array ? param : utf8.encode(
      /** @type {string} */
      param); // Resize value to a 32 byte boundary if needed

      if (Math.floor(par.length / 32) >= 0 && Math.floor(par.length % 32) !== 0) {
        value = new Uint8Array((Math.floor(par.length / 32) + 1) * 32 + 32);
      } else {
        value = new Uint8Array(64);
      }

      value.set(par, 32);
      valueView = new DataView(value.buffer, 28);
      valueView.setUint32(0, par.length);
      return value;

    default:
      throw new Error(`Unsupported argument type: ${ty.toString()}`);
  }
}
/**
 * @param {number | BigNumber} param
 * @param {number} byteoffset
 * @param {(byteOffset: number, value: number) => void} func
 * @returns {void}
 */


function numberToBytes(param, byteoffset, func) {
  const value = _bignumber.default.isBigNumber(param) ? param.toNumber() : param;
  func(byteoffset, value);
}

/***/ }),

/***/ 5971:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ContractLogInfo = _interopRequireDefault(__nccwpck_require__(3795));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

var hex = _interopRequireWildcard(__nccwpck_require__(819));

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IContractFunctionResult} proto.IContractFunctionResult
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 */

/**
 * The result returned by a call to a smart contract function. This is part of the response to
 * a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
 * transaction. The ContractCreateInstance transaction record has the results of the call to
 * the constructor.
 */
class ContractFunctionResult {
  /**
   * Constructor isn't part of the stable API
   *
   * @param {object} result
   * @param {?ContractId} result.contractId
   * @param {?string} result.errorMessage
   * @param {Uint8Array} result.bloom
   * @param {Long} result.gasUsed
   * @param {ContractLogInfo[]} result.logs
   * @param {Uint8Array} result.bytes
   */
  constructor(result) {
    /**
     * The smart contract instance whose function was called.
     */
    this.contractId = result.contractId;
    this.bytes = result.bytes;
    /**
     * Message In case there was an error during smart contract execution.
     */

    this.errorMessage = result.errorMessage;
    /**
     * Bloom filter for record
     */

    this.bloom = result.bloom;
    /**
     * Units of gas used  to execute contract.
     */

    this.gasUsed = result.gasUsed;
    /**
     * The log info for events returned by the function.
     */

    this.logs = result.logs;
  }
  /**
   * @param {proto.IContractFunctionResult} result
   * @returns {ContractFunctionResult}
   */


  static _fromProtobuf(result) {
    const contractId =
    /** @type {proto.IContractID | null} */
    result.contractID;
    const gas =
    /** @type {Long | number} */
    result.gasUsed;
    return new ContractFunctionResult({
      bytes:
      /** @type {Uint8Array} */
      result.contractCallResult,
      contractId: contractId != null ? _ContractId.default._fromProtobuf(contractId) : null,
      errorMessage: result.errorMessage != null ? result.errorMessage : null,
      bloom:
      /** @type {Uint8Array} */
      result.bloom,
      gasUsed: gas instanceof _long.default ? gas : _long.default.fromValue(gas),
      logs: (result.logInfo != null ? result.logInfo : []).map(info => _ContractLogInfo.default._fromProtobuf(info))
    });
  }
  /**
   * @returns {Uint8Array}
   */


  asBytes() {
    return this.bytes;
  }
  /**
   * @param {number} [index]
   * @returns {string}
   */


  getString(index) {
    return utf8.decode(this.getBytes(index));
  }
  /**
   * @private
   * @param {number} [index]
   * @returns {Uint8Array}
   */


  getBytes(index) {
    // Len should never be larger than Number.MAX
    // index * 32 is the position of the lenth
    // (index + 1) * 32 onward to (index + 1) * 32 + len will be the elements of the array
    // Arrays in solidity cannot be longer than 1024:
    // https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html
    const offset = this.getInt32(index);
    const len = new DataView(this.bytes.buffer, this.bytes.byteOffset + offset + 28, 4).getInt32(0);
    return this.bytes.subarray(offset + 32, offset + 32 + len);
  }
  /**
   * @param {number} [index]
   * @returns {Uint8Array}
   */


  getBytes32(index) {
    return this.bytes.subarray((index != null ? index : 0) * 32, (index != null ? index : 0) * 32 + 32);
  }
  /**
   * @param {number} [index]
   * @returns {boolean}
   */


  getBool(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */


  getInt8(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31];
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */


  getInt32(index) {
    // .getInt32() interprets as big-endian
    // Using DataView instead of Uint32Array because the latter interprets
    // using platform endianness which is little-endian on x86
    return new DataView(this.bytes.buffer, this.bytes.byteOffset + (index != null ? index : 0) * 32 + 28, 4).getInt32(0);
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */


  getInt64(index) {
    return new _bignumber.default(hex.encode(this._getBytes32(index != null ? index : 0).subarray(24, 32)), 16);
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */


  getInt256(index) {
    return new _bignumber.default(hex.encode(this._getBytes32(index != null ? index : 0)), 16);
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */


  getUint8(index) {
    return this.bytes[(index != null ? index : 0) * 32 + 31];
  }
  /**
   * @param {number} [index]
   * @returns {number}
   */


  getUint32(index) {
    // .getUint32() interprets as big-endian
    // Using DataView instead of Uint32Array because the latter interprets
    // using platform endianness which is little-endian on x86
    return new DataView(this.bytes.buffer, this.bytes.byteOffset + (index != null ? index : 0) * 32 + 28, 4).getUint32(0);
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */


  getUint64(index) {
    return new _bignumber.default(hex.encode(this._getBytes32(index).subarray(24, 32)), 16);
  }
  /**
   * @param {number} [index]
   * @returns {BigNumber}
   */


  getUint256(index) {
    return new _bignumber.default(hex.encode(this._getBytes32(index)), 16);
  }
  /**
   * @param {number} [index]
   * @returns {string}
   */


  getAddress(index) {
    return hex.encode(this.bytes.subarray((index != null ? index : 0) * 32 + 12, (index != null ? index : 0) * 32 + 32));
  }
  /**
   * @param {number} [index]
   * @returns {Uint8Array}
   */


  _getBytes32(index) {
    return this.bytes.subarray((index != null ? index : 0) * 32, (index != null ? index : 0) * 32 + 32);
  }

}

exports.default = ContractFunctionResult;

/***/ }),

/***/ 8347:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = exports.ArgumentType = void 0;

var _keccak = __nccwpck_require__(9652);

/**
 * @enum {number}
 */
const ArgumentType = {
  uint8: 0,
  int8: 1,
  uint16: 2,
  int16: 3,
  uint32: 4,
  int32: 5,
  uint64: 6,
  int64: 7,
  uint256: 8,
  int256: 9,
  string: 10,
  bool: 11,
  bytes: 12,
  bytes32: 13,
  address: 14,
  func: 15
};
/**
 * @typedef {object} Argument
 * @property {boolean} dynamic
 * @property {Uint8Array} value
 */

/**
 * @typedef {object} SolidityType
 * @property {ArgumentType} ty
 * @property {boolean} array
 */

exports.ArgumentType = ArgumentType;

class ContractFunctionSelector {
  /**
   * @param {string} [name]
   */
  constructor(name) {
    /**
     * @type {?string}
     */
    this.name = null;
    /**
     * @type {string}
     */

    this._params = "";
    /**
     * @type {SolidityType[]}
     */

    this._paramTypes = [];

    if (name != null) {
      this._name = name;
    }
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addString() {
    return this._addParam({
      ty: ArgumentType.string,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addStringArray() {
    return this._addParam({
      ty: ArgumentType.string,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addBytes() {
    return this._addParam({
      ty: ArgumentType.bytes,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addBytes32() {
    return this._addParam({
      ty: ArgumentType.bytes32,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addBytesArray() {
    return this._addParam({
      ty: ArgumentType.bytes,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addBytes32Array() {
    return this._addParam({
      ty: ArgumentType.bytes32,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt8() {
    return this._addParam({
      ty: ArgumentType.int8,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt32() {
    return this._addParam({
      ty: ArgumentType.int32,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt64() {
    return this._addParam({
      ty: ArgumentType.int64,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt256() {
    return this._addParam({
      ty: ArgumentType.int256,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt8Array() {
    return this._addParam({
      ty: ArgumentType.int8,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt32Array() {
    return this._addParam({
      ty: ArgumentType.int32,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt64Array() {
    return this._addParam({
      ty: ArgumentType.int64,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addInt256Array() {
    return this._addParam({
      ty: ArgumentType.int256,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint8() {
    return this._addParam({
      ty: ArgumentType.uint8,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint32() {
    return this._addParam({
      ty: ArgumentType.uint32,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint64() {
    return this._addParam({
      ty: ArgumentType.uint64,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint256() {
    return this._addParam({
      ty: ArgumentType.uint256,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint8Array() {
    return this._addParam({
      ty: ArgumentType.uint8,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint32Array() {
    return this._addParam({
      ty: ArgumentType.uint32,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint64Array() {
    return this._addParam({
      ty: ArgumentType.uint64,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addUint256Array() {
    return this._addParam({
      ty: ArgumentType.uint256,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addBool() {
    return this._addParam({
      ty: ArgumentType.bool,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addAddress() {
    return this._addParam({
      ty: ArgumentType.address,
      array: false
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addAddressArray() {
    return this._addParam({
      ty: ArgumentType.address,
      array: true
    });
  }
  /**
   * @returns {ContractFunctionSelector}
   */


  addFunction() {
    return this._addParam({
      ty: ArgumentType.func,
      array: false
    });
  }
  /**
   * @param {SolidityType} ty
   * @returns {ContractFunctionSelector}
   */


  _addParam(ty) {
    if (this._paramTypes.length > 0) {
      this._params += ",";
    }

    this._params += solidityTypeToString(ty);

    this._paramTypes.push(ty);

    return this;
  }
  /**
   * @param {string} [name]
   * @returns {Uint8Array}
   */


  _build(name) {
    if (name != null) {
      this._name = name;
    } else if (this._name == null) {
      throw new Error("`name` required for ContractFunctionSelector");
    }

    return new Uint8Array((0, _keccak.keccak256)(this.toString()).slice(0, 4));
  }
  /**
   * @returns {string}
   */


  toString() {
    return `${this._name != null ? this._name.toString() : ""}(${this._params})`;
  }

}
/**
 * @param {SolidityType} ty
 * @returns {string}
 */


exports.default = ContractFunctionSelector;

function solidityTypeToString(ty) {
  let s = "";

  switch (ty.ty) {
    case ArgumentType.uint8:
      s = "uint8";
      break;

    case ArgumentType.int8:
      s = "int8";
      break;

    case ArgumentType.uint16:
      s = "uint16";
      break;

    case ArgumentType.int16:
      s = "int16";
      break;

    case ArgumentType.uint32:
      s = "uint32";
      break;

    case ArgumentType.int32:
      s = "int32";
      break;

    case ArgumentType.uint64:
      s = "uint64";
      break;

    case ArgumentType.int64:
      s = "int64";
      break;

    case ArgumentType.uint256:
      s = "uint256";
      break;

    case ArgumentType.int256:
      s = "int256";
      break;

    case ArgumentType.string:
      s = "string";
      break;

    case ArgumentType.bool:
      s = "bool";
      break;

    case ArgumentType.bytes:
      s = "bytes";
      break;

    case ArgumentType.bytes32:
      s = "bytes32";
      break;

    case ArgumentType.address:
      s = "address";
      break;

    case ArgumentType.func:
      s = "function";
      break;

    default:
      s = "";
      break;
  }

  if (ty.array) {
    s += "[]";
  }

  return s;
}

/***/ }),

/***/ 9954:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var _cryptography = __nccwpck_require__(7410);

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency contract on Hedera.
 */
class ContractId extends _cryptography.Key {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    super();
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {ContractId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new ContractId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.IContractID} id
   * @param {(string | null)=} ledgerId
   * @returns {ContractId}
   */


  static _fromProtobuf(id, ledgerId) {
    const contractId = new ContractId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.contractNum != null ? id.contractNum : 0);

    if (ledgerId != null) {
      contractId._setNetwork(ledgerId);
    }

    return contractId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ContractId}
   */


  static fromBytes(bytes) {
    return ContractId._fromProtobuf(proto.ContractID.decode(bytes));
  }
  /**
   * @param {string} address
   * @returns {ContractId}
   */


  static fromSolidityAddress(address) {
    const [shard, realm, contract] = entity_id.fromSolidityAddress(address);
    return new ContractId(shard, realm, contract);
  }
  /**
   * @override
   * @internal
   * @returns {proto.IContractID}
   */


  _toProtobuf() {
    return {
      contractNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.ContractID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {ContractId}
   */


  clone() {
    const id = new ContractId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = ContractId;

/***/ }),

/***/ 8197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _protobuf = __nccwpck_require__(223);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _TokenRelationshipMap = _interopRequireDefault(__nccwpck_require__(5985));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class ContractInfo {
  /**
   * @private
   * @param {object} props
   * @param {ContractId} props.contractId
   * @param {AccountId} props.accountId
   * @param {string} props.contractAccountId
   * @param {?Key} props.adminKey
   * @param {Timestamp} props.expirationTime
   * @param {Duration} props.autoRenewPeriod
   * @param {Long} props.storage
   * @param {string} props.contractMemo
   * @param {Hbar} props.balance
   * @param {boolean} props.isDeleted
   * @param {TokenRelationshipMap} props.tokenRelationships
   */
  constructor(props) {
    /**
     * ID of the contract instance, in the format used in transactions.
     *
     * @readonly
     */
    this.contractId = props.contractId;
    /**
     * ID of the cryptocurrency account owned by the contract instance,
     * in the format used in transactions.
     *
     * @readonly
     */

    this.accountId = props.accountId;
    /**
     * ID of both the contract instance and the cryptocurrency account owned by the contract
     * instance, in the format used by Solidity.
     *
     * @readonly
     */

    this.contractAccountId = props.contractAccountId;
    /**
     * The state of the instance and its fields can be modified arbitrarily if this key signs a
     * transaction to modify it. If this is null, then such modifications are not possible,
     * and there is no administrator that can override the normal operation of this smart
     * contract instance. Note that if it is created with no admin keys, then there is no
     * administrator to authorize changing the admin keys, so there can never be any admin keys
     * for that instance.
     *
     * @readonly
     */

    this.adminKey = props.adminKey != null ? props.adminKey : null;
    /**
     * The current time at which this contract instance (and its account) is set to expire.
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     * The expiration time will extend every this many seconds. If there are insufficient funds,
     * then it extends as long as possible. If the account is empty when it expires,
     * then it is deleted.
     *
     * @readonly
     */

    this.autoRenewPeriod = props.autoRenewPeriod;
    /**
     * Number of bytes of storage being used by this instance (which affects the cost to
     * extend the expiration time).
     *
     * @readonly
     */

    this.storage = props.storage;
    /**
     * The memo associated with the contract (max 100 bytes).
     *
     * @readonly
     */

    this.contractMemo = props.contractMemo;
    /**
     * The current balance of the contract.
     *
     * @readonly
     */

    this.balance = props.balance;
    /**
     * Whether the contract has been deleted
     *
     * @readonly
     */

    this.isDeleted = props.isDeleted;
    /**
     * The tokens associated to the contract
     *
     * @readonly
     */

    this.tokenRelationships = props.tokenRelationships;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IContractInfo} info
   * @param {(string | null)=} ledgerId
   * @returns {ContractInfo}
   */


  static _fromProtobuf(info, ledgerId) {
    const autoRenewPeriod =
    /** @type {Long | number} */

    /** @type {proto.IDuration} */
    info.autoRenewPeriod.seconds;
    return new ContractInfo({
      contractId: _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      info.contractID, ledgerId),
      accountId: _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      info.accountID, ledgerId),
      contractAccountId: info.contractAccountID != null ? info.contractAccountID : "",
      adminKey: info.adminKey != null ? (0, _protobuf.keyFromProtobuf)(info.adminKey, ledgerId) : null,
      expirationTime: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.expirationTime),
      autoRenewPeriod: new _Duration.default(autoRenewPeriod),
      storage: info.storage != null ? info.storage instanceof _long.default ? info.storage : _long.default.fromValue(info.storage) : _long.default.ZERO,
      contractMemo: info.memo != null ? info.memo : "",
      balance: _Hbar.default.fromTinybars(info.balance != null ? info.balance : 0),
      isDeleted:
      /** @type {boolean} */
      info.deleted,
      tokenRelationships: _TokenRelationshipMap.default._fromProtobuf(info.tokenRelationships != null ? info.tokenRelationships : [], ledgerId)
    });
  }
  /**
   * @internal
   * @returns {proto.IContractInfo}
   */


  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      accountID: this.accountId._toProtobuf(),
      contractAccountID: this.contractAccountId,
      adminKey: this.adminKey != null ? (0, _protobuf.keyToProtobuf)(this.adminKey) : null,
      expirationTime: this.expirationTime._toProtobuf(),
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      storage: this.storage,
      memo: this.contractMemo,
      balance: this.balance.toTinybars(),
      deleted: this.isDeleted,
      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ContractInfo}
   */


  static fromBytes(bytes) {
    return ContractInfo._fromProtobuf(proto.ContractGetInfoResponse.ContractInfo.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.ContractGetInfoResponse.ContractInfo.encode(this._toProtobuf()).finish();
  }

}

exports.default = ContractInfo;

/***/ }),

/***/ 2070:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _ContractInfo = _interopRequireDefault(__nccwpck_require__(8197));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractGetInfoQuery} proto.IContractGetInfoQuery
 * @typedef {import("@hashgraph/proto").IContractGetInfoResponse} proto.IContractGetInfoResponse
 * @typedef {import("@hashgraph/proto").IContractInfo} proto.IContractInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<ContractInfo>}
 */
class ContractInfoQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {ContractId | string} [props.contractId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?ContractId}
     * @private
     */

    this._contractId = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {ContractInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.IContractGetInfoQuery} */
    query.contractGetInfo;
    return new ContractInfoQuery({
      contractId: info.contractID != null ? _ContractId.default._fromProtobuf(info.contractID) : undefined
    });
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Set the contract ID for which the info is being requested.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractInfoQuery}
   */


  setContractId(contractId) {
    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.getContractInfo(request);
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const contractGetInfo =
    /** @type {proto.IContractGetInfoResponse} */
    response.contractGetInfo;
    return (
      /** @type {proto.IResponseHeader} */
      contractGetInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<ContractInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const info =
    /** @type {proto.IContractGetInfoResponse} */
    response.contractGetInfo;
    return Promise.resolve(_ContractInfo.default._fromProtobuf(
    /** @type {proto.IContractInfo} */
    info.contractInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      contractGetInfo: {
        header,
        contractID: this._contractId != null ? this._contractId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = ContractInfoQuery;

_Query.QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);

/***/ }),

/***/ 3795:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IContractLoginfo} proto.IContractLoginfo
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 */

/**
 * The log information for an event returned by a smart contract function call. One function call
 * may return several such events.
 */
class ContractLogInfo {
  /**
   * @param {object} props
   * @param {ContractId} props.contractId
   * @param {Uint8Array} props.bloom
   * @param {Uint8Array[]} props.topics
   * @param {Uint8Array} props.data
   */
  constructor(props) {
    /**
     * Address of a contract that emitted the event.
     *
     * @readonly
     */
    this.contractId = props.contractId;
    /**
     * Bloom filter for a particular log.
     *
     * @readonly
     */

    this.bloom = props.bloom;
    /**
     * Topics of a particular event.
     *
     * @readonly
     */

    this.topics = props.topics;
    /**
     * Event data.
     *
     * @readonly
     */

    this.data = props.data;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IContractLoginfo} info
   * @returns {ContractLogInfo}
   */


  static _fromProtobuf(info) {
    return new ContractLogInfo({
      contractId: _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      info.contractID),
      bloom: info.bloom != null ? info.bloom : new Uint8Array(),
      topics: info.topic != null ? info.topic : [],
      data: info.data != null ? info.data : new Uint8Array()
    });
  }
  /**
   * @internal
   * @returns {proto.IContractLoginfo}
   */


  _toProtobuf() {
    return {
      contractID: this.contractId._toProtobuf(),
      bloom: this.bloom,
      topic: this.topics,
      data: this.data
    };
  }

}

exports.default = ContractLogInfo;

/***/ }),

/***/ 2362:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractUpdateTransactionBody} proto.IContractUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class ContractUpdateTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {ContractId | string} [props.contractId]
   * @param {FileId | string} [props.bytecodeFileId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Key} [props.adminKey]
   * @param {AccountId | string} [props.proxyAccountId]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.contractMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._proxyAccountId = null;
    /**
     * @private
     * @type {?Duration}
     */

    this._autoRenewPeriod = null;
    /**
     * @private
     * @type {?FileId}
     */

    this._bytecodeFileId = null;
    /**
     * @private
     * @type {?string}
     */

    this._contractMemo = null;

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.proxyAccountId != null) {
      this.setProxyAccountId(props.proxyAccountId);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.bytecodeFileId != null) {
      this.setBytecodeFileId(props.bytecodeFileId);
    }

    if (props.contractMemo != null) {
      this.setContractMemo(props.contractMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ContractUpdateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update =
    /** @type {proto.IContractUpdateTransactionBody} */
    body.contractUpdateInstance;
    return _Transaction.default._fromProtobufTransactions(new ContractUpdateTransaction({
      contractId: update.contractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      update.contractID) : undefined,
      bytecodeFileId: update.fileID != null ? _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      update.fileID) : undefined,
      expirationTime: update.expirationTime != null ? _Timestamp.default._fromProtobuf(update.expirationTime) : undefined,
      adminKey: update.adminKey != null ? (0, _protobuf.keyFromProtobuf)(update.adminKey) : undefined,
      proxyAccountId: update.proxyAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      update.proxyAccountID) : undefined,
      autoRenewPeriod: update.autoRenewPeriod != null ? update.autoRenewPeriod.seconds != null ? update.autoRenewPeriod.seconds : undefined : undefined,
      contractMemo: update.memoWrapper != null ? update.memoWrapper.value != null ? update.memoWrapper.value : undefined : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {ContractId | string} contractId
   * @returns {ContractUpdateTransaction}
   */


  setContractId(contractId) {
    this._requireNotFrozen();

    this._contractId = typeof contractId === "string" ? _ContractId.default.fromString(contractId) : contractId.clone();
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Sets the contract ID which is being deleted in this transaction.
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {ContractUpdateTransaction}
   */


  setExpirationTime(expirationTime) {
    this._requireNotFrozen();

    this._expirationTime = expirationTime instanceof _Timestamp.default ? expirationTime : _Timestamp.default.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */


  setAdminKey(adminKey) {
    this._requireNotFrozen();

    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get proxyAccountId() {
    return this._proxyAccountId;
  }
  /**
   * @param {AccountId | string} proxyAccountId
   * @returns {this}
   */


  setProxyAccountId(proxyAccountId) {
    this._requireNotFrozen();

    this._proxyAccountId = typeof proxyAccountId === "string" ? _AccountId.default.fromString(proxyAccountId) : proxyAccountId.clone();
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?FileId}
   */


  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  /**
   * @param {FileId | string} bytecodeFileId
   * @returns {this}
   */


  setBytecodeFileId(bytecodeFileId) {
    this._requireNotFrozen();

    this._bytecodeFileId = typeof bytecodeFileId === "string" ? _FileId.default.fromString(bytecodeFileId) : bytecodeFileId.clone();
    return this;
  }
  /**
   * @returns {?string}
   */


  get contractMemo() {
    return this._contractMemo;
  }
  /**
   * @param {string} contractMemo
   * @returns {this}
   */


  setContractMemo(contractMemo) {
    this._requireNotFrozen();

    this._contractMemo = contractMemo;
    return this;
  }
  /**
   * @returns {this}
   */


  clearContractMemo() {
    this._requireNotFrozen();

    this._contractMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._contractId != null) {
      this._contractId.validate(client);
    }

    if (this._bytecodeFileId != null) {
      this._bytecodeFileId.validate(client);
    }

    if (this._proxyAccountId != null) {
      this._proxyAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.smartContract.updateContract(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "contractUpdateInstance";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IContractUpdateTransactionBody}
   */


  _makeTransactionData() {
    return {
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      proxyAccountID: this._proxyAccountId != null ? this._proxyAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      fileID: this._bytecodeFileId ? this._bytecodeFileId._toProtobuf() : null,
      memoWrapper: this._contractMemo != null ? {
        value: this._contractMemo
      } : null
    };
  }

}

exports.default = ContractUpdateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("contractUpdateInstance", // eslint-disable-next-line @typescript-eslint/unbound-method
ContractUpdateTransaction._fromProtobuf);

/***/ }),

/***/ 9652:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.keccak256 = void 0;
// Originally sourced from:
// https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
//  - added type declarations
//  - switched to es6 module syntax

/** @type {number[]} */
const KECCAK_PADDING = [1, 256, 65536, 16777216];
/** @type {number[]} */

const SHIFT = [0, 8, 16, 24];
/** @type {number[]} */

const RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
/**
 * @typedef {object} Keccak
 * @property {number[]} blocks
 * @property {number} blockCount
 * @property {number} outputBlocks
 * @property {number[]} s
 * @property {number} start
 * @property {number} block
 * @property {boolean} reset
 * @property {?number} lastByteIndex
 */

/**
 * @param {number} bits
 * @returns {Keccak}
 */

function createKeccakState(bits) {
  return {
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    lastByteIndex: null,
    blockCount: 1600 - (bits << 1) >> 5,
    outputBlocks: bits >> 5,
    s: zeroFill(50)
  };
}
/**
 * @param {number} n
 * @returns {number[]}
 */


function zeroFill(n) {
  /** @type {number[]} */
  let arr = Array(n);

  for (let i = 0; i < n; ++i) arr[i] = 0;

  return arr;
}
/**
 * @param {Keccak} state
 * @param {string} message
 * @returns {Uint8Array}
 */


function update(state, message) {
  var length = message.length,
      blocks = state.blocks,
      byteCount = state.blockCount << 2,
      blockCount = state.blockCount,
      outputBlocks = state.outputBlocks,
      s = state.s,
      index = 0,
      i = 0,
      code; // update

  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;

      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }

    for (i = state.start; index < length && i < byteCount; ++index) {
      code = message.charCodeAt(index);

      if (code < 0x80) {
        blocks[i >> 2] |= code << SHIFT[i++ & 3];
      } else if (code < 0x800) {
        blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
      } else if (code < 0xd800 || code >= 0xe000) {
        blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
      } else {
        code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
        blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
      }
    }

    state.lastByteIndex = i;

    if (i >= byteCount) {
      state.start = i - byteCount;
      state.block = blocks[blockCount];

      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }

      f(s);
      state.reset = true;
    } else {
      state.start = i;
    }
  } // finalize


  i =
  /** @type {number} */
  state.lastByteIndex;
  blocks[i >> 2] |= KECCAK_PADDING[i & 3];

  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];

    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }

  blocks[blockCount - 1] |= 0x80000000;

  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }

  f(s);
  const buffer = new ArrayBuffer(outputBlocks * 4);
  const view = new DataView(buffer);
  i = 0;
  var j = 0;

  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      view.setInt32(i * 4, s[i], true);
    }

    if (j % blockCount === 0) {
      f(s);
      i = 0;
    }
  }

  return new Uint8Array(buffer);
}
/**
 * @param {number[]} s
 */


function f(s) {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ (c2 << 1 | c3 >>> 31);
    l = c9 ^ (c3 << 1 | c2 >>> 31);
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ (c4 << 1 | c5 >>> 31);
    l = c1 ^ (c5 << 1 | c4 >>> 31);
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ (c6 << 1 | c7 >>> 31);
    l = c3 ^ (c7 << 1 | c6 >>> 31);
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ (c8 << 1 | c9 >>> 31);
    l = c5 ^ (c9 << 1 | c8 >>> 31);
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ (c0 << 1 | c1 >>> 31);
    l = c7 ^ (c1 << 1 | c0 >>> 31);
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = s[11] << 4 | s[10] >>> 28;
    b33 = s[10] << 4 | s[11] >>> 28;
    b14 = s[20] << 3 | s[21] >>> 29;
    b15 = s[21] << 3 | s[20] >>> 29;
    b46 = s[31] << 9 | s[30] >>> 23;
    b47 = s[30] << 9 | s[31] >>> 23;
    b28 = s[40] << 18 | s[41] >>> 14;
    b29 = s[41] << 18 | s[40] >>> 14;
    b20 = s[2] << 1 | s[3] >>> 31;
    b21 = s[3] << 1 | s[2] >>> 31;
    b2 = s[13] << 12 | s[12] >>> 20;
    b3 = s[12] << 12 | s[13] >>> 20;
    b34 = s[22] << 10 | s[23] >>> 22;
    b35 = s[23] << 10 | s[22] >>> 22;
    b16 = s[33] << 13 | s[32] >>> 19;
    b17 = s[32] << 13 | s[33] >>> 19;
    b48 = s[42] << 2 | s[43] >>> 30;
    b49 = s[43] << 2 | s[42] >>> 30;
    b40 = s[5] << 30 | s[4] >>> 2;
    b41 = s[4] << 30 | s[5] >>> 2;
    b22 = s[14] << 6 | s[15] >>> 26;
    b23 = s[15] << 6 | s[14] >>> 26;
    b4 = s[25] << 11 | s[24] >>> 21;
    b5 = s[24] << 11 | s[25] >>> 21;
    b36 = s[34] << 15 | s[35] >>> 17;
    b37 = s[35] << 15 | s[34] >>> 17;
    b18 = s[45] << 29 | s[44] >>> 3;
    b19 = s[44] << 29 | s[45] >>> 3;
    b10 = s[6] << 28 | s[7] >>> 4;
    b11 = s[7] << 28 | s[6] >>> 4;
    b42 = s[17] << 23 | s[16] >>> 9;
    b43 = s[16] << 23 | s[17] >>> 9;
    b24 = s[26] << 25 | s[27] >>> 7;
    b25 = s[27] << 25 | s[26] >>> 7;
    b6 = s[36] << 21 | s[37] >>> 11;
    b7 = s[37] << 21 | s[36] >>> 11;
    b38 = s[47] << 24 | s[46] >>> 8;
    b39 = s[46] << 24 | s[47] >>> 8;
    b30 = s[8] << 27 | s[9] >>> 5;
    b31 = s[9] << 27 | s[8] >>> 5;
    b12 = s[18] << 20 | s[19] >>> 12;
    b13 = s[19] << 20 | s[18] >>> 12;
    b44 = s[29] << 7 | s[28] >>> 25;
    b45 = s[28] << 7 | s[29] >>> 25;
    b26 = s[38] << 8 | s[39] >>> 24;
    b27 = s[39] << 8 | s[38] >>> 24;
    b8 = s[48] << 14 | s[49] >>> 18;
    b9 = s[49] << 14 | s[48] >>> 18;
    s[0] = b0 ^ ~b2 & b4;
    s[1] = b1 ^ ~b3 & b5;
    s[10] = b10 ^ ~b12 & b14;
    s[11] = b11 ^ ~b13 & b15;
    s[20] = b20 ^ ~b22 & b24;
    s[21] = b21 ^ ~b23 & b25;
    s[30] = b30 ^ ~b32 & b34;
    s[31] = b31 ^ ~b33 & b35;
    s[40] = b40 ^ ~b42 & b44;
    s[41] = b41 ^ ~b43 & b45;
    s[2] = b2 ^ ~b4 & b6;
    s[3] = b3 ^ ~b5 & b7;
    s[12] = b12 ^ ~b14 & b16;
    s[13] = b13 ^ ~b15 & b17;
    s[22] = b22 ^ ~b24 & b26;
    s[23] = b23 ^ ~b25 & b27;
    s[32] = b32 ^ ~b34 & b36;
    s[33] = b33 ^ ~b35 & b37;
    s[42] = b42 ^ ~b44 & b46;
    s[43] = b43 ^ ~b45 & b47;
    s[4] = b4 ^ ~b6 & b8;
    s[5] = b5 ^ ~b7 & b9;
    s[14] = b14 ^ ~b16 & b18;
    s[15] = b15 ^ ~b17 & b19;
    s[24] = b24 ^ ~b26 & b28;
    s[25] = b25 ^ ~b27 & b29;
    s[34] = b34 ^ ~b36 & b38;
    s[35] = b35 ^ ~b37 & b39;
    s[44] = b44 ^ ~b46 & b48;
    s[45] = b45 ^ ~b47 & b49;
    s[6] = b6 ^ ~b8 & b0;
    s[7] = b7 ^ ~b9 & b1;
    s[16] = b16 ^ ~b18 & b10;
    s[17] = b17 ^ ~b19 & b11;
    s[26] = b26 ^ ~b28 & b20;
    s[27] = b27 ^ ~b29 & b21;
    s[36] = b36 ^ ~b38 & b30;
    s[37] = b37 ^ ~b39 & b31;
    s[46] = b46 ^ ~b48 & b40;
    s[47] = b47 ^ ~b49 & b41;
    s[8] = b8 ^ ~b0 & b2;
    s[9] = b9 ^ ~b1 & b3;
    s[18] = b18 ^ ~b10 & b12;
    s[19] = b19 ^ ~b11 & b13;
    s[28] = b28 ^ ~b20 & b22;
    s[29] = b29 ^ ~b21 & b23;
    s[38] = b38 ^ ~b30 & b32;
    s[39] = b39 ^ ~b31 & b33;
    s[48] = b48 ^ ~b40 & b42;
    s[49] = b49 ^ ~b41 & b43;
    s[0] ^= RC[n];
    s[1] ^= RC[n + 1];
  }
}
/**
 * @param {number} bits
 * @returns {(message: string) => Uint8Array}
 */


function createKeccak(bits) {
  return function (message) {
    return update(createKeccakState(bits), message);
  };
}

const keccak256 = createKeccak(256);
exports.keccak256 = keccak256;

/***/ }),

/***/ 223:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.keyToProtobuf = keyToProtobuf;
exports.keyListToProtobuf = keyListToProtobuf;
exports.keyFromProtobuf = keyFromProtobuf;
exports.keyListFromProtobuf = keyListFromProtobuf;

var _cryptography = __nccwpck_require__(7410);

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IKeyList} proto.IKeyList
 * @typedef {import("@hashgraph/proto").IThresholdKey} proto.IThresholdKey
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */

/**
 * @param {Key} key
 * @returns {proto.IKey}
 */
function keyToProtobuf(key) {
  if (key instanceof _cryptography.PrivateKey) {
    key = key.publicKey;
  }

  if (key instanceof _cryptography.PublicKey) {
    return {
      ed25519: key.toBytes()
    };
  }

  if (key instanceof _cryptography.KeyList) {
    if (key.threshold == null) {
      return {
        keyList: keyListToProtobuf(key)
      };
    } else {
      return {
        thresholdKey: {
          threshold: key.threshold,
          keys: keyListToProtobuf(key)
        }
      };
    }
  }

  if (key instanceof _ContractId.default) {
    return {
      contractID: key._toProtobuf()
    };
  }

  throw new Error(`(BUG) keyToProtobuf: unsupported key type: ${key.constructor.name}`);
}
/**
 * @param {KeyList} list
 * @returns {proto.IKeyList}
 */


function keyListToProtobuf(list) {
  const keys = [];

  for (const key of list) {
    keys.push(keyToProtobuf(key));
  }

  return {
    keys
  };
}
/**
 * @param {proto.IKey} key
 * @param {(string | null)=} ledgerId
 * @returns {KeyList | PublicKey | ContractId}
 */


function keyFromProtobuf(key, ledgerId) {
  if (key.contractID != null) {
    return _ContractId.default._fromProtobuf(key.contractID, ledgerId);
  }

  if (key.ed25519 != null && key.ed25519.byteLength > 0) {
    return _cryptography.PublicKey.fromBytes(key.ed25519);
  }

  if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
    const kl = key.thresholdKey.keys != null ? keyListFromProtobuf(key.thresholdKey.keys) : new _cryptography.KeyList();
    kl.setThreshold(key.thresholdKey.threshold);
    return kl;
  }

  if (key.keyList != null) {
    return keyListFromProtobuf(key.keyList);
  }

  throw new Error(`(BUG) keyFromProtobuf: not implemented key case: ${JSON.stringify(key)}`);
}
/**
 * @param {proto.IKeyList} keys
 * @returns {KeyList}
 */


function keyListFromProtobuf(keys) {
  if (keys.keys == null) {
    return new _cryptography.KeyList();
  }

  return _cryptography.KeyList.from(keys.keys, keyFromProtobuf);
}

/***/ }),

/***/ 8141:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.digest = digest;

var _crypto = _interopRequireDefault(__nccwpck_require__(6417));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
function digest(data) {
  // fallback to trying node-crypto which could be polyfilled by the browser environment
  return Promise.resolve(_crypto.default.createHash("sha384").update(data).digest());
}

/***/ }),

/***/ 819:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encode = encode;
exports.decode = decode;

/**
 * @type {string[]}
 */
const byteToHex = [];

for (let n = 0; n <= 0xff; n += 1) {
  byteToHex.push(n.toString(16).padStart(2, "0"));
}
/**
 * @param {Uint8Array} data
 * @returns {string}
 */


function encode(data) {
  return Buffer.from(data).toString("hex");
}
/**
 * @param {string} text
 * @returns {Uint8Array}
 */


function decode(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  return Buffer.from(str, "hex");
}

/***/ }),

/***/ 3251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decode = decode;
exports.encode = encode;

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function decode(data) {
  return Buffer.from(data).toString("utf8");
}
/**
 * @param {string} text
 * @returns {Uint8Array}
 */


function encode(text) {
  return Buffer.from(text, "utf8");
}

/***/ }),

/***/ 934:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  AccountBalanceQuery: true,
  AccountCreateTransaction: true,
  AccountDeleteTransaction: true,
  AccountId: true,
  AccountInfo: true,
  AccountInfoQuery: true,
  AccountRecordsQuery: true,
  AccountStakersQuery: true,
  AccountUpdateTransaction: true,
  ContractByteCodeQuery: true,
  ContractCallQuery: true,
  ContractCreateTransaction: true,
  ContractDeleteTransaction: true,
  ContractExecuteTransaction: true,
  ContractFunctionParameters: true,
  ContractFunctionResult: true,
  ContractFunctionSelector: true,
  ContractId: true,
  ContractInfo: true,
  ContractInfoQuery: true,
  ContractLogInfo: true,
  ContractUpdateTranscation: true,
  ExchangeRate: true,
  FileAppendTransaction: true,
  FileContentsQuery: true,
  FileCreateTransaction: true,
  FileDeleteTransaction: true,
  FileId: true,
  FileInfo: true,
  FileInfoQuery: true,
  FileUpdateTransaction: true,
  FreezeTransaction: true,
  Hbar: true,
  HbarUnit: true,
  LiveHash: true,
  LiveHashAddTransaction: true,
  LiveHashDeleteTransaction: true,
  LiveHashQuery: true,
  NetworkName: true,
  NetworkVersionInfo: true,
  NetworkVersionInfoQuery: true,
  ProxyStaker: true,
  Query: true,
  ScheduleCreateTransaction: true,
  ScheduleDeleteTransaction: true,
  ScheduleId: true,
  ScheduleInfo: true,
  ScheduleInfoQuery: true,
  ScheduleSignTransaction: true,
  SemanticVersion: true,
  Status: true,
  SystemDeleteTransaction: true,
  SystemUndeleteTransaction: true,
  Timestamp: true,
  TokenAssociateTransaction: true,
  TokenBurnTransaction: true,
  TokenCreateTransaction: true,
  TokenDeleteTransaction: true,
  TokenDissociateTransaction: true,
  TokenFreezeTransaction: true,
  TokenGrantKycTransaction: true,
  TokenId: true,
  TokenInfo: true,
  TokenInfoQuery: true,
  TokenMintTransaction: true,
  TokenRelationship: true,
  TokenRelationshipMap: true,
  TokenRevokeKycTransaction: true,
  TokenUnfreezeTransaction: true,
  TokenUpdateTransaction: true,
  TokenWipeTransaction: true,
  TopicCreateTransaction: true,
  TopicDeleteTransaction: true,
  TopicId: true,
  TopicInfo: true,
  TopicInfoQuery: true,
  TopicMessage: true,
  TopicMessageChunk: true,
  TopicMessageQuery: true,
  TopicMessageSubmitTransaction: true,
  TopicUpdateTransaction: true,
  Transaction: true,
  TransactionId: true,
  TransactionReceipt: true,
  TransactionReceiptQuery: true,
  TransactionRecord: true,
  TransactionRecordQuery: true,
  TransactionResponse: true,
  Transfer: true,
  TransferTransaction: true,
  StatusError: true,
  PrecheckStatusError: true,
  ReceiptStatusError: true
};
Object.defineProperty(exports, "AccountBalanceQuery", ({
  enumerable: true,
  get: function () {
    return _AccountBalanceQuery.default;
  }
}));
Object.defineProperty(exports, "AccountCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _AccountCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "AccountDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _AccountDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "AccountId", ({
  enumerable: true,
  get: function () {
    return _AccountId.default;
  }
}));
Object.defineProperty(exports, "AccountInfo", ({
  enumerable: true,
  get: function () {
    return _AccountInfo.default;
  }
}));
Object.defineProperty(exports, "AccountInfoQuery", ({
  enumerable: true,
  get: function () {
    return _AccountInfoQuery.default;
  }
}));
Object.defineProperty(exports, "AccountRecordsQuery", ({
  enumerable: true,
  get: function () {
    return _AccountRecordsQuery.default;
  }
}));
Object.defineProperty(exports, "AccountStakersQuery", ({
  enumerable: true,
  get: function () {
    return _AccountStakersQuery.default;
  }
}));
Object.defineProperty(exports, "AccountUpdateTransaction", ({
  enumerable: true,
  get: function () {
    return _AccountUpdateTransaction.default;
  }
}));
Object.defineProperty(exports, "ContractByteCodeQuery", ({
  enumerable: true,
  get: function () {
    return _ContractByteCodeQuery.default;
  }
}));
Object.defineProperty(exports, "ContractCallQuery", ({
  enumerable: true,
  get: function () {
    return _ContractCallQuery.default;
  }
}));
Object.defineProperty(exports, "ContractCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _ContractCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "ContractDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _ContractDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "ContractExecuteTransaction", ({
  enumerable: true,
  get: function () {
    return _ContractExecuteTransaction.default;
  }
}));
Object.defineProperty(exports, "ContractFunctionParameters", ({
  enumerable: true,
  get: function () {
    return _ContractFunctionParameters.default;
  }
}));
Object.defineProperty(exports, "ContractFunctionResult", ({
  enumerable: true,
  get: function () {
    return _ContractFunctionResult.default;
  }
}));
Object.defineProperty(exports, "ContractFunctionSelector", ({
  enumerable: true,
  get: function () {
    return _ContractFunctionSelector.default;
  }
}));
Object.defineProperty(exports, "ContractId", ({
  enumerable: true,
  get: function () {
    return _ContractId.default;
  }
}));
Object.defineProperty(exports, "ContractInfo", ({
  enumerable: true,
  get: function () {
    return _ContractInfo.default;
  }
}));
Object.defineProperty(exports, "ContractInfoQuery", ({
  enumerable: true,
  get: function () {
    return _ContractInfoQuery.default;
  }
}));
Object.defineProperty(exports, "ContractLogInfo", ({
  enumerable: true,
  get: function () {
    return _ContractLogInfo.default;
  }
}));
Object.defineProperty(exports, "ContractUpdateTranscation", ({
  enumerable: true,
  get: function () {
    return _ContractUpdateTranscation.default;
  }
}));
Object.defineProperty(exports, "ExchangeRate", ({
  enumerable: true,
  get: function () {
    return _ExchangeRate.default;
  }
}));
Object.defineProperty(exports, "FileAppendTransaction", ({
  enumerable: true,
  get: function () {
    return _FileAppendTransaction.default;
  }
}));
Object.defineProperty(exports, "FileContentsQuery", ({
  enumerable: true,
  get: function () {
    return _FileContentsQuery.default;
  }
}));
Object.defineProperty(exports, "FileCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _FileCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "FileDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _FileDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "FileId", ({
  enumerable: true,
  get: function () {
    return _FileId.default;
  }
}));
Object.defineProperty(exports, "FileInfo", ({
  enumerable: true,
  get: function () {
    return _FileInfo.default;
  }
}));
Object.defineProperty(exports, "FileInfoQuery", ({
  enumerable: true,
  get: function () {
    return _FileInfoQuery.default;
  }
}));
Object.defineProperty(exports, "FileUpdateTransaction", ({
  enumerable: true,
  get: function () {
    return _FileUpdateTransaction.default;
  }
}));
Object.defineProperty(exports, "FreezeTransaction", ({
  enumerable: true,
  get: function () {
    return _FreezeTransaction.default;
  }
}));
Object.defineProperty(exports, "Hbar", ({
  enumerable: true,
  get: function () {
    return _Hbar.default;
  }
}));
Object.defineProperty(exports, "HbarUnit", ({
  enumerable: true,
  get: function () {
    return _HbarUnit.default;
  }
}));
Object.defineProperty(exports, "LiveHash", ({
  enumerable: true,
  get: function () {
    return _LiveHash.default;
  }
}));
Object.defineProperty(exports, "LiveHashAddTransaction", ({
  enumerable: true,
  get: function () {
    return _LiveHashAddTransaction.default;
  }
}));
Object.defineProperty(exports, "LiveHashDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _LiveHashDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "LiveHashQuery", ({
  enumerable: true,
  get: function () {
    return _LiveHashQuery.default;
  }
}));
Object.defineProperty(exports, "NetworkName", ({
  enumerable: true,
  get: function () {
    return _NetworkName.default;
  }
}));
Object.defineProperty(exports, "NetworkVersionInfo", ({
  enumerable: true,
  get: function () {
    return _NetworkVersionInfo.default;
  }
}));
Object.defineProperty(exports, "NetworkVersionInfoQuery", ({
  enumerable: true,
  get: function () {
    return _NetworkVersionInfoQuery.default;
  }
}));
Object.defineProperty(exports, "ProxyStaker", ({
  enumerable: true,
  get: function () {
    return _ProxyStaker.default;
  }
}));
Object.defineProperty(exports, "Query", ({
  enumerable: true,
  get: function () {
    return _Query.default;
  }
}));
Object.defineProperty(exports, "ScheduleCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _ScheduleCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "ScheduleDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _ScheduleDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "ScheduleId", ({
  enumerable: true,
  get: function () {
    return _ScheduleId.default;
  }
}));
Object.defineProperty(exports, "ScheduleInfo", ({
  enumerable: true,
  get: function () {
    return _ScheduleInfo.default;
  }
}));
Object.defineProperty(exports, "ScheduleInfoQuery", ({
  enumerable: true,
  get: function () {
    return _ScheduleInfoQuery.default;
  }
}));
Object.defineProperty(exports, "ScheduleSignTransaction", ({
  enumerable: true,
  get: function () {
    return _ScheduleSignTransaction.default;
  }
}));
Object.defineProperty(exports, "SemanticVersion", ({
  enumerable: true,
  get: function () {
    return _SemanticVersion.default;
  }
}));
Object.defineProperty(exports, "Status", ({
  enumerable: true,
  get: function () {
    return _Status.default;
  }
}));
Object.defineProperty(exports, "SystemDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _SystemDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "SystemUndeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _SystemUndeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "Timestamp", ({
  enumerable: true,
  get: function () {
    return _Timestamp.default;
  }
}));
Object.defineProperty(exports, "TokenAssociateTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenAssociateTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenBurnTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenBurnTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenDissociateTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenDissociateTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenFreezeTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenFreezeTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenGrantKycTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenGrantKycTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenId", ({
  enumerable: true,
  get: function () {
    return _TokenId.default;
  }
}));
Object.defineProperty(exports, "TokenInfo", ({
  enumerable: true,
  get: function () {
    return _TokenInfo.default;
  }
}));
Object.defineProperty(exports, "TokenInfoQuery", ({
  enumerable: true,
  get: function () {
    return _TokenInfoQuery.default;
  }
}));
Object.defineProperty(exports, "TokenMintTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenMintTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenRelationship", ({
  enumerable: true,
  get: function () {
    return _TokenRelationship.default;
  }
}));
Object.defineProperty(exports, "TokenRelationshipMap", ({
  enumerable: true,
  get: function () {
    return _TokenRelationshipMap.default;
  }
}));
Object.defineProperty(exports, "TokenRevokeKycTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenRevokeKycTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenUnfreezeTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenUnfreezeTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenUpdateTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenUpdateTransaction.default;
  }
}));
Object.defineProperty(exports, "TokenWipeTransaction", ({
  enumerable: true,
  get: function () {
    return _TokenWipeTransaction.default;
  }
}));
Object.defineProperty(exports, "TopicCreateTransaction", ({
  enumerable: true,
  get: function () {
    return _TopicCreateTransaction.default;
  }
}));
Object.defineProperty(exports, "TopicDeleteTransaction", ({
  enumerable: true,
  get: function () {
    return _TopicDeleteTransaction.default;
  }
}));
Object.defineProperty(exports, "TopicId", ({
  enumerable: true,
  get: function () {
    return _TopicId.default;
  }
}));
Object.defineProperty(exports, "TopicInfo", ({
  enumerable: true,
  get: function () {
    return _TopicInfo.default;
  }
}));
Object.defineProperty(exports, "TopicInfoQuery", ({
  enumerable: true,
  get: function () {
    return _TopicInfoQuery.default;
  }
}));
Object.defineProperty(exports, "TopicMessage", ({
  enumerable: true,
  get: function () {
    return _TopicMessage.default;
  }
}));
Object.defineProperty(exports, "TopicMessageChunk", ({
  enumerable: true,
  get: function () {
    return _TopicMessageChunk.default;
  }
}));
Object.defineProperty(exports, "TopicMessageQuery", ({
  enumerable: true,
  get: function () {
    return _TopicMessageQuery.default;
  }
}));
Object.defineProperty(exports, "TopicMessageSubmitTransaction", ({
  enumerable: true,
  get: function () {
    return _TopicMessageSubmitTransaction.default;
  }
}));
Object.defineProperty(exports, "TopicUpdateTransaction", ({
  enumerable: true,
  get: function () {
    return _TopicUpdateTransaction.default;
  }
}));
Object.defineProperty(exports, "Transaction", ({
  enumerable: true,
  get: function () {
    return _Transaction.default;
  }
}));
Object.defineProperty(exports, "TransactionId", ({
  enumerable: true,
  get: function () {
    return _TransactionId.default;
  }
}));
Object.defineProperty(exports, "TransactionReceipt", ({
  enumerable: true,
  get: function () {
    return _TransactionReceipt.default;
  }
}));
Object.defineProperty(exports, "TransactionReceiptQuery", ({
  enumerable: true,
  get: function () {
    return _TransactionReceiptQuery.default;
  }
}));
Object.defineProperty(exports, "TransactionRecord", ({
  enumerable: true,
  get: function () {
    return _TransactionRecord.default;
  }
}));
Object.defineProperty(exports, "TransactionRecordQuery", ({
  enumerable: true,
  get: function () {
    return _TransactionRecordQuery.default;
  }
}));
Object.defineProperty(exports, "TransactionResponse", ({
  enumerable: true,
  get: function () {
    return _TransactionResponse.default;
  }
}));
Object.defineProperty(exports, "Transfer", ({
  enumerable: true,
  get: function () {
    return _Transfer.default;
  }
}));
Object.defineProperty(exports, "TransferTransaction", ({
  enumerable: true,
  get: function () {
    return _TransferTransaction.default;
  }
}));
Object.defineProperty(exports, "StatusError", ({
  enumerable: true,
  get: function () {
    return _StatusError.default;
  }
}));
Object.defineProperty(exports, "PrecheckStatusError", ({
  enumerable: true,
  get: function () {
    return _PrecheckStatusError.default;
  }
}));
Object.defineProperty(exports, "ReceiptStatusError", ({
  enumerable: true,
  get: function () {
    return _ReceiptStatusError.default;
  }
}));

var _cryptography = __nccwpck_require__(7410);

Object.keys(_cryptography).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _cryptography[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cryptography[key];
    }
  });
});

var _AccountBalanceQuery = _interopRequireDefault(__nccwpck_require__(7757));

var _AccountCreateTransaction = _interopRequireDefault(__nccwpck_require__(67));

var _AccountDeleteTransaction = _interopRequireDefault(__nccwpck_require__(9913));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _AccountInfo = _interopRequireDefault(__nccwpck_require__(8065));

var _AccountInfoQuery = _interopRequireDefault(__nccwpck_require__(6985));

var _AccountRecordsQuery = _interopRequireDefault(__nccwpck_require__(3472));

var _AccountStakersQuery = _interopRequireDefault(__nccwpck_require__(9016));

var _AccountUpdateTransaction = _interopRequireDefault(__nccwpck_require__(2927));

var _ContractByteCodeQuery = _interopRequireDefault(__nccwpck_require__(7781));

var _ContractCallQuery = _interopRequireDefault(__nccwpck_require__(8223));

var _ContractCreateTransaction = _interopRequireDefault(__nccwpck_require__(149));

var _ContractDeleteTransaction = _interopRequireDefault(__nccwpck_require__(2139));

var _ContractExecuteTransaction = _interopRequireDefault(__nccwpck_require__(6837));

var _ContractFunctionParameters = _interopRequireDefault(__nccwpck_require__(3506));

var _ContractFunctionResult = _interopRequireDefault(__nccwpck_require__(5971));

var _ContractFunctionSelector = _interopRequireDefault(__nccwpck_require__(8347));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _ContractInfo = _interopRequireDefault(__nccwpck_require__(8197));

var _ContractInfoQuery = _interopRequireDefault(__nccwpck_require__(2070));

var _ContractLogInfo = _interopRequireDefault(__nccwpck_require__(3795));

var _ContractUpdateTranscation = _interopRequireDefault(__nccwpck_require__(2362));

var _ExchangeRate = _interopRequireDefault(__nccwpck_require__(7344));

var _FileAppendTransaction = _interopRequireDefault(__nccwpck_require__(4906));

var _FileContentsQuery = _interopRequireDefault(__nccwpck_require__(2281));

var _FileCreateTransaction = _interopRequireDefault(__nccwpck_require__(8361));

var _FileDeleteTransaction = _interopRequireDefault(__nccwpck_require__(7679));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _FileInfo = _interopRequireDefault(__nccwpck_require__(2838));

var _FileInfoQuery = _interopRequireDefault(__nccwpck_require__(4075));

var _FileUpdateTransaction = _interopRequireDefault(__nccwpck_require__(8927));

var _FreezeTransaction = _interopRequireDefault(__nccwpck_require__(6807));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _HbarUnit = _interopRequireDefault(__nccwpck_require__(7190));

var _LiveHash = _interopRequireDefault(__nccwpck_require__(9367));

var _LiveHashAddTransaction = _interopRequireDefault(__nccwpck_require__(712));

var _LiveHashDeleteTransaction = _interopRequireDefault(__nccwpck_require__(1160));

var _LiveHashQuery = _interopRequireDefault(__nccwpck_require__(2513));

var _NetworkName = _interopRequireDefault(__nccwpck_require__(8986));

var _NetworkVersionInfo = _interopRequireDefault(__nccwpck_require__(7418));

var _NetworkVersionInfoQuery = _interopRequireDefault(__nccwpck_require__(5675));

var _ProxyStaker = _interopRequireDefault(__nccwpck_require__(2843));

var _Query = _interopRequireDefault(__nccwpck_require__(8678));

var _ScheduleCreateTransaction = _interopRequireDefault(__nccwpck_require__(1296));

var _ScheduleDeleteTransaction = _interopRequireDefault(__nccwpck_require__(1492));

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _ScheduleInfo = _interopRequireDefault(__nccwpck_require__(3919));

var _ScheduleInfoQuery = _interopRequireDefault(__nccwpck_require__(3519));

var _ScheduleSignTransaction = _interopRequireDefault(__nccwpck_require__(3122));

var _SemanticVersion = _interopRequireDefault(__nccwpck_require__(8188));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _SystemDeleteTransaction = _interopRequireDefault(__nccwpck_require__(3805));

var _SystemUndeleteTransaction = _interopRequireDefault(__nccwpck_require__(1403));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _TokenAssociateTransaction = _interopRequireDefault(__nccwpck_require__(2334));

var _TokenBurnTransaction = _interopRequireDefault(__nccwpck_require__(3464));

var _TokenCreateTransaction = _interopRequireDefault(__nccwpck_require__(8123));

var _TokenDeleteTransaction = _interopRequireDefault(__nccwpck_require__(6903));

var _TokenDissociateTransaction = _interopRequireDefault(__nccwpck_require__(2651));

var _TokenFreezeTransaction = _interopRequireDefault(__nccwpck_require__(3825));

var _TokenGrantKycTransaction = _interopRequireDefault(__nccwpck_require__(5443));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _TokenInfo = _interopRequireDefault(__nccwpck_require__(9425));

var _TokenInfoQuery = _interopRequireDefault(__nccwpck_require__(5248));

var _TokenMintTransaction = _interopRequireDefault(__nccwpck_require__(3192));

var _TokenRelationship = _interopRequireDefault(__nccwpck_require__(586));

var _TokenRelationshipMap = _interopRequireDefault(__nccwpck_require__(5985));

var _TokenRevokeKycTransaction = _interopRequireDefault(__nccwpck_require__(4501));

var _TokenUnfreezeTransaction = _interopRequireDefault(__nccwpck_require__(2181));

var _TokenUpdateTransaction = _interopRequireDefault(__nccwpck_require__(3081));

var _TokenWipeTransaction = _interopRequireDefault(__nccwpck_require__(5091));

var _TopicCreateTransaction = _interopRequireDefault(__nccwpck_require__(6144));

var _TopicDeleteTransaction = _interopRequireDefault(__nccwpck_require__(4595));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _TopicInfo = _interopRequireDefault(__nccwpck_require__(1615));

var _TopicInfoQuery = _interopRequireDefault(__nccwpck_require__(1066));

var _TopicMessage = _interopRequireDefault(__nccwpck_require__(5334));

var _TopicMessageChunk = _interopRequireDefault(__nccwpck_require__(4042));

var _TopicMessageQuery = _interopRequireDefault(__nccwpck_require__(4658));

var _TopicMessageSubmitTransaction = _interopRequireDefault(__nccwpck_require__(6929));

var _TopicUpdateTransaction = _interopRequireDefault(__nccwpck_require__(5211));

var _Transaction = _interopRequireDefault(__nccwpck_require__(3972));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _TransactionReceipt = _interopRequireDefault(__nccwpck_require__(7214));

var _TransactionReceiptQuery = _interopRequireDefault(__nccwpck_require__(5230));

var _TransactionRecord = _interopRequireDefault(__nccwpck_require__(1155));

var _TransactionRecordQuery = _interopRequireDefault(__nccwpck_require__(8529));

var _TransactionResponse = _interopRequireDefault(__nccwpck_require__(198));

var _Transfer = _interopRequireDefault(__nccwpck_require__(5199));

var _TransferTransaction = _interopRequireDefault(__nccwpck_require__(3007));

var _StatusError = _interopRequireDefault(__nccwpck_require__(3325));

var _PrecheckStatusError = _interopRequireDefault(__nccwpck_require__(3553));

var _ReceiptStatusError = _interopRequireDefault(__nccwpck_require__(7852));

__nccwpck_require__(8346);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4906:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileAppendTransactionBody} proto.IFileAppendTransactionBody
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 */

/**
 * A transaction specifically to append data to a file on the network.
 *
 * If a file has multiple keys, all keys must sign to modify its contents.
 */
class FileAppendTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {Uint8Array | string} [props.contents]
   * @param {number} [props.maxChunks]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._fileId = null;
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._contents = null;
    /**
     * @private
     * @type {number}
     */

    this._maxChunks = 20;
    this.setMaxTransactionFee(new _Hbar.default(5));

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }

    if (props.contents != null) {
      this.setContents(props.contents);
    }

    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    /** @type {number} */


    this._startIndex = 0;
    /** @type {TransactionId[]} */

    this._transactionIds = [];
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {FileAppendTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const append =
    /** @type {proto.IFileAppendTransactionBody} */
    body.fileAppend;
    let contents;

    for (let i = 0; i < bodies.length; i += nodeIds.length) {
      const fileAppend =
      /** @type {proto.IFileAppendTransactionBody} */
      bodies[i].fileAppend;

      if (fileAppend.contents == null) {
        break;
      }

      if (contents == null) {
        contents = new Uint8Array(
        /** @type {Uint8Array} */
        fileAppend.contents);
        continue;
      }
      /** @type {Uint8Array} */


      const concat = new Uint8Array(contents.length +
      /** @type {Uint8Array} */
      fileAppend.contents.length);
      concat.set(contents, 0);
      concat.set(
      /** @type {Uint8Array} */
      fileAppend.contents, contents.length);
      contents = concat;
    }

    return _Transaction.default._fromProtobufTransactions(new FileAppendTransaction({
      fileId: append.fileID != null ? _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      append.fileID) : undefined,
      contents: contents
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @param {TransactionId} transactionId
   * @returns {this}
   */


  setTransactionId(transactionId) {
    this._requireNotFrozen();

    if (transactionId.accountId == null || transactionId.validStart == null) {
      throw new Error("`FileAppendTransaction` does not support `TransactionId` built from `nonce`");
    }

    this._transactionIds = [transactionId];
    return this;
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {FileId | string} fileId
   * @returns {this}
   */


  setFileId(fileId) {
    this._requireNotFrozen();

    this._fileId = typeof fileId === "string" ? _FileId.default.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to append an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */


  setContents(contents) {
    this._requireNotFrozen();

    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);
    return this;
  }
  /**
   * @returns {?number}
   */


  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */


  setMaxChunks(maxChunks) {
    this._requireNotFrozen();

    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */


  freezeWith(client) {
    super.freezeWith(client);

    if (this._contents == null) {
      return this;
    }

    const chunks = Math.floor((this._contents.length + (_Transaction.CHUNK_SIZE - 1)) / _Transaction.CHUNK_SIZE);

    if (chunks > this._maxChunks) {
      throw new Error(`Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`);
    }

    let nextTransactionId = this.transactionId;
    super._transactions = [];
    super._transactionIds = [];
    super._signedTransactions = [];
    super._nextTransactionIndex = 0;

    for (let chunk = 0; chunk < chunks; chunk++) {
      this._startIndex = chunk * _Transaction.CHUNK_SIZE;

      this._transactionIds.push(nextTransactionId);

      for (const nodeAccountId of this._nodeIds) {
        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));
      }

      nextTransactionId = new _TransactionId.default(
      /** @type {AccountId} */
      nextTransactionId.accountId, new _Timestamp.default(
      /** @type {Timestamp} */
      nextTransactionId.validStart.seconds,
      /** @type {Timestamp} */
      nextTransactionId.validStart.nanos.add(1)));
      super._nextTransactionIndex = this._nextTransactionIndex + 1;
    }

    this._startIndex = 0;
    super._nextTransactionIndex = 0;
    return this;
  }
  /**
   * @returns {ScheduleCreateTransaction}
   */


  schedule() {
    this._requireNotFrozen();

    if (this._contents != null && this._contents.length > _Transaction.CHUNK_SIZE) {
      throw new Error(`cannot scheduled \`FileAppendTransaction\` with message over ${_Transaction.CHUNK_SIZE} bytes`);
    }

    return super.schedule();
  }
  /**
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<TransactionResponse>}
   */


  async execute(client) {
    return (await this.executeAll(client))[0];
  }
  /**
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<TransactionResponse[]>}
   */


  async executeAll(client) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    } // on execute, sign each transaction with the operator, if present
    // and we are signing a transaction that used the default transaction ID


    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;

    if (operatorAccountId != null && operatorAccountId.equals(
    /** @type {AccountId} */
    transactionId.accountId)) {
      await super.signWithOperator(client);
    }

    const responses = [];

    for (let i = 0; i < this._transactionIds.length; i++) {
      const response = await super.execute(client);
      await response.getReceipt(client);
      responses.push(response);
    }

    return responses;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._fileId != null) {
      this._fileId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.file.appendContent(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "fileAppend";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IFileAppendTransactionBody}
   */


  _makeTransactionData() {
    const length = this._contents != null ? this._contents.length : 0;
    let endIndex = this._startIndex + _Transaction.CHUNK_SIZE;

    if (endIndex > length) {
      endIndex = length;
    }

    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contents: this._contents != null ? this._contents.slice(this._startIndex, endIndex) : null
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileAppendTransaction;

_Transaction.TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);

/***/ }),

/***/ 2281:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IFileGetContentsQuery} proto.IFileGetContentsQuery
 * @typedef {import("@hashgraph/proto").IFileGetContentsResponse} proto.IFileGetContentsResponse
 * @typedef {import("@hashgraph/proto").IFileContents} proto.IFileContents
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<Uint8Array>}
 */
class FileContentsQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?FileId}
     * @private
     */

    this._fileId = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {FileContentsQuery}
   */


  static _fromProtobuf(query) {
    const contents =
    /** @type {proto.IFileGetContentsQuery} */
    query.fileGetContents;
    return new FileContentsQuery({
      fileId: contents.fileID != null ? _FileId.default._fromProtobuf(contents.fileID) : undefined
    });
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._fileId != null) {
      this._fileId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.file.getFileContent(request);
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID for which the info is being requested.
   *
   * @param {FileId | string} fileId
   * @returns {FileContentsQuery}
   */


  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? _FileId.default.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const fileGetContents =
    /** @type {proto.IFileGetContentsResponse} */
    response.fileGetContents;
    return (
      /** @type {proto.IResponseHeader} */
      fileGetContents.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<Uint8Array>}
   */


  _mapResponse(response) {
    const fileContentsResponse =
    /** @type {proto.IFileGetContentsResponse} */
    response.fileGetContents;
    const fileConents =
    /** @type {proto.IFileContents} */
    fileContentsResponse.fileContents;
    const contents =
    /** @type {Uint8Array} */
    fileConents.contents;
    return Promise.resolve(contents);
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      fileGetContents: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileContentsQuery;

_Query.QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);

/***/ }),

/***/ 8361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _cryptography = __nccwpck_require__(7410);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileCreateTransactionBody} proto.IFileCreateTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency file.
 */
class FileCreateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {Key[] | KeyList} [props.keys]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Uint8Array | string} [props.contents]
   * @param {string} [props.fileMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Key[]}
     */

    this._keys = null;
    /**
     * @private
     * @type {Timestamp}
     */

    this._expirationTime = _Timestamp.default.fromDate(Date.now() + _Transaction.DEFAULT_AUTO_RENEW_PERIOD.toInt() * 1000);
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._contents = null;
    /**
     * @private
     * @type {?string}
     */

    this._fileMemo = null;
    this.setMaxTransactionFee(new _Hbar.default(5));

    if (props.keys != null) {
      this.setKeys(props.keys);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.contents != null) {
      this.setContents(props.contents);
    }

    if (props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {FileCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.IFileCreateTransactionBody} */
    body.fileCreate;
    return _Transaction.default._fromProtobufTransactions(new FileCreateTransaction({
      keys: create.keys != null ? create.keys.keys != null ? create.keys.keys.map(key => (0, _protobuf.keyFromProtobuf)(key)) : undefined : undefined,
      expirationTime: create.expirationTime != null ? _Timestamp.default._fromProtobuf(create.expirationTime) : undefined,
      contents: create.contents != null ? create.contents : undefined,
      fileMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?Key[]}
   */


  get keys() {
    return this._keys;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {Key[] | KeyList} keys
   * @returns {this}
   */


  setKeys(keys) {
    this._requireNotFrozen();

    if (keys instanceof _cryptography.KeyList && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }

    this._keys = keys instanceof _cryptography.KeyList ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Set the instant at which this file will expire, after which its contents will no longer be
   * available.
   *
   * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction
   * was invoked.
   *
   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */


  setExpirationTime(expirationTime) {
    this._requireNotFrozen();

    this._expirationTime = expirationTime instanceof _Timestamp.default ? expirationTime : _Timestamp.default.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to create an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */


  setContents(contents) {
    this._requireNotFrozen();

    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);
    return this;
  }
  /**
   * @returns {?string}
   */


  get fileMemo() {
    return this._fileMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setFileMemo(memo) {
    this._requireNotFrozen();

    this._fileMemo = memo;
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.file.createFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "fileCreate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IFileCreateTransactionBody}
   */


  _makeTransactionData() {
    return {
      keys: this._keys != null ? {
        keys: this._keys.map(key => (0, _protobuf.keyToProtobuf)(key))
      } : null,
      expirationTime: this._expirationTime._toProtobuf(),
      contents: this._contents,
      memo: this._fileMemo
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);

/***/ }),

/***/ 7679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileDeleteTransactionBody} proto.IFileDeleteTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * A transaction to delete a file on the Hedera network.
 *
 * When deleted, a file's contents are truncated to zero length and it can no longer be updated
 * or appended to, or its expiration time extended. FileContentsQuery and FileInfoQuery
 * will throw HederaPreCheckStatusException with a status of Status#FileDeleted.
 *
 * Only one of the file's keys needs to sign to delete the file, unless the key you have is part
 * of a KeyList.
 */
class FileDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._fileId = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {FileDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const fileDelete =
    /** @type {proto.IFileDeleteTransactionBody} */
    body.fileDelete;
    return _Transaction.default._fromProtobufTransactions(new FileDeleteTransaction({
      fileId: fileDelete.fileID != null ? _FileId.default._fromProtobuf(fileDelete.fileID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID which is being deleted in this transaction.
   *
   * @param {FileId | string} fileId
   * @returns {FileDeleteTransaction}
   */


  setFileId(fileId) {
    this._requireNotFrozen();

    this._fileId = typeof fileId === "string" ? _FileId.default.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._fileId != null) {
      this._fileId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.file.deleteFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "fileDelete";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IFileDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 3842:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency file on Hedera.
 */
class FileId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {FileId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new FileId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.IFileID} id
   * @param {(string | null)=} ledgerId
   * @returns {FileId}
   */


  static _fromProtobuf(id, ledgerId) {
    const fileId = new FileId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.fileNum != null ? id.fileNum : 0);

    if (ledgerId != null) {
      fileId._setNetwork(ledgerId);
    }

    return fileId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FileId}
   */


  static fromBytes(bytes) {
    return FileId._fromProtobuf(proto.FileID.decode(bytes));
  }
  /**
   * @override
   * @internal
   * @returns {proto.IFileID}
   */


  _toProtobuf() {
    return {
      fileNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.FileID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {FileId}
   */


  clone() {
    const id = new FileId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = FileId;

/***/ }),

/***/ 2838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _cryptography = __nccwpck_require__(7410);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _protobuf = __nccwpck_require__(223);

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class FileInfo {
  /**
   * @private
   * @param {object} props
   * @param {FileId} props.fileId
   * @param {Long} props.size
   * @param {Timestamp} props.expirationTime
   * @param {boolean} props.isDeleted
   * @param {KeyList} props.keys
   * @param {string} props.fileMemo
   */
  constructor(props) {
    /**
     * The ID of the file for which information is requested.
     *
     * @readonly
     */
    this.fileId = props.fileId;
    /**
     * Number of bytes in contents.
     *
     * @readonly
     */

    this.size = props.size;
    /**
     * The current time at which this account is set to expire.
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     * True if deleted but not yet expired.
     *
     * @readonly
     */

    this.isDeleted = props.isDeleted;
    /**
     * One of these keys must sign in order to delete the file.
     * All of these keys must sign in order to update the file.
     *
     * @readonly
     */

    this.keys = props.keys;
    this.fileMemo = props.fileMemo;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IFileInfo} info
   * @param {(string | null)=} ledgerId
   * @returns {FileInfo}
   */


  static _fromProtobuf(info, ledgerId) {
    const size =
    /** @type {Long | number} */
    info.size;
    return new FileInfo({
      fileId: _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      info.fileID, ledgerId),
      size: size instanceof _long.default ? size : _long.default.fromValue(size),
      expirationTime: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.expirationTime),
      isDeleted:
      /** @type {boolean} */
      info.deleted,
      keys: info.keys != null ? (0, _protobuf.keyListFromProtobuf)(info.keys) : new _cryptography.KeyList(),
      fileMemo: info.memo != null ? info.memo : ""
    });
  }
  /**
   * @internal
   * @returns {proto.IFileInfo}
   */


  _toProtobuf() {
    return {
      fileID: this.fileId._toProtobuf(),
      size: this.size,
      expirationTime: this.expirationTime._toProtobuf(),
      deleted: this.isDeleted,
      keys: (0, _protobuf.keyListToProtobuf)(this.keys),
      memo: this.fileMemo
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FileInfo}
   */


  static fromBytes(bytes) {
    return FileInfo._fromProtobuf(proto.FileGetInfoResponse.FileInfo.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.FileGetInfoResponse.FileInfo.encode(this._toProtobuf()).finish();
  }

}

exports.default = FileInfo;

/***/ }),

/***/ 4075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _FileInfo = _interopRequireDefault(__nccwpck_require__(2838));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IFileGetInfoQuery} proto.IFileGetInfoQuery
 * @typedef {import("@hashgraph/proto").IFileGetInfoResponse} proto.IFileGetInfoResponse
 * @typedef {import("@hashgraph/proto").IFileInfo} proto.IFileInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<FileInfo>}
 */
class FileInfoQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   */
  constructor(props = {}) {
    super();
    /**
     * @type {?FileId}
     * @private
     */

    this._fileId = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {FileInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.IFileGetInfoQuery} */
    query.fileGetInfo;
    return new FileInfoQuery({
      fileId: info.fileID != null ? _FileId.default._fromProtobuf(info.fileID) : undefined
    });
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * Set the file ID for which the info is being requested.
   *
   * @param {FileId | string} fileId
   * @returns {FileInfoQuery}
   */


  setFileId(fileId) {
    this._fileId = typeof fileId === "string" ? _FileId.default.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._fileId != null) {
      this._fileId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.file.getFileInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const fileGetInfo =
    /** @type {proto.IFileGetInfoResponse} */
    response.fileGetInfo;
    return (
      /** @type {proto.IResponseHeader} */
      fileGetInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<FileInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const info =
    /** @type {proto.IFileGetInfoResponse} */
    response.fileGetInfo;
    return Promise.resolve(_FileInfo.default._fromProtobuf(
    /** @type {proto.IFileInfo} */
    info.fileInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      fileGetInfo: {
        header,
        fileID: this._fileId != null ? this._fileId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileInfoQuery;

_Query.QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);

/***/ }),

/***/ 8927:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _cryptography = __nccwpck_require__(7410);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileUpdateTransactionBody} proto.IFileUpdateTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera crypto-currency file.
 */
class FileUpdateTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {FileId | string} [props.fileId]
   * @param {Key[] | KeyList} [props.keys]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Uint8Array | string} [props.contents]
   * @param {string} [props.fileMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._fileId = null;
    /**
     * @private
     * @type {?Key[]}
     */

    this._keys = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;
    /**
     * @private
     * @type {?Uint8Array}
     */

    this._contents = null;
    /**
     * @private
     * @type {?string}
     */

    this._fileMemo = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }

    if (props.keys != null) {
      this.setKeys(props.keys);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.contents != null) {
      this.setContents(props.contents);
    }

    if (props.fileMemo != null) {
      this.setFileMemo(props.fileMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {FileUpdateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update =
    /** @type {proto.IFileUpdateTransactionBody} */
    body.fileUpdate;
    return _Transaction.default._fromProtobufTransactions(new FileUpdateTransaction({
      fileId: update.fileID != null ? _FileId.default._fromProtobuf(update.fileID) : undefined,
      keys: update.keys != null ? update.keys.keys != null ? update.keys.keys.map(key => (0, _protobuf.keyFromProtobuf)(key)) : undefined : undefined,
      expirationTime: update.expirationTime != null ? _Timestamp.default._fromProtobuf(update.expirationTime) : undefined,
      contents: update.contents != null ? update.contents : undefined,
      fileMemo: update.memo != null ? update.memo.value != null ? update.memo.value : undefined : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {FileId | string} fileId
   * @returns {this}
   */


  setFileId(fileId) {
    this._requireNotFrozen();

    this._fileId = typeof fileId === "string" ? _FileId.default.fromString(fileId) : fileId.clone();
    return this;
  }
  /**
   * @returns {?Key[]}
   */


  get keys() {
    return this._keys;
  }
  /**
   * Set the keys which must sign any transactions modifying this file. Required.
   *
   * All keys must sign to modify the file's contents or keys. No key is required
   * to sign for extending the expiration time (except the one for the operator account
   * paying for the transaction). Only one key must sign to delete the file, however.
   *
   * To require more than one key to sign to delete a file, add them to a
   * KeyList and pass that here.
   *
   * The network currently requires a file to have at least one key (or key list or threshold key)
   * but this requirement may be lifted in the future.
   *
   * @param {Key[] | KeyList} keys
   * @returns {this}
   */


  setKeys(keys) {
    this._requireNotFrozen();

    if (keys instanceof _cryptography.KeyList && keys.threshold != null) {
      throw new Error("Cannot set threshold key as file key");
    }

    this._keys = keys instanceof _cryptography.KeyList ? keys.toArray() : keys;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * Set the instant at which this file will expire, after which its contents will no longer be
   * available.
   *
   * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction
   * was invoked.
   *
   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
   *
   * @param {Timestamp | Date} expirationTime
   * @returns {this}
   */


  setExpirationTime(expirationTime) {
    this._requireNotFrozen();

    this._expirationTime = expirationTime instanceof _Timestamp.default ? expirationTime : _Timestamp.default.fromDate(expirationTime);
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get contents() {
    return this._contents;
  }
  /**
   * Set the given byte array as the file's contents.
   *
   * This may be omitted to update an empty file.
   *
   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
   * network; if you exceed this you may receive a HederaPreCheckStatusException
   * with Status#TransactionOversize.
   *
   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
   * transaction with the first chunk and then use FileAppendTransaction with
   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
   *
   * @param {Uint8Array | string} contents
   * @returns {this}
   */


  setContents(contents) {
    this._requireNotFrozen();

    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);
    return this;
  }
  /**
   * @returns {?string}
   */


  get fileMemo() {
    return this._fileMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setFileMemo(memo) {
    this._requireNotFrozen();

    this._fileMemo = memo;
    return this;
  }
  /**
   * @returns {this}
   */


  clearFileMemo() {
    this._requireNotFrozen();

    this._fileMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._fileId != null) {
      this._fileId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.file.updateFile(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "fileUpdate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IFileUpdateTransactionBody}
   */


  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      keys: this._keys != null ? {
        keys: this._keys.map(key => (0, _protobuf.keyToProtobuf)(key))
      } : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      contents: this._contents,
      memo: this._fileMemo != null ? {
        value: this._fileMemo
      } : null
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FileUpdateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);

/***/ }),

/***/ 9115:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _GrpcStatus = _interopRequireDefault(__nccwpck_require__(3374));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Describes how the gRPC request failed.
 *
 * Exists in order for the Hedera JavaScript SDK to produce the same error type for gRPC errors regardless of
 * operating in node or the browser.
 *
 * Definition taken from <https://grpc.github.io/grpc/node/grpc.html#~ServiceError>.
 */
class GrpcServiceError extends Error {
  /**
   * @param {GrpcStatus} status
   */
  constructor(status) {
    super(`gRPC service failed with status: ${status.toString()}`);
    /**
     * @readonly
     */

    this.status = status;
    this.name = "GrpcServiceError";

    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, GrpcServiceError);
    }
  }
  /**
   * @param {Error & { code?: number; details?: string }} obj
   * @returns {Error}
   */


  static _fromResponse(obj) {
    if (obj.code != null && obj.details != null) {
      const status = _GrpcStatus.default._fromValue(obj.code);

      const err = new GrpcServiceError(status);
      err.message = obj.details;
      return err;
    } else {
      return (
        /** @type {Error} */
        obj
      );
    }
  }

}

exports.default = GrpcServiceError;

/***/ }),

/***/ 3374:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

class GrpcStatus {
  /**
   * @hideconstructor
   * @internal
   * @param {number} code
   */
  constructor(code) {
    /** @readonly */
    this._code = code;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {number} code
   * @returns {GrpcStatus}
   */


  static _fromValue(code) {
    switch (code) {
      case 0:
        return GrpcStatus.Ok;

      case 1:
        return GrpcStatus.Cancelled;

      case 2:
        return GrpcStatus.Unknown;

      case 3:
        return GrpcStatus.InvalidArgument;

      case 4:
        return GrpcStatus.DeadlineExceeded;

      case 5:
        return GrpcStatus.NotFound;

      case 6:
        return GrpcStatus.AlreadyExists;

      case 7:
        return GrpcStatus.PermissionDenied;

      case 16:
        return GrpcStatus.Unauthenticated;

      case 8:
        return GrpcStatus.ResourceExhausted;

      case 9:
        return GrpcStatus.FailedPrecondition;

      case 10:
        return GrpcStatus.Aborted;

      case 11:
        return GrpcStatus.OutOfRange;

      case 12:
        return GrpcStatus.Unimplemented;

      case 13:
        return GrpcStatus.Internal;

      case 14:
        return GrpcStatus.Unavailable;

      case 15:
        return GrpcStatus.DataLoss;

      default:
        throw new Error("(BUG) non-exhaustive GrpcStatus switch statement");
    }
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    switch (this) {
      case GrpcStatus.Ok:
        return "OK";

      case GrpcStatus.Cancelled:
        return "CANCELLED";

      case GrpcStatus.Unknown:
        return "UNKNOWN";

      case GrpcStatus.InvalidArgument:
        return "INVALID_ARGUMENT";

      case GrpcStatus.DeadlineExceeded:
        return "DEADLINE_EXCEEDED";

      case GrpcStatus.NotFound:
        return "NOT_FOUND";

      case GrpcStatus.AlreadyExists:
        return "ALREADY_EXISTS";

      case GrpcStatus.PermissionDenied:
        return "PERMISSION_DENIED";

      case GrpcStatus.Unauthenticated:
        return "UNAUTHENTICATED";

      case GrpcStatus.ResourceExhausted:
        return "RESOURCE_EXHAUSTED";

      case GrpcStatus.FailedPrecondition:
        return "FAILED_PRECONDITION";

      case GrpcStatus.Aborted:
        return "ABORTED";

      case GrpcStatus.OutOfRange:
        return "OUT_OF_RANGE";

      case GrpcStatus.Unimplemented:
        return "UNIMPLEMENTED";

      case GrpcStatus.Internal:
        return "INTERNAL";

      case GrpcStatus.Unavailable:
        return "UNAVAILABLE";

      case GrpcStatus.DataLoss:
        return "DATA_LOSS";

      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  /**
   * @returns {number}
   */


  valueOf() {
    return this._code;
  }

}

exports.default = GrpcStatus;
GrpcStatus.Ok = new GrpcStatus(0);
GrpcStatus.Cancelled = new GrpcStatus(1);
GrpcStatus.Unknown = new GrpcStatus(2);
GrpcStatus.InvalidArgument = new GrpcStatus(3);
GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
GrpcStatus.NotFound = new GrpcStatus(5);
GrpcStatus.AlreadyExists = new GrpcStatus(6);
GrpcStatus.PermissionDenied = new GrpcStatus(7);
GrpcStatus.Unauthenticated = new GrpcStatus(16);
GrpcStatus.ResourceExhausted = new GrpcStatus(8);
GrpcStatus.FailedPrecondition = new GrpcStatus(9);
GrpcStatus.Aborted = new GrpcStatus(10);
GrpcStatus.OutOfRange = new GrpcStatus(11);
GrpcStatus.Unimplemented = new GrpcStatus(12);
GrpcStatus.Internal = new GrpcStatus(13);
GrpcStatus.Unavailable = new GrpcStatus(14);
GrpcStatus.DataLoss = new GrpcStatus(15);

/***/ }),

/***/ 9868:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  Client: true
};
Object.defineProperty(exports, "Client", ({
  enumerable: true,
  get: function () {
    return _NodeClient.default;
  }
}));

var _exports = __nccwpck_require__(934);

Object.keys(_exports).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _exports[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exports[key];
    }
  });
});

var _NodeClient = _interopRequireDefault(__nccwpck_require__(5640));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4218:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.valueToLong = valueToLong;

var _bignumber = _interopRequireDefault(__nccwpck_require__(2639));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {{low: number, high: number, unsigned: boolean}} LongObject
 * @typedef {import("long")} Long
 */

/**
 * @param {Long | number | string | LongObject | BigNumber} value
 * @returns {BigNumber}
 */
function valueToLong(value) {
  if (_bignumber.default.isBigNumber(value)) {
    return value;
  } else {
    return new _bignumber.default(value.toString());
  }
}

/***/ }),

/***/ 7418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _SemanticVersion = _interopRequireDefault(__nccwpck_require__(8188));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Response when the client sends the node CryptoGetVersionInfoQuery.
 */
class NetworkVersionInfo {
  /**
   * @private
   * @param {object} props
   * @param {SemanticVersion} props.protobufVersion
   * @param {SemanticVersion} props.servicesVesion
   *
   */
  constructor(props) {
    /**
     * The account ID for which this information applies.
     *
     * @readonly
     */
    this.protobufVersion = props.protobufVersion;
    /**
     * The account ID for which this information applies.
     *
     * @readonly
     */

    this.servicesVesion = props.servicesVesion;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.INetworkGetVersionInfoResponse} info
   * @returns {NetworkVersionInfo}
   */


  static _fromProtobuf(info) {
    return new NetworkVersionInfo({
      protobufVersion: _SemanticVersion.default._fromProtobuf(
      /** @type {proto.ISemanticVersion} */
      info.hapiProtoVersion),
      servicesVesion: _SemanticVersion.default._fromProtobuf(
      /** @type {proto.ISemanticVersion} */
      info.hederaServicesVersion)
    });
  }
  /**
   * @internal
   * @returns {proto.INetworkGetVersionInfoResponse}
   */


  _toProtobuf() {
    return {
      hapiProtoVersion: this.protobufVersion._toProtobuf(),
      hederaServicesVersion: this.servicesVesion._toProtobuf()
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NetworkVersionInfo}
   */


  static fromBytes(bytes) {
    return NetworkVersionInfo._fromProtobuf(proto.NetworkGetVersionInfoResponse.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.NetworkGetVersionInfoResponse.encode(this._toProtobuf()).finish();
  }

}

exports.default = NetworkVersionInfo;

/***/ }),

/***/ 5675:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _NetworkVersionInfo = _interopRequireDefault(__nccwpck_require__(7418));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").INetworkGetVersionInfoQuery} proto.INetworkGetVersionInfoQuery
 * @typedef {import("@hashgraph/proto").INetworkGetVersionInfoResponse} proto.INetworkGetVersionInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @augments {Query<NetworkVersionInfo>}
 */
class NetworkVersionInfoQuery extends _Query.default {
  constructor() {
    super();
  }
  /**
   * @param {proto.IQuery} query
   * @returns {NetworkVersionInfoQuery}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  static _fromProtobuf(query) {
    return new NetworkVersionInfoQuery();
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.network.getVersionInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const networkGetVersionInfo =
    /** @type {proto.INetworkGetVersionInfoResponse} */
    response.networkGetVersionInfo;
    return (
      /** @type {proto.IResponseHeader} */
      networkGetVersionInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @returns {Promise<NetworkVersionInfo>}
   */


  _mapResponse(response) {
    const info =
    /** @type {proto.INetworkGetVersionInfoResponse} */
    response.networkGetVersionInfo;
    return Promise.resolve(_NetworkVersionInfo.default._fromProtobuf(info));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      networkGetVersionInfo: {
        header
      }
    };
  }

}

exports.default = NetworkVersionInfoQuery;

_Query.QUERY_REGISTRY.set("networkGetVersionInfo", // eslint-disable-next-line @typescript-eslint/unbound-method
NetworkVersionInfoQuery._fromProtobuf);

/***/ }),

/***/ 8188:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class SemanticVersion {
  /**
   * @private
   * @param {object} props
   * @param {number} props.major
   * @param {number} props.minor
   * @param {number} props.patch
   */
  constructor(props) {
    /** @readonly */
    this.major = props.major;
    /** @readonly */

    this.minor = props.minor;
    /** @readonly */

    this.patch = props.patch;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.ISemanticVersion} version
   * @returns {SemanticVersion}
   */


  static _fromProtobuf(version) {
    return new SemanticVersion({
      major:
      /** @type {number} */
      version.major,
      minor:
      /** @type {number} */
      version.minor,
      patch:
      /** @type {number} */
      version.patch
    });
  }
  /**
   * @internal
   * @returns {proto.ISemanticVersion}
   */


  _toProtobuf() {
    return {
      major: this.major,
      minor: this.minor,
      patch: this.patch
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {SemanticVersion}
   */


  static fromBytes(bytes) {
    return SemanticVersion._fromProtobuf(proto.SemanticVersion.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.SemanticVersion.encode(this._toProtobuf()).finish();
  }

}

exports.default = SemanticVersion;

/***/ }),

/***/ 8346:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Executable = _interopRequireDefault(__nccwpck_require__(1128));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Query = __nccwpck_require__(8678);

var _proto = __nccwpck_require__(973);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Status.js").default} Status
 * @typedef {import("../Executable.js").ExecutionState} ExecutionState
 */

/**
 * @template OutputT
 * @augments {Executable<proto.IQuery, proto.IResponse, Hbar>}
 */
class CostQuery extends _Executable.default {
  /**
   * @param {import("./Query.js").default<OutputT>} query
   */
  constructor(query) {
    super();
    this._query = query;
    /**
     * @type {proto.IQueryHeader | null}
     */

    this._header = null;
  }
  /**
   * @returns {TransactionId}
   */


  _getTransactionId() {
    return this._query._getTransactionId();
  }
  /**
   * @abstract
   * @protected
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<void>}
   */


  async _beforeExecute(client) {
    if (client == null) {
      throw new Error("Cannot do CostQuery without Client");
    }

    const operator = client._operator;

    if (operator == null) {
      throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
    }

    if (this._query._nodeIds.length == 0) {
      this._query._nodeIds = client._network.getNodeAccountIdsForExecute();
    }

    this._header = {
      payment: await (0, _Query._makePaymentTransaction)(
      /** @type {import("../transaction/TransactionId.js").default} */
      _TransactionId.default.generate(new _AccountId.default(0)), new _AccountId.default(0), operator, new _Hbar.default(0)),
      responseType: _proto.ResponseType.COST_ANSWER
    };
  }
  /**
   * @abstract
   * @internal
   * @returns {Promise<proto.IQuery>}
   */


  _makeRequestAsync() {
    return Promise.resolve(this._query._onMakeRequest(
    /** @type {proto.IQueryHeader} */
    this._header));
  }
  /**
   * @abstract
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @returns {ExecutionState}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _shouldRetry(request, response) {
    return this._query._shouldRetry(request, response);
  }
  /**
   * @abstract
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    return this._query._mapStatusError(request, response, ledgerId);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @returns {Promise<Hbar>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request) {
    const cost = this._query._mapResponseHeader(response).cost;

    return Promise.resolve(_Hbar.default.fromTinybars(
    /** @type {Long | number} */
    cost));
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return this._query._execute(channel, request);
  }
  /**
   * @override
   * @returns {AccountId}
   */


  _getNodeAccountId() {
    return this._query._getNodeAccountId();
  }

}

exports.default = CostQuery;

_Query.COST_QUERY.push(query => new CostQuery(query));

/***/ }),

/***/ 8678:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._makePaymentTransaction = _makePaymentTransaction;
exports.COST_QUERY = exports.default = exports.QUERY_REGISTRY = void 0;

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Executable = _interopRequireWildcard(__nccwpck_require__(1128));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _proto = __nccwpck_require__(973);

var _PrecheckStatusError = _interopRequireDefault(__nccwpck_require__(3553));

var _MaxQueryPaymentExceeded = _interopRequireDefault(__nccwpck_require__(3672));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @type {Map<ProtoQuery["query"], (query: proto.IQuery) => Query<*>>}
 */
const QUERY_REGISTRY = new Map();
/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<proto.IQuery, proto.IResponse, OutputT>}
 */

exports.QUERY_REGISTRY = QUERY_REGISTRY;

class Query extends _Executable.default {
  constructor() {
    super();
    /** @type {?TransactionId} */

    this._paymentTransactionId = null;
    /** @type {proto.ITransaction[]} */

    this._paymentTransactions = [];
    /** @type {?Hbar} */

    this._queryPayment = null;
    /** @type {?Hbar} */

    this._maxQueryPayment = null;
  }
  /**
   * @template T
   * @param {Uint8Array} bytes
   * @returns {Query<T>}
   */


  static fromBytes(bytes) {
    const query = _proto.Query.decode(bytes);

    if (query.query == null) {
      throw new Error("(BUG) query.query was not set in the protobuf");
    }

    const fromProtobuf =
    /** @type {(query: proto.IQuery) => Query<T>} */
    QUERY_REGISTRY.get(query.query);

    if (fromProtobuf == null) {
      throw new Error(`(BUG) Query.fromBytes() not implemented for type ${query.query}`);
    }

    return fromProtobuf(query);
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return _proto.Query.encode(this._makeRequest()).finish();
  }
  /**
   * Set an explicit payment amount for this query.
   *
   * The client will submit exactly this amount for the payment of this query. Hedera
   * will not return any remainder.
   *
   * @param {Hbar} queryPayment
   * @returns {this}
   */


  setQueryPayment(queryPayment) {
    this._queryPayment = queryPayment;
    return this;
  }
  /**
   * Set the maximum payment allowable for this query.
   *
   * @param {Hbar} maxQueryPayment
   * @returns {this}
   */


  setMaxQueryPayment(maxQueryPayment) {
    this._maxQueryPayment = maxQueryPayment;
    return this;
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  getCost(client) {
    if (COST_QUERY.length != 1) {
      throw new Error("CostQuery has not been loaded yet");
    }

    return COST_QUERY[0](this).execute(client);
  }
  /**
   * @param {TransactionId} paymentTransactionId
   * @returns {this}
   */


  setPaymentTransactionId(paymentTransactionId) {
    this._paymentTransactionId = paymentTransactionId;
    return this;
  }
  /**
   * @returns {?TransactionId}
   */


  get paymentTransactionId() {
    return this._paymentTransactionId;
  }
  /**
   * @returns {TransactionId}
   */


  _getTransactionId() {
    if (this._paymentTransactionId == null) {
      throw new Error("Query.PaymentTransactionId was not set duration execution");
    }

    return this._paymentTransactionId;
  }
  /**
   * @protected
   * @returns {boolean}
   */


  _isPaymentRequired() {
    return true;
  }
  /**
   * @param {Client} client
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function


  _validateIdNetworks(client) {// Do nothing
  }
  /**
   * @template MirrorChannelT
   * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
   * @returns {Promise<void>}
   */


  async _beforeExecute(client) {
    if (this._paymentTransactions.length > 0) {
      return;
    }

    this._validateIdNetworks(client);

    if (this._nodeIds.length == 0) {
      this._nodeIds = client._network.getNodeAccountIdsForExecute();
    }

    const operator = client._operator;

    if (this._paymentTransactionId == null) {
      if (this._isPaymentRequired()) {
        if (operator != null) {
          this._paymentTransactionId = _TransactionId.default.generate(operator.accountId);
        } else {
          throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
        }
      } else {
        this._paymentTransactionId = _TransactionId.default.generate(new _AccountId.default(0));
      }
    }

    let cost = this._queryPayment != null ? this._queryPayment : client.maxQueryPayment;

    if (this._paymentTransactions.length !== 0 || !this._isPaymentRequired()) {
      cost = new _Hbar.default(0);
    } else {
      if (this._queryPayment == null) {
        const actualCost = await this.getCost(client);

        if (cost.toTinybars().toInt() < actualCost.toTinybars().toInt()) {
          throw new _MaxQueryPaymentExceeded.default(cost, actualCost);
        }

        cost = actualCost;
      }
    }

    for (const node of this._nodeIds) {
      this._paymentTransactions.push(await _makePaymentTransaction(
      /** @type {import("../transaction/TransactionId.js").default} */
      this._paymentTransactionId, node, operator,
      /** @type {Hbar} */
      cost));
    }
  }
  /**
   * @abstract
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponseHeader(response) {
    throw new Error("not implemented");
  }
  /**
   * @protected
   * @returns {proto.IQueryHeader}
   */


  _makeRequestHeader() {
    /** @type {proto.IQueryHeader} */
    let header = {};

    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
      header = {
        responseType: _proto.ResponseType.ANSWER_ONLY,
        payment: this._paymentTransactions[this._nextNodeIndex]
      };
    }

    return header;
  }
  /**
   * @abstract
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _onMakeRequest(header) {
    throw new Error("not implemented");
  }
  /**
   * @internal
   * @returns {proto.IQuery}
   */


  _makeRequest() {
    /** @type {proto.IQueryHeader} */
    let header = {};

    if (this._isPaymentRequired() && this._paymentTransactions != null) {
      header = {
        payment: this._paymentTransactions[this._nextNodeIndex],
        responseType: _proto.ResponseType.ANSWER_ONLY
      };
    }

    return this._onMakeRequest(header);
  }
  /**
   * @override
   * @internal
   * @returns {Promise<proto.IQuery>}
   */


  _makeRequestAsync() {
    return Promise.resolve(this._makeRequest());
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @returns {ExecutionState}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _shouldRetry(request, response) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    const status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.PlatformTransactionNotCreated:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Ok:
        return _Executable.ExecutionState.Finished;

      default:
        return _Executable.ExecutionState.Error;
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    const status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    return new _PrecheckStatusError.default({
      status,
      transactionId: this._getTransactionId()
    });
  }
  /**
   * @returns {AccountId}
   */


  _getNodeAccountId() {
    if (this._nodeIds.length > 0) {
      // if there are payment transactions,
      // we need to use the node of the current payment transaction
      return this._nodeIds[this._nextNodeIndex];
    } else {
      throw new Error("(BUG) nodeAccountIds were not set for query before executing");
    }
  }
  /**
   * @override
   * @protected
   * @returns {void}
   */


  _advanceRequest() {
    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
      // each time we move our cursor to the next transaction
      // wrapping around to ensure we are cycling
      super._nextNodeIndex = (this._nextNodeIndex + 1) % this._paymentTransactions.length;
    }
  }

}
/**
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {?ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<proto.ITransaction>}
 */


exports.default = Query;

async function _makePaymentTransaction(paymentTransactionId, nodeId, operator, paymentAmount) {
  const accountAmounts = [];

  if (operator != null) {
    accountAmounts.push({
      accountID: operator.accountId._toProtobuf(),
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  } else {
    accountAmounts.push({
      accountID: new _AccountId.default(0)._toProtobuf(),
      amount: paymentAmount.negated().toTinybars()
    });
    accountAmounts.push({
      accountID: nodeId._toProtobuf(),
      amount: paymentAmount.toTinybars()
    });
  }
  /**
   * @type {proto.ITransactionBody}
   */


  const body = {
    transactionID: paymentTransactionId._toProtobuf(),
    nodeAccountID: nodeId._toProtobuf(),
    transactionFee: new _Hbar.default(1).toTinybars(),
    transactionValidDuration: {
      seconds: _long.default.fromNumber(120)
    },
    cryptoTransfer: {
      transfers: {
        accountAmounts
      }
    }
  };
  /** @type {proto.ISignedTransaction} */

  const signedTransaction = {
    bodyBytes: _proto.TransactionBody.encode(body).finish()
  };

  if (operator != null) {
    const signature = await operator.transactionSigner(
    /** @type {Uint8Array} */
    signedTransaction.bodyBytes);
    signedTransaction.sigMap = {
      sigPair: [{
        pubKeyPrefix: operator.publicKey.toBytes(),
        ed25519: signature
      }]
    };
  }

  return {
    signedTransactionBytes: _proto.SignedTransaction.encode(signedTransaction).finish()
  };
}
/**
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */


const COST_QUERY = [];
exports.COST_QUERY = COST_QUERY;

/***/ }),

/***/ 1296:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleCreateTransactionBody} proto.IScheduleCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ISignatureMap} proto.ISignatureMap
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
 * @typedef {import("@hashgraph/cryptography").PrivateKey} PrivateKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleCreateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {Key} [props.adminKey]
   * @param {AccountId} [props.payerAccountID]
   * @param {string} [props.scheduleMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?Transaction}
     */

    this._scheduledTransaction = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._payerAccountId = null;
    /**
     * @private
     * @type {?string}
     */

    this._scheduleMemo = null;
    /**
     * @private
     * @type {Set<string>}
     */

    this._scheduledSignerPublicKeys = new Set();

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.payerAccountID != null) {
      this.setPayerAccountId(props.payerAccountID);
    }

    if (props.scheduleMemo != null) {
      this.setScheduleMemo(props.scheduleMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ScheduleCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.IScheduleCreateTransactionBody} */
    body.scheduleCreate;
    return _Transaction.default._fromProtobufTransactions(new ScheduleCreateTransaction({
      adminKey: create.adminKey != null ? (0, _protobuf.keyFromProtobuf)(create.adminKey) : undefined,
      payerAccountID: create.payerAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      create.payerAccountID) : undefined,
      scheduleMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @internal
   * @param {Transaction} tx
   * @returns {this}
   */


  _setScheduledTransaction(tx) {
    this._scheduledTransaction = tx;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * Set the key for this account.
   *
   * This is the key that must sign each transfer out of the account.
   *
   * If `receiverSignatureRequired` is true, then the key must also sign
   * any transfer into the account.
   *
   * @param {Key} key
   * @returns {this}
   */


  setAdminKey(key) {
    this._requireNotFrozen();

    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get payerAccountId() {
    return this._payerAccountId;
  }
  /**
   * @param {AccountId} account
   * @returns {this}
   */


  setPayerAccountId(account) {
    this._requireNotFrozen();

    this._payerAccountId = account;
    return this;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setScheduleMemo(memo) {
    this._requireNotFrozen();

    this._scheduleMemo = memo;
    return this;
  }
  /**
   * @returns {?string}
   */


  get getScheduleMemo() {
    this._requireNotFrozen();

    return this._scheduleMemo;
  }
  /**
   * @param {Transaction} transaction
   * @returns {this}
   */


  setScheduledTransaction(transaction) {
    this._requireNotFrozen();

    transaction._requireNotFrozen();

    this._scheduledTransaction = transaction.schedule()._scheduledTransaction;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._payerAccountId != null) {
      this._payerAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.schedule.createSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "scheduleCreate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IScheduleCreateTransactionBody}
   */


  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      payerAccountID: this._payerAccountId != null ? this._payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this._scheduledTransaction != null ? this._scheduledTransaction._getScheduledTransactionBody() : null,
      memo: this._scheduleMemo
    };
  }

}

exports.default = ScheduleCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("scheduleCreate", // eslint-disable-next-line @typescript-eslint/unbound-method
ScheduleCreateTransaction._fromProtobuf);

_Transaction.SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());

/***/ }),

/***/ 1492:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleDeleteTransactionBody} proto.IScheduleDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduleID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {ScheduleId | string} [props.scheduleId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ScheduleId}
     */

    this._scheduleId = null;

    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ScheduleDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const scheduleDelete =
    /** @type {proto.IScheduleDeleteTransactionBody} */
    body.scheduleDelete;
    return _Transaction.default._fromProtobufTransactions(new ScheduleDeleteTransaction({
      scheduleId: scheduleDelete.scheduleID != null ? _ScheduleId.default._fromProtobuf(
      /** @type {proto.IScheduleID} */
      scheduleDelete.scheduleID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?ScheduleId}
   */


  get scheduleId() {
    return this._scheduleId;
  }
  /**
   * @param {ScheduleId | string} scheduleId
   * @returns {this}
   */


  setScheduleId(scheduleId) {
    this._requireNotFrozen();

    this._scheduleId = typeof scheduleId === "string" ? _ScheduleId.default.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.schedule.deleteSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "scheduleDelete";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IScheduleDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }

}

exports.default = ScheduleDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("scheduleDelete", // eslint-disable-next-line @typescript-eslint/unbound-method
ScheduleDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 9032:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 *
 * @augments {EntityId<proto.IScheduleID>}
 */
class ScheduleId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {ScheduleId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new ScheduleId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.IScheduleID} id
   * @param {(string | null)=} ledgerId
   * @returns {ScheduleId}
   */


  static _fromProtobuf(id, ledgerId) {
    const scheduleId = new ScheduleId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.scheduleNum != null ? id.scheduleNum : 0);

    if (ledgerId != null) {
      scheduleId._setNetwork(ledgerId);
    }

    return scheduleId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScheduleId}
   */


  static fromBytes(bytes) {
    return ScheduleId._fromProtobuf(proto.ScheduleID.decode(bytes));
  }
  /**
   * @param {string} address
   * @returns {ScheduleId}
   */


  static fromSolidityAddress(address) {
    return new ScheduleId(...entity_id.fromSolidityAddress(address));
  }
  /**
   * @internal
   * @override
   * @returns {proto.ScheduleID}
   */


  _toProtobuf() {
    return {
      scheduleNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.ScheduleID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {ScheduleId}
   */


  clone() {
    const id = new ScheduleId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = ScheduleId;

/***/ }),

/***/ 3919:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _protobuf = __nccwpck_require__(223);

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Transaction = _interopRequireDefault(__nccwpck_require__(3972));

var _proto = __nccwpck_require__(973);

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IScheduleInfo} proto.IScheduleInfo
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduleID
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduledID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 * @typedef {import("@hashgraph/proto").ISchedulableTransactionBody} proto.ISchedulableTransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("@hashgraph/cryptography").KeyList} KeyList
 */

/**
 * Response when the client sends the node ScheduleGetInfoQuery.
 */
class ScheduleInfo {
  /**
   * @private
   * @param {object} props
   * @param {ScheduleId} props.scheduleId;
   * @param {?AccountId} props.creatorAccountID;
   * @param {?AccountId} props.payerAccountID;
   * @param {?proto.ISchedulableTransactionBody} props.schedulableTransactionBody;
   * @param {?Key} props.adminKey
   * @param {?KeyList} props.signers;
   * @param {?string} props.scheduleMemo;
   * @param {?Timestamp} props.expirationTime;
   * @param {?Timestamp} props.executed;
   * @param {?Timestamp} props.deleted;
   * @param {?TransactionId} props.scheduledTransactionId;
   */
  constructor(props) {
    /**
     *
     * @readonly
     */
    this.scheduleId = props.scheduleId;
    /**
     *
     * @readonly
     */

    this.creatorAccountId = props.creatorAccountID;
    /**
     *
     * @readonly
     */

    this.payerAccountId = props.payerAccountID;
    /**
     *
     * @readonly
     */

    this.schedulableTransactionBody = props.schedulableTransactionBody;
    /**
     *
     * @readonly
     */

    this.signers = props.signers;
    /**
     *
     * @readonly
     */

    this.scheduleMemo = props.scheduleMemo;
    /**
     *
     * @readonly
     */

    this.adminKey = props.adminKey != null ? props.adminKey : null;
    /**
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     *
     * @readonly
     */

    this.executed = props.executed;
    /**
     *
     * @readonly
     */

    this.deleted = props.deleted;
    this.scheduledTransactionId = props.scheduledTransactionId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IScheduleInfo} info
   * @param {(string | null)=} ledgerId
   * @returns {ScheduleInfo}
   */


  static _fromProtobuf(info, ledgerId) {
    return new ScheduleInfo({
      scheduleId: _ScheduleId.default._fromProtobuf(
      /** @type {proto.IScheduleID} */
      info.scheduleID, ledgerId),
      creatorAccountID: info.creatorAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      info.creatorAccountID, ledgerId) : null,
      payerAccountID: info.payerAccountID != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      info.payerAccountID, ledgerId) : null,
      schedulableTransactionBody: info.scheduledTransactionBody != null ? info.scheduledTransactionBody : null,
      adminKey: info.adminKey != null ? (0, _protobuf.keyFromProtobuf)(info.adminKey, ledgerId) : null,
      signers: info.signers != null ? (0, _protobuf.keyListFromProtobuf)(info.signers) : null,
      scheduleMemo: info.memo != null ? info.memo : null,
      expirationTime: info.expirationTime != null ? _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.expirationTime) : null,
      executed: info.executionTime != null ? _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.executionTime) : null,
      deleted: info.deletionTime != null ? _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.deletionTime) : null,
      scheduledTransactionId: info.scheduledTransactionID != null ? _TransactionId.default._fromProtobuf(info.scheduledTransactionID, ledgerId) : null
    });
  }
  /**
   * @returns {proto.IScheduleInfo}
   */


  _toProtobuf() {
    return {
      scheduleID: this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
      creatorAccountID: this.creatorAccountId != null ? this.creatorAccountId._toProtobuf() : null,
      payerAccountID: this.payerAccountId != null ? this.payerAccountId._toProtobuf() : null,
      scheduledTransactionBody: this.schedulableTransactionBody != null ? this.schedulableTransactionBody : null,
      adminKey: this.adminKey != null ? (0, _protobuf.keyToProtobuf)(this.adminKey) : null,
      signers: this.signers != null ? (0, _protobuf.keyListToProtobuf)(this.signers) : null,
      memo: this.scheduleMemo != null ? this.scheduleMemo : "",
      expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null
    };
  }
  /**
   * @returns {Transaction}
   */


  get scheduledTransaction() {
    if (this.schedulableTransactionBody == null) {
      throw new Error("Scheduled transaction body is empty");
    }

    const scheduled = new _proto.SchedulableTransactionBody(this.schedulableTransactionBody);
    const data =
    /** @type {NonNullable<ProtoSchedulableTransactionBody["data"]>} */
    scheduled.data;
    return _Transaction.default.fromBytes(_proto.TransactionList.encode({
      transactionList: [{
        signedTransactionBytes: _proto.SignedTransaction.encode({
          bodyBytes: _proto.TransactionBody.encode({
            transactionFee: this.schedulableTransactionBody.transactionFee,
            memo: this.schedulableTransactionBody.memo,
            [data]: scheduled[data]
          }).finish()
        }).finish()
      }]
    }).finish());
  }

}

exports.default = ScheduleInfo;

/***/ }),

/***/ 3519:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _ScheduleInfo = _interopRequireDefault(__nccwpck_require__(3919));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IScheduleInfo} proto.IScheduleInfo
 * @typedef {import("@hashgraph/proto").IScheduleGetInfoQuery} proto.IScheduleGetInfoQuery
 * @typedef {import("@hashgraph/proto").IScheduleGetInfoResponse} proto.IScheduleGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<ScheduleInfo>}
 */
class ScheduleInfoQuery extends _Query.default {
  /**
   * @param {object} properties
   * @param {ScheduleId | string} [properties.scheduleId]
   */
  constructor(properties = {}) {
    super();
    /**
     * @private
     * @type {?ScheduleId}
     */

    this._scheduleId = null;

    if (properties.scheduleId != null) {
      this.setScheduleId(properties.scheduleId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {ScheduleInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.IScheduleGetInfoQuery} */
    query.scheduleGetInfo;
    return new ScheduleInfoQuery({
      scheduleId: info.scheduleID != null ? _ScheduleId.default._fromProtobuf(info.scheduleID) : undefined
    });
  }
  /**
   * @returns {?ScheduleId}
   */


  get scheduleId() {
    return this._scheduleId;
  }
  /**
   *
   * @param {ScheduleId | string} scheduleId
   * @returns {ScheduleInfoQuery}
   */


  setScheduleId(scheduleId) {
    this._scheduleId = typeof scheduleId === "string" ? _ScheduleId.default.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.schedule.getScheduleInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const scheduleGetInfo =
    /** @type {proto.IScheduleGetInfoResponse} */
    response.scheduleGetInfo;
    return (
      /** @type {proto.IResponseHeader} */
      scheduleGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<ScheduleInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const info =
    /** @type {proto.IScheduleGetInfoResponse} */
    response.scheduleGetInfo;
    return Promise.resolve(_ScheduleInfo.default._fromProtobuf(
    /** @type {proto.IScheduleInfo} */
    info.scheduleInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      scheduleGetInfo: {
        header,
        scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = ScheduleInfoQuery;

_Query.QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);

/***/ }),

/***/ 3122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleSignTransactionBody} proto.IScheduleSignTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ISignatureMap} proto.ISignatureMap
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleSignTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {ScheduleId | string} [props.scheduleId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?ScheduleId}
     */

    this._scheduleId = null;

    if (props.scheduleId != null) {
      this.setScheduleId(props.scheduleId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {ScheduleSignTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const sign =
    /** @type {proto.IScheduleSignTransactionBody} */
    body.scheduleSign;
    return _Transaction.default._fromProtobufTransactions(new ScheduleSignTransaction({
      scheduleId: sign.scheduleID != null ? _ScheduleId.default._fromProtobuf(sign.scheduleID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?ScheduleId}
   */


  get scheduleId() {
    return this._scheduleId;
  }
  /**
   * @param {ScheduleId | string} scheduleId
   * @returns {this}
   */


  setScheduleId(scheduleId) {
    this._requireNotFrozen();

    this._scheduleId = typeof scheduleId === "string" ? _ScheduleId.default.fromString(scheduleId) : scheduleId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._scheduleId != null) {
      this._scheduleId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.schedule.signSchedule(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "scheduleSign";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IScheduleSignTransactionBody}
   */


  _makeTransactionData() {
    return {
      scheduleID: this._scheduleId != null ? this._scheduleId._toProtobuf() : null
    };
  }

}

exports.default = ScheduleSignTransaction;

_Transaction.TRANSACTION_REGISTRY.set("scheduleSign", // eslint-disable-next-line @typescript-eslint/unbound-method
ScheduleSignTransaction._fromProtobuf);

/***/ }),

/***/ 6807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFreezeTransactionBody} proto.IFreezeTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} HourMinute
 * @property {number} hour
 * @property {number} minute
 */
class FreezeTransaction extends _Transaction.default {
  /**
   * @param {Object} [props]
   * @param {HourMinute} [props.startTime]
   * @param {HourMinute} [props.endTime]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?HourMinute}
     */

    this._startTime = null;
    /**
     * @private
     * @type {?HourMinute}
     */

    this._endTime = null;

    if (props.startTime != null) {
      this.setStartTime(props.startTime.hour, props.startTime.minute);
    }

    if (props.endTime != null) {
      this.setEndTime(props.endTime.hour, props.endTime.minute);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {FreezeTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freeze =
    /** @type {proto.IFreezeTransactionBody} */
    body.freeze;
    return _Transaction.default._fromProtobufTransactions(new FreezeTransaction({
      startTime: freeze.startHour != null && freeze.startMin != null ? {
        hour: freeze.startHour,
        minute: freeze.startMin
      } : undefined,
      endTime: freeze.endHour != null && freeze.endMin != null ? {
        hour: freeze.endHour,
        minute: freeze.endMin
      } : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?HourMinute}
   */


  get startTime() {
    return this._startTime;
  }
  /**
   * @param {number | string} startHourOrString
   * @param {?number} startMinute
   * @returns {FreezeTransaction}
   */


  setStartTime(startHourOrString, startMinute) {
    this._requireNotFrozen();

    if (typeof startHourOrString === "string") {
      const split = startHourOrString.split(":");
      this._startTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._startTime = {
        hour: startHourOrString,
        minute:
        /** @type {number} */
        startMinute
      };
    }

    return this;
  }
  /**
   * @returns {?HourMinute}
   */


  get endTime() {
    return this._endTime;
  }
  /**
   * @param {number | string} endHourOrString
   * @param {?number} endMinute
   * @returns {FreezeTransaction}
   */


  setEndTime(endHourOrString, endMinute) {
    this._requireNotFrozen();

    if (typeof endHourOrString === "string") {
      const split = endHourOrString.split(":");
      this._endTime = {
        hour: Number(split[0]),
        minute: Number(split[1])
      };
    } else {
      this._endTime = {
        hour: endHourOrString,
        minute:
        /** @type {number} */
        endMinute
      };
    }

    return this;
  }
  /**
   * @override
   * @protected
   * @param {Channel} channel
   * @returns {(transaction: proto.ITransaction) => Promise<proto.ITransactionResponse>}
   */


  _getMethod(channel) {
    return transaction => channel.freeze.freeze(transaction);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "freeze";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IFreezeTransactionBody}
   */


  _makeTransactionData() {
    return {
      startHour: this._startTime != null ? this._startTime.hour : null,
      startMin: this._startTime != null ? this._startTime.minute : null,
      endHour: this._endTime != null ? this._endTime.hour : null,
      endMin: this._endTime != null ? this._endTime.minute : null
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = FreezeTransaction;

_Transaction.TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);

/***/ }),

/***/ 3805:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ISystemDeleteTransactionBody} proto.ISystemDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class SystemDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {ContractId | string} [props.contractId]
   * @param {Timestamp} [props.expirationTime]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._fileId = null;
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {SystemDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemDelete =
    /** @type {proto.ISystemDeleteTransactionBody} */
    body.systemDelete;
    return _Transaction.default._fromProtobufTransactions(new SystemDeleteTransaction({
      fileId: systemDelete.fileID != null ? _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      systemDelete.fileID) : undefined,
      contractId: systemDelete.contractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      systemDelete.contractID) : undefined,
      expirationTime: systemDelete.expirationTime != null ? _Timestamp.default._fromProtobuf(systemDelete.expirationTime) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId | string} fileId
   * @returns {this}
   */


  setFileId(fileId) {
    this._requireNotFrozen();

    this._fileId = fileId instanceof _FileId.default ? fileId : _FileId.default.fromString(fileId);
    return this;
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * @param {ContractId | string} contractId
   * @returns {this}
   */


  setContractId(contractId) {
    this._requireNotFrozen();

    this._contractId = contractId instanceof _ContractId.default ? contractId : _ContractId.default.fromString(contractId);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp} expirationTime
   * @returns {SystemDeleteTransaction}
   */


  setExpirationTime(expirationTime) {
    this._requireNotFrozen();

    this._expirationTime = expirationTime;
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemDelete(request);
    } else {
      return channel.smartContract.systemDelete(request);
    }
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "systemDelete";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ISystemDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null,
      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = SystemDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 1403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ISystemUndeleteTransactionBody} proto.ISystemUndeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */
class SystemUndeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {FileId | string} [props.fileId]
   * @param {ContractId | string} [props.contractId]
   * @param {Timestamp} [props.expirationTime]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?FileId}
     */

    this._fileId = null;
    /**
     * @private
     * @type {?ContractId}
     */

    this._contractId = null;

    if (props.fileId != null) {
      this.setFileId(props.fileId);
    }

    if (props.contractId != null) {
      this.setContractId(props.contractId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {SystemUndeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const systemUndelete =
    /** @type {proto.ISystemUndeleteTransactionBody} */
    body.systemUndelete;
    return _Transaction.default._fromProtobufTransactions(new SystemUndeleteTransaction({
      fileId: systemUndelete.fileID != null ? _FileId.default._fromProtobuf(
      /** @type {proto.IFileID} */
      systemUndelete.fileID) : undefined,
      contractId: systemUndelete.contractID != null ? _ContractId.default._fromProtobuf(
      /** @type {proto.IContractID} */
      systemUndelete.contractID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?FileId}
   */


  get fileId() {
    return this._fileId;
  }
  /**
   * @param {FileId | string} fileId
   * @returns {this}
   */


  setFileId(fileId) {
    this._requireNotFrozen();

    this._fileId = fileId instanceof _FileId.default ? fileId : _FileId.default.fromString(fileId);
    return this;
  }
  /**
   * @returns {?ContractId}
   */


  get contractId() {
    return this._contractId;
  }
  /**
   * @param {ContractId | string} contractId
   * @returns {this}
   */


  setContractId(contractId) {
    this._requireNotFrozen();

    this._contractId = contractId instanceof _ContractId.default ? contractId : _ContractId.default.fromString(contractId);
    return this;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    if (this._fileId != null) {
      return channel.file.systemUndelete(request);
    } else {
      return channel.smartContract.systemUndelete(request);
    }
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "systemUndelete";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ISystemUndeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
      contractID: this._contractId != null ? this._contractId._toProtobuf() : null
    };
  }

}

exports.default = SystemUndeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("systemUndelete", // eslint-disable-next-line @typescript-eslint/unbound-method
SystemUndeleteTransaction._fromProtobuf);

/***/ }),

/***/ 2334:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenAssociateTransactionBody} proto.ITokenAssociateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Associate a new Hedera crypto-currency token.
 */
class TokenAssociateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {(TokenId | string)[]} [props.tokenIds]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId[]}
     */

    this._tokenIds = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;
    this.setMaxTransactionFee(new _Hbar.default(5));

    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenAssociateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const associateToken =
    /** @type {proto.ITokenAssociateTransactionBody} */
    body.tokenAssociate;
    return _Transaction.default._fromProtobufTransactions(new TokenAssociateTransaction({
      tokenIds: associateToken.tokens != null ? associateToken.tokens.map(token => _TokenId.default._fromProtobuf(token)) : undefined,
      accountId: associateToken.account != null ? _AccountId.default._fromProtobuf(associateToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId[]}
   */


  get tokenIds() {
    return this._tokenIds;
  }
  /**
   * @param {(TokenId | string)[]} tokenIds
   * @returns {this}
   */


  setTokenIds(tokenIds) {
    this._requireNotFrozen();

    this._tokenIds = tokenIds.map(tokenId => typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone());
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }

    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validate(client);
      }
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.associateTokens(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenAssociate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenAssociateTransactionBody}
   */


  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map(tokenId => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenAssociateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenAssociate", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenAssociateTransaction._fromProtobuf);

/***/ }),

/***/ 3464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenBurnTransactionBody} proto.ITokenBurnTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Burn a new Hedera crypto-currency token.
 */
class TokenBurnTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {Long | number} [props.amount]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?Long}
     */

    this._amount = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.amount != null) {
      this.setAmount(props.amount);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenBurnTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const burnToken =
    /** @type {proto.ITokenBurnTransactionBody} */
    body.tokenBurn;
    return _Transaction.default._fromProtobufTransactions(new TokenBurnTransaction({
      tokenId: burnToken.token != null ? _TokenId.default._fromProtobuf(burnToken.token) : undefined,
      amount: burnToken.amount != null ? burnToken.amount : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */


  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */


  setAmount(amount) {
    this._requireNotFrozen();

    this._amount = amount instanceof _long.default ? amount : _long.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.burnToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenBurn";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenBurnTransactionBody}
   */


  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }

}

exports.default = TokenBurnTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenBurn", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenBurnTransaction._fromProtobuf);

/***/ }),

/***/ 8123:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenCreateTransactionBody} proto.ITokenCreateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency token.
 */
class TokenCreateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {string} [props.tokenName]
   * @param {string} [props.tokenSymbol]
   * @param {Long | number} [props.decimals]
   * @param {Long | number} [props.initialSupply]
   * @param {AccountId | string} [props.treasuryAccountId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.kycKey]
   * @param {Key} [props.freezeKey]
   * @param {Key} [props.wipeKey]
   * @param {Key} [props.supplyKey]
   * @param {boolean} [props.freezeDefault]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.tokenMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?string}
     */

    this._tokenName = null;
    /**
     * @private
     * @type {?string}
     */

    this._tokenSymbol = null;
    /**
     * @private
     * @type {?Long}
     */

    this._decimals = null;
    /**
     * @private
     * @type {?Long}
     */

    this._initialSupply = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._treasuryAccountId = null;
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._kycKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._freezeKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._wipeKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._supplyKey = null;
    /**
     * @private
     * @type {?boolean}
     */

    this._freezeDefault = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._autoRenewAccountId = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;
    /**
     * @private
     * @type {?Duration}
     */

    this._autoRenewPeriod = new _Duration.default(_Transaction.DEFAULT_AUTO_RENEW_PERIOD);
    /**
     * @private
     * @type {?string}
     */

    this._tokenMemo = null;
    this.setMaxTransactionFee(new _Hbar.default(30));

    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }

    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }

    if (props.decimals != null) {
      this.setDecimals(props.decimals);
    }

    if (props.initialSupply != null) {
      this.setInitialSupply(props.initialSupply);
    }

    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }

    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }

    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }

    if (props.supplyKey != null) {
      this.setSupplyKey(props.supplyKey);
    }

    if (props.freezeDefault != null) {
      this.setFreezeDefault(props.freezeDefault);
    }

    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.ITokenCreateTransactionBody} */
    body.tokenCreation;
    return _Transaction.default._fromProtobufTransactions(new TokenCreateTransaction({
      tokenName: create.name != null ? create.name : undefined,
      tokenSymbol: create.symbol != null ? create.symbol : undefined,
      decimals: create.decimals != null ? create.decimals : undefined,
      initialSupply: create.initialSupply != null ? create.initialSupply : undefined,
      treasuryAccountId: create.treasury != null ? _AccountId.default._fromProtobuf(create.treasury) : undefined,
      adminKey: create.adminKey != null ? (0, _protobuf.keyFromProtobuf)(create.adminKey) : undefined,
      kycKey: create.kycKey != null ? (0, _protobuf.keyFromProtobuf)(create.kycKey) : undefined,
      freezeKey: create.freezeKey != null ? (0, _protobuf.keyFromProtobuf)(create.freezeKey) : undefined,
      wipeKey: create.wipeKey != null ? (0, _protobuf.keyFromProtobuf)(create.wipeKey) : undefined,
      supplyKey: create.supplyKey != null ? (0, _protobuf.keyFromProtobuf)(create.supplyKey) : undefined,
      freezeDefault: create.freezeDefault != null ? create.freezeDefault : undefined,
      autoRenewAccountId: create.autoRenewAccount != null ? _AccountId.default._fromProtobuf(create.autoRenewAccount) : undefined,
      expirationTime: create.expiry != null ? _Timestamp.default._fromProtobuf(create.expiry) : undefined,
      autoRenewPeriod: create.autoRenewPeriod != null ? _Duration.default._fromProtobuf(create.autoRenewPeriod) : undefined,
      tokenMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?string}
   */


  get tokenName() {
    return this._tokenName;
  }
  /**
   * @param {string} name
   * @returns {this}
   */


  setTokenName(name) {
    this._requireNotFrozen();

    this._tokenName = name;
    return this;
  }
  /**
   * @returns {?string}
   */


  get tokenSymbol() {
    return this._tokenSymbol;
  }
  /**
   * @param {string} symbol
   * @returns {this}
   */


  setTokenSymbol(symbol) {
    this._requireNotFrozen();

    this._tokenSymbol = symbol;
    return this;
  }
  /**
   * @returns {?Long}
   */


  get decimals() {
    return this._decimals;
  }
  /**
   * @param {Long | number} decimals
   * @returns {this}
   */


  setDecimals(decimals) {
    this._requireNotFrozen();

    this._decimals = decimals instanceof _long.default ? decimals : _long.default.fromValue(decimals);
    return this;
  }
  /**
   * @returns {?Long}
   */


  get initialSupply() {
    return this._initialSupply;
  }
  /**
   * @param {Long | number} initialSupply
   * @returns {this}
   */


  setInitialSupply(initialSupply) {
    this._requireNotFrozen();

    this._initialSupply = _long.default.fromValue(initialSupply);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */


  setTreasuryAccountId(id) {
    this._requireNotFrozen();

    this._treasuryAccountId = typeof id === "string" ? _AccountId.default.fromString(id) : id.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setAdminKey(key) {
    this._requireNotFrozen();

    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get kycKey() {
    return this._kycKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setKycKey(key) {
    this._requireNotFrozen();

    this._kycKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get freezeKey() {
    return this._freezeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setFreezeKey(key) {
    this._requireNotFrozen();

    this._freezeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get wipeKey() {
    return this._wipeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setWipeKey(key) {
    this._requireNotFrozen();

    this._wipeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get supplyKey() {
    return this._supplyKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setSupplyKey(key) {
    this._requireNotFrozen();

    this._supplyKey = key;
    return this;
  }
  /**
   * @returns {?boolean}
   */


  get freezeDefault() {
    return this._freezeDefault;
  }
  /**
   * @param {boolean} freeze
   * @returns {this}
   */


  setFreezeDefault(freeze) {
    this._requireNotFrozen();

    this._freezeDefault = freeze;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} time
   * @returns {this}
   */


  setExpirationTime(time) {
    this._requireNotFrozen();

    this._autoRenewPeriod = null;
    this._expirationTime = time instanceof _Timestamp.default ? time : _Timestamp.default.fromDate(time);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */


  setAutoRenewAccountId(id) {
    this._requireNotFrozen();

    this._autoRenewAccountId = id instanceof _AccountId.default ? id : _AccountId.default.fromString(id);
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this token.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */


  get tokenMemo() {
    return this._tokenMemo;
  }
  /**
   * @param {string} memo
   * @returns {this}
   */


  setTokenMemo(memo) {
    this._requireNotFrozen();

    this._tokenMemo = memo;
    return this;
  }
  /**
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */


  freezeWith(client) {
    if (this._autoRenewPeriod != null && client != null && client.operatorAccountId) {
      this._autoRenewAccountId = client.operatorAccountId;
    }

    return super.freezeWith(client);
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validate(client);
    }

    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.createToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenCreation";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenCreateTransactionBody}
   */


  _makeTransactionData() {
    return {
      name: this._tokenName,
      symbol: this._tokenSymbol,
      decimals: this._decimals != null ? this._decimals.toInt() : null,
      initialSupply: this._initialSupply,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      kycKey: this._kycKey != null ? (0, _protobuf.keyToProtobuf)(this._kycKey) : null,
      freezeKey: this._freezeKey != null ? (0, _protobuf.keyToProtobuf)(this._freezeKey) : null,
      wipeKey: this._wipeKey != null ? (0, _protobuf.keyToProtobuf)(this._wipeKey) : null,
      supplyKey: this._supplyKey != null ? (0, _protobuf.keyToProtobuf)(this._supplyKey) : null,
      freezeDefault: this._freezeDefault,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo
    };
  }

}

exports.default = TokenCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenCreation", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenCreateTransaction._fromProtobuf);

/***/ }),

/***/ 6903:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenDeleteTransactionBody} proto.ITokenDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a new Hedera crypto-currency token.
 */
class TokenDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const deleteToken =
    /** @type {proto.ITokenDeleteTransactionBody} */
    body.tokenDeletion;
    return _Transaction.default._fromProtobufTransactions(new TokenDeleteTransaction({
      tokenId: deleteToken.token != null ? _TokenId.default._fromProtobuf(deleteToken.token) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.deleteToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenDeletion";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenDeleteTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }

}

exports.default = TokenDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenDeletion", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 2651:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenDissociateTransactionBody} proto.ITokenDissociateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Dissociate a new Hedera crypto-currency token.
 */
class TokenDissociateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {(TokenId | string)[]} [props.tokenIds]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId[]}
     */

    this._tokenIds = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;
    this.setMaxTransactionFee(new _Hbar.default(5));

    if (props.tokenIds != null) {
      this.setTokenIds(props.tokenIds);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenDissociateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const dissociateToken =
    /** @type {proto.ITokenDissociateTransactionBody} */
    body.tokenDissociate;
    return _Transaction.default._fromProtobufTransactions(new TokenDissociateTransaction({
      tokenIds: dissociateToken.tokens != null ? dissociateToken.tokens.map(token => _TokenId.default._fromProtobuf(token)) : undefined,
      accountId: dissociateToken.account != null ? _AccountId.default._fromProtobuf(dissociateToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId[]}
   */


  get tokenIds() {
    return this._tokenIds;
  }
  /**
   * @param {(TokenId | string)[]} tokenIds
   * @returns {this}
   */


  setTokenIds(tokenIds) {
    this._requireNotFrozen();

    this._tokenIds = tokenIds.map(tokenId => typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone());
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._accountId != null) {
      this._accountId.validate(client);
    }

    for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
      if (tokenId != null) {
        tokenId.validate(client);
      }
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.dissociateTokens(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenDissociate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenDissociateTransactionBody}
   */


  _makeTransactionData() {
    return {
      tokens: this._tokenIds != null ? this._tokenIds.map(tokenId => tokenId._toProtobuf()) : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenDissociateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenDissociate", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenDissociateTransaction._fromProtobuf);

/***/ }),

/***/ 3825:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenFreezeAccountTransactionBody} proto.ITokenFreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Freeze a new Hedera crypto-currency token.
 */
class TokenFreezeTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenFreezeTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const freezeToken =
    /** @type {proto.ITokenFreezeAccountTransactionBody} */
    body.tokenFreeze;
    return _Transaction.default._fromProtobufTransactions(new TokenFreezeTransaction({
      tokenId: freezeToken.token != null ? _TokenId.default._fromProtobuf(freezeToken.token) : undefined,
      accountId: freezeToken.account != null ? _AccountId.default._fromProtobuf(freezeToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.freezeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenFreeze";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenFreezeAccountTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenFreezeTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenFreeze", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenFreezeTransaction._fromProtobuf);

/***/ }),

/***/ 5443:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenGrantKycTransactionBody} proto.ITokenGrantKycTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * GrantKyc a new Hedera crypto-currency token.
 */
class TokenGrantKycTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenGrantKycTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const grantKycToken =
    /** @type {proto.ITokenGrantKycTransactionBody} */
    body.tokenGrantKyc;
    return _Transaction.default._fromProtobufTransactions(new TokenGrantKycTransaction({
      tokenId: grantKycToken.token != null ? _TokenId.default._fromProtobuf(grantKycToken.token) : undefined,
      accountId: grantKycToken.account != null ? _AccountId.default._fromProtobuf(grantKycToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.grantKycToTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenGrantKyc";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenGrantKycTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenGrantKycTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenGrantKyc", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenGrantKycTransaction._fromProtobuf);

/***/ }),

/***/ 6297:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency token on Hedera.
 */
class TokenId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {TokenId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new TokenId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.ITokenID} id
   * @param {(string | null)=} ledgerId
   * @returns {TokenId}
   */


  static _fromProtobuf(id, ledgerId) {
    const tokenId = new TokenId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.tokenNum != null ? id.tokenNum : 0);

    if (ledgerId != null) {
      tokenId._setNetwork(ledgerId);
    }

    return tokenId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TokenId}
   */


  static fromBytes(bytes) {
    return TokenId._fromProtobuf(proto.TokenID.decode(bytes));
  }
  /**
   * @param {string} address
   * @returns {TokenId}
   */


  static fromSolidityAddress(address) {
    return new TokenId(...entity_id.fromSolidityAddress(address));
  }
  /**
   * @internal
   * @override
   * @returns {proto.ITokenID}
   */


  _toProtobuf() {
    return {
      tokenNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.TokenID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {TokenId}
   */


  clone() {
    const id = new TokenId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = TokenId;

/***/ }),

/***/ 9425:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _protobuf = __nccwpck_require__(223);

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _long = _interopRequireDefault(__nccwpck_require__(492));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */

/**
 * Response when the client sends the node TokenGetInfoQuery.
 */
class TokenInfo {
  /**
   * @private
   * @param {object} props
   * @param {TokenId} props.tokenId;
   * @param {string} props.name;
   * @param {string} props.symbol;
   * @param {number} props.decimals;
   * @param {Long} props.totalSupply;
   * @param {AccountId | null} props.treasuryAccountId;
   * @param {Key | null} props.adminKey;
   * @param {Key | null} props.kycKey;
   * @param {Key | null} props.freezeKey;
   * @param {Key | null} props.wipeKey;
   * @param {Key | null} props.supplyKey;
   * @param {boolean | null} props.defaultFreezeStatus;
   * @param {boolean | null} props.defaultKycStatus;
   * @param {boolean} props.isDeleted;
   * @param {AccountId | null} props.autoRenewAccountId;
   * @param {Duration | null} props.autoRenewPeriod;
   * @param {Timestamp | null} props.expirationTime;
   * @param {string} props.tokenMemo;
   */
  constructor(props) {
    /**
     * ID of the token instance
     *
     * @readonly
     */
    this.tokenId = props.tokenId;
    /**
     * The name of the token. It is a string of ASCII only characters
     *
     * @readonly
     */

    this.name = props.name;
    /**
     * The symbol of the token. It is a UTF-8 capitalized alphabetical string
     *
     * @readonly
     */

    this.symbol = props.symbol;
    /**
     * The number of decimal places a token is divisible by
     *
     * @readonly
     */

    this.decimals = props.decimals;
    /**
     * The total supply of tokens that are currently in circulation
     *
     * @readonly
     */

    this.totalSupply = props.totalSupply;
    /**
     * The ID of the account which is set as treasuryAccountId
     *
     * @readonly
     */

    this.treasuryAccountId = props.treasuryAccountId;
    /**
     * The key which can perform update/delete operations on the token. If empty, the token can be perceived as
     * immutable (not being able to be updated/deleted)
     *
     * @readonly
     */

    this.adminKey = props.adminKey;
    /**
     * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required,
     * and KYC grant or revoke operations are not possible.
     *
     * @readonly
     */

    this.kycKey = props.kycKey;
    /**
     * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
     *
     * @readonly
     */

    this.freezeKey = props.freezeKey;
    /**
     * The key which can wipe token balance of an account. If empty, wipe is not possible
     *
     * @readonly
     */

    this.wipeKey = props.wipeKey;
    /**
     * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
     *
     * @readonly
     */

    this.supplyKey = props.supplyKey;
    /**
     * The default Freeze status (not applicable = null, frozen = false, or unfrozen = true) of Hedera accounts relative to this token.
     * FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and
     * defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
     *      FreezeNotApplicable = null;
     *      Frozen = true;
     *      Unfrozen = false;
     *
     * @readonly
     */

    this.defaultFreezeStatus = props.defaultFreezeStatus;
    /**
     * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable
     * is returned if KYC key is not set, otherwise Revoked
     *      KycNotApplicable = null;
     *      Granted = true;
     *      Revoked = false;
     *
     * @readonly
     */

    this.defaultKycStatus = props.defaultKycStatus;
    /**
     * Specifies whether the token was deleted or not
     *
     * @readonly
     */

    this.isDeleted = props.isDeleted;
    /**
     * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
     *
     * @readonly
     */

    this.autoRenewAccountId = props.autoRenewAccountId;
    /**
     * The interval at which the auto-renew account will be charged to extend the token's expiry
     *
     * @readonly
     */

    this.autoRenewPeriod = props.autoRenewPeriod;
    /**
     * The epoch second at which the token expire: will; if an auto-renew account and period are specified,
     * this is coerced to the current epoch second plus the autoRenewPeriod
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     * The memo associated with the token.
     *
     * @readonly
     */

    this.tokenMemo = props.tokenMemo;
  }
  /**
   * @internal
   * @param {proto.ITokenInfo} info
   * @param {(string | null)=} ledgerId
   * @returns {TokenInfo}
   */


  static _fromProtobuf(info, ledgerId) {
    const defaultFreezeStatus =
    /** @type {proto.TokenFreezeStatus} */
    info.defaultFreezeStatus;
    const defaultKycStatus =
    /** @type {proto.TokenKycStatus} */
    info.defaultKycStatus;
    const autoRenewAccountId = info.autoRenewAccount != null ? _AccountId.default._fromProtobuf(info.autoRenewAccount, ledgerId) : new _AccountId.default(0);
    return new TokenInfo({
      tokenId: _TokenId.default._fromProtobuf(
      /** @type {proto.ITokenID} */
      info.tokenId, ledgerId),
      name:
      /** @type {string} */
      info.name,
      symbol:
      /** @type {string} */
      info.symbol,
      decimals:
      /** @type {number} */
      info.decimals,
      totalSupply: _long.default.fromValue(
      /** @type {Long} */
      info.totalSupply),
      treasuryAccountId: info.treasury != null ? _AccountId.default._fromProtobuf(
      /** @type {proto.IAccountID} */
      info.treasury, ledgerId) : null,
      adminKey: info.adminKey != null ? (0, _protobuf.keyFromProtobuf)(info.adminKey, ledgerId) : null,
      kycKey: info.kycKey != null ? (0, _protobuf.keyFromProtobuf)(info.kycKey, ledgerId) : null,
      freezeKey: info.freezeKey != null ? (0, _protobuf.keyFromProtobuf)(info.freezeKey, ledgerId) : null,
      wipeKey: info.wipeKey != null ? (0, _protobuf.keyFromProtobuf)(info.wipeKey, ledgerId) : null,
      supplyKey: info.supplyKey != null ? (0, _protobuf.keyFromProtobuf)(info.supplyKey, ledgerId) : null,
      defaultFreezeStatus: defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
      defaultKycStatus: defaultKycStatus === 0 ? null : defaultKycStatus == 1,
      isDeleted:
      /** @type {boolean} */
      info.deleted,
      autoRenewAccountId: !(autoRenewAccountId.shard.toInt() == 0 && autoRenewAccountId.realm.toInt() == 0 && autoRenewAccountId.num.toInt() == 0) ? autoRenewAccountId : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? _Duration.default._fromProtobuf(
      /** @type {proto.IDuration} */
      info.autoRenewPeriod) : null,
      expirationTime: info.expiry != null ? _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      info.expiry) : null,
      tokenMemo: info.memo != null ? info.memo : ""
    });
  }
  /**
   * @returns {proto.ITokenInfo}
   */


  _toProtobuf() {
    return {
      tokenId: this.tokenId._toProtobuf(),
      name: this.name,
      symbol: this.symbol,
      decimals: this.decimals,
      totalSupply: this.totalSupply,
      treasury: this.treasuryAccountId != null ? this.treasuryAccountId._toProtobuf() : null,
      adminKey: this.adminKey != null ? (0, _protobuf.keyToProtobuf)(this.adminKey) : null,
      kycKey: this.kycKey != null ? (0, _protobuf.keyToProtobuf)(this.kycKey) : null,
      freezeKey: this.freezeKey != null ? (0, _protobuf.keyToProtobuf)(this.freezeKey) : null,
      wipeKey: this.wipeKey != null ? (0, _protobuf.keyToProtobuf)(this.wipeKey) : null,
      supplyKey: this.supplyKey != null ? (0, _protobuf.keyToProtobuf)(this.supplyKey) : null,
      defaultFreezeStatus: this.defaultFreezeStatus == null ? 0 : this.defaultFreezeStatus ? 1 : 2,
      defaultKycStatus: this.defaultKycStatus == null ? 0 : this.defaultKycStatus ? 1 : 2,
      deleted: this.isDeleted,
      autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : undefined,
      autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
      expiry: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
      memo: this.tokenMemo
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TokenInfo}
   */


  static fromBytes(bytes) {
    return TokenInfo._fromProtobuf(proto.TokenInfo.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.TokenInfo.encode(this._toProtobuf()).finish();
  }

}

exports.default = TokenInfo;

/***/ }),

/***/ 5248:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _TokenInfo = _interopRequireDefault(__nccwpck_require__(9425));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITokenInfo} proto.ITokenInfo
 * @typedef {import("@hashgraph/proto").ITokenGetInfoQuery} proto.ITokenGetInfoQuery
 * @typedef {import("@hashgraph/proto").ITokenGetInfoResponse} proto.ITokenGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<TokenInfo>}
 */
class TokenInfoQuery extends _Query.default {
  /**
   * @param {object} properties
   * @param {TokenId | string} [properties.tokenId]
   */
  constructor(properties = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;

    if (properties.tokenId != null) {
      this.setTokenId(properties.tokenId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {TokenInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.ITokenGetInfoQuery} */
    query.tokenGetInfo;
    return new TokenInfoQuery({
      tokenId: info.token != null ? _TokenId.default._fromProtobuf(info.token) : undefined
    });
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * Set the token ID for which the info is being requested.
   *
   * @param {TokenId | string} tokenId
   * @returns {TokenInfoQuery}
   */


  setTokenId(tokenId) {
    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.token.getTokenInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const tokenGetInfo =
    /** @type {proto.ITokenGetInfoResponse} */
    response.tokenGetInfo;
    return (
      /** @type {proto.IResponseHeader} */
      tokenGetInfo.header
    );
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<TokenInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const info =
    /** @type {proto.ITokenGetInfoResponse} */
    response.tokenGetInfo;
    return Promise.resolve(_TokenInfo.default._fromProtobuf(
    /** @type {proto.ITokenInfo} */
    info.tokenInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      tokenGetInfo: {
        header,
        token: this._tokenId != null ? this._tokenId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = TokenInfoQuery;

_Query.QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);

/***/ }),

/***/ 3192:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenMintTransactionBody} proto.ITokenMintTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Mint a new Hedera crypto-currency token.
 */
class TokenMintTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {Long | number} [props.amount]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?Long}
     */

    this._amount = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.amount != null) {
      this.setAmount(props.amount);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenMintTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const mintToken =
    /** @type {proto.ITokenMintTransactionBody} */
    body.tokenCreation;
    return _Transaction.default._fromProtobufTransactions(new TokenMintTransaction({
      tokenId: mintToken.token != null ? _TokenId.default._fromProtobuf(mintToken.token) : undefined,
      amount: mintToken.amount != null ? mintToken.amount : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */


  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */


  setAmount(amount) {
    this._requireNotFrozen();

    this._amount = amount instanceof _long.default ? amount : _long.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.mintToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenMint";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenMintTransactionBody}
   */


  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null
    };
  }

}

exports.default = TokenMintTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenMint", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenMintTransaction._fromProtobuf);

/***/ }),

/***/ 4501:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenRevokeKycTransactionBody} proto.ITokenRevokeKycTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * RevokeKyc a new Hedera crypto-currency token.
 */
class TokenRevokeKycTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenRevokeKycTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const revokeKycToken =
    /** @type {proto.ITokenRevokeKycTransactionBody} */
    body.tokenRevokeKyc;
    return _Transaction.default._fromProtobufTransactions(new TokenRevokeKycTransaction({
      tokenId: revokeKycToken.token != null ? _TokenId.default._fromProtobuf(revokeKycToken.token) : undefined,
      accountId: revokeKycToken.account != null ? _AccountId.default._fromProtobuf(revokeKycToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.revokeKycFromTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenRevokeKyc";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenRevokeKycTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenRevokeKycTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenRevokeKyc", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenRevokeKycTransaction._fromProtobuf);

/***/ }),

/***/ 2181:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenUnfreezeAccountTransactionBody} proto.ITokenUnfreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Unfreeze a new Hedera crypto-currency token.
 */
class TokenUnfreezeTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenUnfreezeTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const unfreezeToken =
    /** @type {proto.ITokenUnfreezeAccountTransactionBody} */
    body.tokenUnfreeze;
    return _Transaction.default._fromProtobufTransactions(new TokenUnfreezeTransaction({
      tokenId: unfreezeToken.token != null ? _TokenId.default._fromProtobuf(unfreezeToken.token) : undefined,
      accountId: unfreezeToken.account != null ? _AccountId.default._fromProtobuf(unfreezeToken.account) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.unfreezeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenUnfreeze";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenUnfreezeAccountTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenUnfreezeTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenUnfreeze", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenUnfreezeTransaction._fromProtobuf);

/***/ }),

/***/ 3081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenUpdateTransactionBody} proto.ITokenUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera crypto-currency token.
 */
class TokenUpdateTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {string} [props.tokenName]
   * @param {string} [props.tokenSymbol]
   * @param {AccountId | string} [props.treasuryAccountId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.kycKey]
   * @param {Key} [props.freezeKey]
   * @param {Key} [props.wipeKey]
   * @param {Key} [props.supplyKey]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {Timestamp | Date} [props.expirationTime]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {string} [props.tokenMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?string}
     */

    this._tokenName = null;
    /**
     * @private
     * @type {?string}
     */

    this._tokenSymbol = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._treasuryAccountId = null;
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._kycKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._freezeKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._wipeKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._supplyKey = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._autoRenewAccountId = null;
    /**
     * @private
     * @type {?Timestamp}
     */

    this._expirationTime = null;
    /**
     * @private
     * @type {?Duration}
     */

    this._autoRenewPeriod = null;
    /**
     * @private
     * @type {?string}
     */

    this._tokenMemo = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.tokenName != null) {
      this.setTokenName(props.tokenName);
    }

    if (props.tokenSymbol != null) {
      this.setTokenSymbol(props.tokenSymbol);
    }

    if (props.treasuryAccountId != null) {
      this.setTreasuryAccountId(props.treasuryAccountId);
    }

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.kycKey != null) {
      this.setKycKey(props.kycKey);
    }

    if (props.freezeKey != null) {
      this.setFreezeKey(props.freezeKey);
    }

    if (props.wipeKey != null) {
      this.setWipeKey(props.wipeKey);
    }

    if (props.supplyKey != null) {
      this.setsupplyKey(props.supplyKey);
    }

    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }

    if (props.expirationTime != null) {
      this.setExpirationTime(props.expirationTime);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.tokenMemo != null) {
      this.setTokenMemo(props.tokenMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenUpdateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update =
    /** @type {proto.ITokenUpdateTransactionBody} */
    body.tokenUpdate;
    return _Transaction.default._fromProtobufTransactions(new TokenUpdateTransaction({
      tokenId: update.token != null ? _TokenId.default._fromProtobuf(update.token) : undefined,
      tokenName: update.name != null ? update.name : undefined,
      tokenSymbol: update.symbol != null ? update.symbol : undefined,
      treasuryAccountId: update.treasury != null ? _AccountId.default._fromProtobuf(update.treasury) : undefined,
      adminKey: update.adminKey != null ? (0, _protobuf.keyFromProtobuf)(update.adminKey) : undefined,
      kycKey: update.kycKey != null ? (0, _protobuf.keyFromProtobuf)(update.kycKey) : undefined,
      freezeKey: update.freezeKey != null ? (0, _protobuf.keyFromProtobuf)(update.freezeKey) : undefined,
      wipeKey: update.wipeKey != null ? (0, _protobuf.keyFromProtobuf)(update.wipeKey) : undefined,
      supplyKey: update.supplyKey != null ? (0, _protobuf.keyFromProtobuf)(update.supplyKey) : undefined,
      autoRenewAccountId: update.autoRenewAccount != null ? _AccountId.default._fromProtobuf(update.autoRenewAccount) : undefined,
      expirationTime: update.expiry != null ? _Timestamp.default._fromProtobuf(update.expiry) : undefined,
      autoRenewPeriod: update.autoRenewPeriod != null ? _Duration.default._fromProtobuf(update.autoRenewPeriod) : undefined,
      tokenMemo: update.memo != null ? update.memo.value != null ? update.memo.value : undefined : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?string}
   */


  get tokenName() {
    return this._tokenName;
  }
  /**
   * @param {string} name
   * @returns {this}
   */


  setTokenName(name) {
    this._requireNotFrozen();

    this._tokenName = name;
    return this;
  }
  /**
   * @returns {?string}
   */


  get tokenSymbol() {
    return this._tokenSymbol;
  }
  /**
   * @param {string} symbol
   * @returns {this}
   */


  setTokenSymbol(symbol) {
    this._requireNotFrozen();

    this._tokenSymbol = symbol;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */


  setTreasuryAccountId(id) {
    this._requireNotFrozen();

    this._treasuryAccountId = typeof id === "string" ? _AccountId.default.fromString(id) : id.clone();
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setAdminKey(key) {
    this._requireNotFrozen();

    this._adminKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get kycKey() {
    return this._kycKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setKycKey(key) {
    this._requireNotFrozen();

    this._kycKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get freezeKey() {
    return this._freezeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setFreezeKey(key) {
    this._requireNotFrozen();

    this._freezeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get wipeKey() {
    return this._wipeKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setWipeKey(key) {
    this._requireNotFrozen();

    this._wipeKey = key;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get supplyKey() {
    return this._supplyKey;
  }
  /**
   * @param {Key} key
   * @returns {this}
   */


  setsupplyKey(key) {
    this._requireNotFrozen();

    this._supplyKey = key;
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get expirationTime() {
    return this._expirationTime;
  }
  /**
   * @param {Timestamp | Date} time
   * @returns {this}
   */


  setExpirationTime(time) {
    this._requireNotFrozen();

    this._expirationTime = time instanceof _Timestamp.default ? time : _Timestamp.default.fromDate(time);
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} id
   * @returns {this}
   */


  setAutoRenewAccountId(id) {
    this._requireNotFrozen();

    this._autoRenewAccountId = id instanceof _AccountId.default ? id : _AccountId.default.fromString(id);
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this token.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @returns {?string}
   */


  get tokenMemo() {
    return this._tokenMemo;
  }
  /**
   * @param {string} tokenMemo
   * @returns {this}
   */


  setTokenMemo(tokenMemo) {
    this._requireNotFrozen();

    this._tokenMemo = tokenMemo;
    return this;
  }
  /**
   * @returns {this}
   */


  clearTokenMemo() {
    this._requireNotFrozen();

    this._tokenMemo = null;
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._treasuryAccountId != null) {
      this._treasuryAccountId.validate(client);
    }

    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.updateToken(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenUpdate";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenUpdateTransactionBody}
   */


  _makeTransactionData() {
    return {
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      name: this.tokenName,
      symbol: this.tokenSymbol,
      treasury: this._treasuryAccountId != null ? this._treasuryAccountId._toProtobuf() : null,
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      kycKey: this._kycKey != null ? (0, _protobuf.keyToProtobuf)(this._kycKey) : null,
      freezeKey: this._freezeKey != null ? (0, _protobuf.keyToProtobuf)(this._freezeKey) : null,
      wipeKey: this._wipeKey != null ? (0, _protobuf.keyToProtobuf)(this._wipeKey) : null,
      supplyKey: this._supplyKey != null ? (0, _protobuf.keyToProtobuf)(this._supplyKey) : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      expiry: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null,
      memo: this._tokenMemo != null ? {
        value: this._tokenMemo
      } : null
    };
  }

}

exports.default = TokenUpdateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenUpdate", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenUpdateTransaction._fromProtobuf);

/***/ }),

/***/ 5091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenWipeAccountTransactionBody} proto.ITokenWipeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Wipe a new Hedera crypto-currency token.
 */
class TokenWipeTransaction extends _Transaction.default {
  /**
   * @param {object} [props]
   * @param {TokenId | string} [props.tokenId]
   * @param {AccountId | string} [props.accountId]
   * @param {Long | number} [props.amount]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TokenId}
     */

    this._tokenId = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._accountId = null;
    /**
     * @private
     * @type {?Long}
     */

    this._amount = null;

    if (props.tokenId != null) {
      this.setTokenId(props.tokenId);
    }

    if (props.accountId != null) {
      this.setAccountId(props.accountId);
    }

    if (props.amount != null) {
      this.setAmount(props.amount);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TokenWipeTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const wipeToken =
    /** @type {proto.ITokenWipeAccountTransactionBody} */
    body.tokenWipe;
    return _Transaction.default._fromProtobufTransactions(new TokenWipeTransaction({
      tokenId: wipeToken.token != null ? _TokenId.default._fromProtobuf(wipeToken.token) : undefined,
      accountId: wipeToken.account != null ? _AccountId.default._fromProtobuf(wipeToken.account) : undefined,
      amount: wipeToken.amount != null ? wipeToken.amount : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TokenId}
   */


  get tokenId() {
    return this._tokenId;
  }
  /**
   * @param {TokenId | string} tokenId
   * @returns {this}
   */


  setTokenId(tokenId) {
    this._requireNotFrozen();

    this._tokenId = typeof tokenId === "string" ? _TokenId.default.fromString(tokenId) : tokenId.clone();
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get accountId() {
    return this._accountId;
  }
  /**
   * @param {AccountId | string} accountId
   * @returns {this}
   */


  setAccountId(accountId) {
    this._requireNotFrozen();

    this._accountId = typeof accountId === "string" ? _AccountId.default.fromString(accountId) : accountId.clone();
    return this;
  }
  /**
   * @returns {?Long}
   */


  get amount() {
    return this._amount;
  }
  /**
   * @param {Long | number} amount
   * @returns {this}
   */


  setAmount(amount) {
    this._requireNotFrozen();

    this._amount = amount instanceof _long.default ? amount : _long.default.fromValue(amount);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._tokenId != null) {
      this._tokenId.validate(client);
    }

    if (this._accountId != null) {
      this._accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.token.wipeTokenAccount(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "tokenWipe";
  }
  /**
   * @override
   * @protected
   * @returns {proto.ITokenWipeAccountTransactionBody}
   */


  _makeTransactionData() {
    return {
      amount: this._amount,
      token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
      account: this._accountId != null ? this._accountId._toProtobuf() : null
    };
  }

}

exports.default = TokenWipeTransaction;

_Transaction.TRANSACTION_REGISTRY.set("tokenWipe", // eslint-disable-next-line @typescript-eslint/unbound-method
TokenWipeTransaction._fromProtobuf);

/***/ }),

/***/ 6533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

class SubscriptionHandle {
  constructor() {
    /** @type {{(): void} | null} */
    this._call = null;
  }
  /**
   * @param {() => void} call
   * @returns {void}
   */


  _setCall(call) {
    this._call = call;
  }

  unsubscribe() {
    if (this._call != null) {
      this._call();
    }
  }

}

exports.default = SubscriptionHandle;

/***/ }),

/***/ 6144:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _protobuf = __nccwpck_require__(223);

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusCreateTopicTransactionBody} proto.IConsensusCreateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a topic to be used for consensus.
 */
class TopicCreateTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {Key} [props.adminKey]
   * @param {Key} [props.submitKey]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {string} [props.topicMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?Key}
     */

    this._adminKey = null;
    /**
     * @private
     * @type {?Key}
     */

    this._submitKey = null;
    /**
     * @private
     * @type {?AccountId}
     */

    this._autoRenewAccountId = null;
    /**
     * @private
     * @type {Duration}
     */

    this._autoRenewPeriod = new _Duration.default(_Transaction.DEFAULT_AUTO_RENEW_PERIOD);
    /**
     * @private
     * @type {?string}
     */

    this._topicMemo = null;

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }

    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }

    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }

    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TopicCreateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const create =
    /** @type {proto.IConsensusCreateTopicTransactionBody} */
    body.consensusCreateTopic;
    return _Transaction.default._fromProtobufTransactions(new TopicCreateTransaction({
      adminKey: create.adminKey != null ? (0, _protobuf.keyFromProtobuf)(create.adminKey) : undefined,
      submitKey: create.submitKey != null ? (0, _protobuf.keyFromProtobuf)(create.submitKey) : undefined,
      autoRenewAccountId: create.autoRenewAccount != null ? _AccountId.default._fromProtobuf(create.autoRenewAccount) : undefined,
      autoRenewPeriod: create.autoRenewPeriod != null ? create.autoRenewPeriod.seconds != null ? create.autoRenewPeriod.seconds : undefined : undefined,
      topicMemo: create.memo != null ? create.memo : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?string}
   */


  get topicMemo() {
    return this._topicMemo;
  }
  /**
   * @param {string} topicMemo
   * @returns {this}
   */


  setTopicMemo(topicMemo) {
    this._requireNotFrozen();

    this._topicMemo = topicMemo;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {this}
   */


  setAdminKey(adminKey) {
    this._requireNotFrozen();

    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get submitKey() {
    return this._submitKey;
  }
  /**
   * @param {Key} submitKey
   * @returns {this}
   */


  setSubmitKey(submitKey) {
    this._requireNotFrozen();

    this._submitKey = submitKey;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} autoRenewAccountId
   * @returns {this}
   */


  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();

    this._autoRenewAccountId = autoRenewAccountId instanceof _AccountId.default ? autoRenewAccountId : _AccountId.default.fromString(autoRenewAccountId);
    return this;
  }
  /**
   * @returns {Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {this}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.consensus.createTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "consensusCreateTopic";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IConsensusCreateTopicTransactionBody}
   */


  _makeTransactionData() {
    return {
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      submitKey: this._submitKey != null ? (0, _protobuf.keyToProtobuf)(this._submitKey) : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
      memo: this._topicMemo
    };
  }

}

exports.default = TopicCreateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("consensusCreateTopic", // eslint-disable-next-line @typescript-eslint/unbound-method
TopicCreateTransaction._fromProtobuf);

/***/ }),

/***/ 4595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusDeleteTopicTransactionBody} proto.IConsensusDeleteTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a topic.
 *
 * No more transactions or queries on the topic will succeed.
 *
 * If an adminKey is set, this transaction must be signed by that key.
 * If there is no adminKey, this transaction will fail with Status#Unautorized.
 */
class TopicDeleteTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TopicId}
     */

    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TopicDeleteTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const topicDelete =
    /** @type {proto.IConsensusDeleteTopicTransactionBody} */
    body.consensusDeleteTopic;
    return _Transaction.default._fromProtobufTransactions(new TopicDeleteTransaction({
      topicId: topicDelete.topicID != null ? _TopicId.default._fromProtobuf(topicDelete.topicID) : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * Set the topic ID which is being deleted in this transaction.
   *
   * @param {TopicId | string} topicId
   * @returns {TopicDeleteTransaction}
   */


  setTopicId(topicId) {
    this._requireNotFrozen();

    this._topicId = typeof topicId === "string" ? _TopicId.default.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._topicId != null) {
      this._topicId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.consensus.deleteTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "consensusDeleteTopic";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IConsensusDeleteTopicTransactionBody}
   */


  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null
    };
  }

}

exports.default = TopicDeleteTransaction;

_Transaction.TRANSACTION_REGISTRY.set("consensusDeleteTopic", // eslint-disable-next-line @typescript-eslint/unbound-method
TopicDeleteTransaction._fromProtobuf);

/***/ }),

/***/ 3545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var entity_id = _interopRequireWildcard(__nccwpck_require__(7237));

var _proto = __nccwpck_require__(973);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITopicID} proto.ITopicID
 */

/**
 * Unique identifier for a topic (used by the consensus service).
 */
class TopicId {
  /**
   * @param {number | Long | import("../EntityIdHelper").IEntityId} props
   * @param {(number | Long)=} realm
   * @param {(number | Long)=} num
   */
  constructor(props, realm, num) {
    const result = entity_id.constructor(props, realm, num);
    this.shard = result.shard;
    this.realm = result.realm;
    this.num = result.num;
    /**
     * @type {string | null}
     */

    this._checksum = null;
  }
  /**
   * @param {string} text
   * @returns {TopicId}
   */


  static fromString(text) {
    const result = entity_id.fromString(text);
    const id = new TopicId(result);
    id._checksum = result.checksum;
    return id;
  }
  /**
   * @internal
   * @param {proto.ITopicID} id
   * @param {(string | null)=} ledgerId
   * @returns {TopicId}
   */


  static _fromProtobuf(id, ledgerId) {
    const topicId = new TopicId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.topicNum != null ? id.topicNum : 0);

    if (ledgerId != null) {
      topicId._setNetwork(ledgerId);
    }

    return topicId;
  }
  /**
   * @internal
   * @param {Client} client
   */


  _setNetworkWith(client) {
    if (client._network._ledgerId != null) {
      this._setNetwork(client._network._ledgerId);
    }
  }
  /**
   * @internal
   * @param {string} ledgerId
   */


  _setNetwork(ledgerId) {
    this._checksum = entity_id._checksum(ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`);
  }
  /**
   * @param {Client} client
   */


  validate(client) {
    if (client._network._ledgerId != null && this._checksum != null && this._checksum != entity_id._checksum(client._network._ledgerId, `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`)) {
      throw new Error("Entity ID is for a different network than client");
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TopicId}
   */


  static fromBytes(bytes) {
    return TopicId._fromProtobuf(_proto.TopicID.decode(bytes));
  }
  /**
   * @override
   * @returns {proto.ITopicID}
   */


  _toProtobuf() {
    return {
      topicNum: this.num,
      shardNum: this.shard,
      realmNum: this.realm
    };
  }
  /**
   * @override
   * @returns {string}
   */


  toString() {
    if (this._checksum == null) {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    } else {
      return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}-${this._checksum}`;
    }
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return _proto.TopicID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {TopicId}
   */


  clone() {
    const id = new TopicId(this);
    id._checksum = this._checksum;
    return id;
  }

}

exports.default = TopicId;

/***/ }),

/***/ 1615:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _protobuf = __nccwpck_require__(223);

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 */

/**
 * Current state of a topic.
 */
class TopicInfo {
  /**
   * @private
   * @param {object} props
   * @param {TopicId} props.topicId
   * @param {string} props.topicMemo
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   * @param {?Timestamp} props.expirationTime
   * @param {?Key} props.adminKey
   * @param {?Key} props.submitKey
   * @param {?Duration} props.autoRenewPeriod
   * @param {?AccountId} props.autoRenewAccountId
   */
  constructor(props) {
    /**
     * The ID of the topic for which information is requested.
     *
     * @readonly
     */
    this.topicId = props.topicId;
    /**
     * Short publicly visible memo about the topic. No guarantee of uniqueness.
     *
     * @readonly
     */

    this.topicMemo = props.topicMemo;
    /**
     * SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
     *
     * @readonly
     */

    this.runningHash = props.runningHash;
    /**
     * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
     *
     * @readonly
     */

    this.sequenceNumber = props.sequenceNumber;
    /**
     * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
     *
     * @readonly
     */

    this.expirationTime = props.expirationTime;
    /**
     * Access control for update/delete of the topic. Null if there is no key.
     *
     * @readonly
     */

    this.adminKey = props.adminKey;
    /**
     * Access control for ConsensusService.submitMessage. Null if there is no key.
     *
     * @readonly
     */

    this.submitKey = props.submitKey;
    /**
     * @readonly
     */

    this.autoRenewPeriod = props.autoRenewPeriod;
    /**
     * @readonly
     */

    this.autoRenewAccountId = props.autoRenewAccountId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IConsensusGetTopicInfoResponse} infoResponse
   * @param {(string | null)=} ledgerId
   * @returns {TopicInfo}
   */


  static _fromProtobuf(infoResponse, ledgerId) {
    const info =
    /** @type {proto.IConsensusTopicInfo} */
    infoResponse.topicInfo;
    return new TopicInfo({
      topicId: _TopicId.default._fromProtobuf(
      /** @type {proto.ITopicID} */
      infoResponse.topicID, ledgerId),
      topicMemo: info.memo != null ? info.memo : "",
      runningHash: info.runningHash != null ? info.runningHash : new Uint8Array(),
      sequenceNumber: info.sequenceNumber != null ? info.sequenceNumber instanceof _long.default ? info.sequenceNumber : _long.default.fromValue(info.sequenceNumber) : _long.default.ZERO,
      expirationTime: info.expirationTime != null ? _Timestamp.default._fromProtobuf(info.expirationTime) : null,
      adminKey: info.adminKey != null ? (0, _protobuf.keyFromProtobuf)(info.adminKey, ledgerId) : null,
      submitKey: info.submitKey != null ? (0, _protobuf.keyFromProtobuf)(info.submitKey, ledgerId) : null,
      autoRenewPeriod: info.autoRenewPeriod != null ? new _Duration.default(
      /** @type {Long} */
      info.autoRenewPeriod.seconds) : null,
      autoRenewAccountId: info.autoRenewAccount != null ? _AccountId.default._fromProtobuf(info.autoRenewAccount, ledgerId) : null
    });
  }
  /**
   * @internal
   * @returns {proto.IConsensusGetTopicInfoResponse}
   */


  _toProtobuf() {
    return {
      topicID: this.topicId._toProtobuf(),
      topicInfo: {
        memo: this.topicMemo,
        runningHash: this.runningHash,
        sequenceNumber: this.sequenceNumber,
        expirationTime: this.expirationTime != null ? this.expirationTime._toProtobuf() : null,
        adminKey: this.adminKey != null ? (0, _protobuf.keyToProtobuf)(this.adminKey) : null,
        submitKey: this.submitKey != null ? (0, _protobuf.keyToProtobuf)(this.submitKey) : null,
        autoRenewPeriod: this.autoRenewPeriod != null ? this.autoRenewPeriod._toProtobuf() : null,
        autoRenewAccount: this.autoRenewAccountId != null ? this.autoRenewAccountId._toProtobuf() : null
      }
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TopicInfo}
   */


  static fromBytes(bytes) {
    return TopicInfo._fromProtobuf({
      topicInfo: proto.ConsensusTopicInfo.decode(bytes)
    });
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.ConsensusTopicInfo.encode(
    /** @type {proto.IConsensusTopicInfo} */
    this._toProtobuf().topicInfo).finish();
  }

}

exports.default = TopicInfo;

/***/ }),

/***/ 1066:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _TopicInfo = _interopRequireDefault(__nccwpck_require__(1615));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IConsensusTopicQuery} proto.IConsensusTopicQuery
 * @typedef {import("@hashgraph/proto").IConsensusGetTopicInfoResponse} proto.IConsensusGetTopicInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Retrieve the latest state of a topic.
 *
 * @augments {Query<TopicInfo>}
 */
class TopicInfoQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {TopicId | string} [props.topicId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TopicId}
     */

    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {TopicInfoQuery}
   */


  static _fromProtobuf(query) {
    const info =
    /** @type {proto.IConsensusTopicQuery} */
    query.consensusGetTopicInfo;
    return new TopicInfoQuery({
      topicId: info.topicID != null ? _TopicId.default._fromProtobuf(info.topicID) : undefined
    });
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * Set the topic ID for which the info is being requested.
   *
   * @param {TopicId | string} topicId
   * @returns {TopicInfoQuery}
   */


  setTopicId(topicId) {
    this._topicId = typeof topicId === "string" ? _TopicId.default.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @override
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<Hbar>}
   */


  async getCost(client) {
    let cost = await super.getCost(client);

    if (cost.toTinybars().greaterThan(25)) {
      return cost;
    } else {
      return _Hbar.default.fromTinybars(25);
    }
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._topicId != null) {
      this._topicId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.consensus.getTopicInfo(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const consensusGetTopicInfo =
    /** @type {proto.IConsensusGetTopicInfoResponse} */
    response.consensusGetTopicInfo;
    return (
      /** @type {proto.IResponseHeader} */
      consensusGetTopicInfo.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<TopicInfo>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    return Promise.resolve(_TopicInfo.default._fromProtobuf(
    /** @type {proto.IConsensusGetTopicInfoResponse} */
    response.consensusGetTopicInfo, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      consensusGetTopicInfo: {
        header,
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null
      }
    };
  }

} // eslint-disable-next-line @typescript-eslint/unbound-method


exports.default = TopicInfoQuery;

_Query.QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);

/***/ }),

/***/ 5334:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _TopicMessageChunk = _interopRequireDefault(__nccwpck_require__(4042));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusTopicResponse} proto.IConsensusTopicResponse
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 */
class TopicMessage {
  /**
   * @private
   * @param {object} props
   * @param {Timestamp} props.consensusTimestamp
   * @param {Uint8Array} props.contents
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   * @param {TopicMessageChunk[]} props.chunks
   */
  constructor(props) {
    /** @readonly */
    this.consensusTimestamp = props.consensusTimestamp;
    /** @readonly */

    this.contents = props.contents;
    /** @readonly */

    this.runningHash = props.runningHash;
    /** @readonly */

    this.sequenceNumber = props.sequenceNumber;
    /** @readonly */

    this.chunks = props.chunks;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IConsensusTopicResponse} response
   * @returns {TopicMessage}
   */


  static _ofSingle(response) {
    return new TopicMessage({
      consensusTimestamp: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      response.consensusTimestamp),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof _long.default ? response.sequenceNumber : _long.default.fromNumber(response.sequenceNumber) : _long.default.ZERO,
      chunks: [_TopicMessageChunk.default._fromProtobuf(response)]
    });
  }
  /**
   * @internal
   * @param {proto.IConsensusTopicResponse[]} responses
   * @returns {TopicMessage}
   */


  static _ofMany(responses) {
    const length = responses.length;
    const last =
    /** @type {proto.IConsensusTopicResponse} */
    responses[length - 1];

    const consensusTimestamp = _Timestamp.default._fromProtobuf(
    /** @type {proto.ITimestamp} */
    last.consensusTimestamp);

    const runningHash =
    /** @type {Uint8Array} */
    last.runningHash;
    /**
     * @type {Long}
     */

    const sequenceNumber = last.sequenceNumber != null ? last.sequenceNumber instanceof _long.default ? last.sequenceNumber : _long.default.fromValue(last.sequenceNumber) : _long.default.ZERO;
    responses.sort((a, b) => (a != null ? a.chunkInfo != null ? a.chunkInfo.number != null ? a.chunkInfo.number : 0 : 0 : 0) < (b != null ? b.chunkInfo != null ? b.chunkInfo.number != null ? b.chunkInfo.number : 0 : 0 : 0) ? -1 : 1);
    /**
     * @type {TopicMessageChunk[]}
     */

    const chunks = responses.map(
    /**
     * @type {proto.IConsensusTopicResponse}
     */
    m => _TopicMessageChunk.default._fromProtobuf(m));
    const size = chunks.map(chunk => chunk.contents.length).reduce((sum, current) => sum + current, 0);
    const contents = new Uint8Array(size);
    let offset = 0;
    responses.forEach(value => {
      contents.set(
      /** @type {Uint8Array} */
      value.message, offset);
      offset +=
      /** @type {Uint8Array} */
      value.message.length;
    });
    return new TopicMessage({
      consensusTimestamp,
      contents,
      runningHash,
      sequenceNumber,
      chunks
    });
  }

}

exports.default = TopicMessage;

/***/ }),

/***/ 4042:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusTopicResponse} proto.IConsensusTopicResponse
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 */
class TopicMessageChunk {
  /**
   * @private
   * @param {object} props
   * @param {Timestamp} props.consensusTimestamp
   * @param {Uint8Array} props.contents
   * @param {Uint8Array} props.runningHash
   * @param {Long} props.sequenceNumber
   */
  constructor(props) {
    /** @readonly */
    this.consensusTimestamp = props.consensusTimestamp;
    /** @readonly */

    this.contents = props.contents;
    /** @readonly */

    this.runningHash = props.runningHash;
    /** @readonly */

    this.sequenceNumber = props.sequenceNumber;
    Object.freeze(this);
  }
  /**
   * @internal
   * @param {proto.IConsensusTopicResponse} response
   * @returns {TopicMessageChunk}
   */


  static _fromProtobuf(response) {
    return new TopicMessageChunk({
      consensusTimestamp: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      response.consensusTimestamp),
      contents: response.message != null ? response.message : new Uint8Array(),
      runningHash: response.runningHash != null ? response.runningHash : new Uint8Array(),
      sequenceNumber: response.sequenceNumber != null ? response.sequenceNumber instanceof _long.default ? response.sequenceNumber : _long.default.fromValue(response.sequenceNumber) : _long.default.ZERO
    });
  }
  /**
   * @internal
   * @returns {proto.IConsensusTopicResponse}
   */


  _toProtobuf() {
    return {
      consensusTimestamp: this.consensusTimestamp._toProtobuf(),
      message: this.contents,
      runningHash: this.runningHash,
      sequenceNumber: this.sequenceNumber
    };
  }

}

exports.default = TopicMessageChunk;

/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _SubscriptionHandle = _interopRequireDefault(__nccwpck_require__(6533));

var _TopicMessage = _interopRequireDefault(__nccwpck_require__(5334));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _long = _interopRequireDefault(__nccwpck_require__(492));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Executable = __nccwpck_require__(1128);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../channel/MirrorChannel.js").MirrorError} MirrorError
 */

/**
 * @template {Channel} ChannelT
 * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
 */
class TopicMessageQuery {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Timestamp} [props.startTime]
   * @param {Timestamp} [props.endTime]
   * @param {(message: TopicMessage, error: Error)=> void} [props.errorHandler]
   * @param {() => void} [props.completionHandler]
   * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]
   * @param {Long | number} [props.limit]
   */
  constructor(props = {}) {
    /**
     * @private
     * @type {?TopicId}
     */
    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    /**
     * @private
     * @type {?Timestamp}
     */


    this._startTime = null;

    if (props.startTime != null) {
      this.setStartTime(props.startTime);
    }
    /**
     * @private
     * @type {?Timestamp}
     */


    this._endTime = null;

    if (props.endTime != null) {
      this.setEndTime(props.endTime);
    }
    /**
     * @private
     * @type {?Long}
     */


    this._limit = null;

    if (props.limit != null) {
      this.setLimit(props.limit);
    }
    /**
     * @private
     * @type {(message: TopicMessage, error: Error) => void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars


    this._errorHandler = (message, error) => {
      console.error(`Error attempting to subscribe to topic: ${this._topicId != null ? this._topicId.toString() : ""}`);
    };

    if (props.errorHandler != null) {
      this._errorHandler = props.errorHandler;
    }
    /*
     * @private
     * @type {((message: TopicMessage) => void) | null}
     */


    this._listener = null;
    /**
     * @private
     * @type {() => void}
     */

    this._completionHandler = () => {
      console.log(`Subscription to topic ${this._topicId != null ? this._topicId.toString() : ""} complete`);
    };

    if (props.completionHandler != null) {
      this._completionHandler = props.completionHandler;
    }
    /**
     * @private
     * @type {(error: MirrorError | Error | null) => boolean}
     */


    this._retryHandler = error => {
      if (error != null) {
        if (error instanceof Error) {
          // Retry on all errors which are not `MirrorError` because they're
          // likely lower level HTTP/2 errors
          return true;
        } else {
          // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`
          // if the messasge matches the right regex.
          switch (error.code) {
            // INTERNAL
            // eslint-disable-next-line no-fallthrough
            case 13:
              return _Executable.RST_STREAM.test(error.details.toString());
            // NOT_FOUND
            // eslint-disable-next-line no-fallthrough

            case 5: // RESOURCE_EXHAUSTED
            // eslint-disable-next-line no-fallthrough

            case 8: // UNAVAILABLE
            // eslint-disable-next-line no-fallthrough

            case 14:
              return true;

            default:
              return false;
          }
        }
      }

      return false;
    };

    if (props.retryHandler != null) {
      this._retryHandler = props.retryHandler;
    }
    /**
     * @private
     * @type {number}
     */


    this._maxAttempts = 10;
    /**
     * @private
     * @type {number}
     */

    this._maxBackoff = 8000;
    /**
     * @private
     * @type {number}
     */

    this._attempt = 0;
    /**
     * @private
     * @type {SubscriptionHandle | null}
     */

    this._handle = null;
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {TopicMessageQuery}
   */


  setTopicId(topicId) {
    this.requireNotSubscribed();
    this._topicId = typeof topicId === "string" ? _TopicId.default.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get startTime() {
    return this._startTime;
  }
  /**
   * @param {Timestamp | Date | number} startTime
   * @returns {TopicMessageQuery}
   */


  setStartTime(startTime) {
    this.requireNotSubscribed();
    this._startTime = startTime instanceof _Timestamp.default ? startTime : startTime instanceof Date ? _Timestamp.default.fromDate(startTime) : new _Timestamp.default(startTime, 0);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get endTime() {
    return this._endTime;
  }
  /**
   * @param {Timestamp | Date | number} endTime
   * @returns {TopicMessageQuery}
   */


  setEndTime(endTime) {
    this.requireNotSubscribed();
    this._endTime = endTime instanceof _Timestamp.default ? endTime : endTime instanceof Date ? _Timestamp.default.fromDate(endTime) : new _Timestamp.default(endTime, 0);
    return this;
  }
  /**
   * @returns {?Long}
   */


  get limit() {
    return this._limit;
  }
  /**
   * @param {Long | number} limit
   * @returns {TopicMessageQuery}
   */


  setLimit(limit) {
    this.requireNotSubscribed();
    this._limit = limit instanceof _long.default ? limit : _long.default.fromValue(limit);
    return this;
  }
  /**
   * @param {(message: TopicMessage, error: Error)=> void} errorHandler
   * @returns {TopicMessageQuery}
   */


  setErrorHandler(errorHandler) {
    this._errorHandler = errorHandler;
    return this;
  }
  /**
   * @param {() => void} completionHandler
   * @returns {TopicMessageQuery}
   */


  setCompletionHandler(completionHandler) {
    this.requireNotSubscribed();
    this._completionHandler = completionHandler;
    return this;
  }
  /**
   * @param {number} attempts
   */


  setMaxAttempts(attempts) {
    this.requireNotSubscribed();
    this._maxAttempts = attempts;
  }
  /**
   * @param {number} backoff
   */


  setMaxBackoff(backoff) {
    this.requireNotSubscribed();
    this._maxBackoff = backoff;
  }
  /**
   * @param {Client<*>} client
   * @param {((message: TopicMessage, error: Error) => void) | null} errorHandler
   * @param {(message: TopicMessage) => void} listener
   * @returns {SubscriptionHandle}
   */


  subscribe(client, errorHandler, listener) {
    this._handle = new _SubscriptionHandle.default();
    this._listener = listener;

    if (errorHandler != null) {
      this._errorHandler = errorHandler;
    }

    this._makeServerStreamRequest(client);

    return this._handle;
  }
  /**
   * @private
   * @param {import("../client/Client.js").default<Channel, MirrorChannel>} client
   * @returns {void}
   */


  _makeServerStreamRequest(client) {
    /** @type {Map<string, proto.ConsensusTopicResponse[]>} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const list = new Map();
    const request = proto.ConsensusTopicQuery.encode({
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      consensusStartTime: this._startTime != null ? this._startTime._toProtobuf() : null,
      consensusEndTime: this._endTime != null ? this._endTime._toProtobuf() : null,
      limit: this._limit
    }).finish();

    const cancel = client._mirrorNetwork.getNextMirrorNode().channel.makeServerStreamRequest(request, data => {
      const message = proto.ConsensusTopicResponse.decode(data);

      if (this._limit != null && this._limit.gt(0)) {
        this._limit = this._limit.sub(1);
      }

      this._startTime = _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      message.consensusTimestamp).plusNanos(1);

      if (message.chunkInfo == null || message.chunkInfo != null && message.chunkInfo.total === 1) {
        this._passTopicMessage(_TopicMessage.default._ofSingle(message));
      } else {
        const chunkInfo =
        /** @type {proto.IConsensusMessageChunkInfo} */
        message.chunkInfo;
        const initialTransactionID =
        /** @type {proto.ITransactionID} */
        chunkInfo.initialTransactionID;
        const total =
        /** @type {number} */
        chunkInfo.total;

        const transactionId = _TransactionId.default._fromProtobuf(initialTransactionID).toString();
        /** @type {proto.ConsensusTopicResponse[]} */


        let responses = [];
        const temp = list.get(transactionId);

        if (temp == null) {
          list.set(transactionId, responses);
        } else {
          responses = temp;
        }

        responses.push(message);

        if (responses.length === total) {
          const topicMessage = _TopicMessage.default._ofMany(responses);

          list.delete(transactionId);

          this._passTopicMessage(topicMessage);
        }
      }
    }, error => {
      const message = error instanceof Error ? error.message : error.details;

      if (this._attempt < this._maxAttempts && this._retryHandler(error)) {
        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);
        console.warn(`Error subscribing to topic ${this._topicId != null ? this._topicId.toString() : "UNKNOWN"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`);
        this._attempt += 1;
        setTimeout(() => {
          this._makeServerStreamRequest(client);
        }, delay);
      }
    }, this._completionHandler);

    if (this._handle != null) {
      this._handle._setCall(() => cancel());
    }
  }

  requireNotSubscribed() {
    if (this._handle != null) {
      throw new Error("Cannot change fields on an already subscribed query");
    }
  }
  /**
   * @private
   * @param {TopicMessage} topicMessage
   */


  _passTopicMessage(topicMessage) {
    try {
      if (this._listener != null) {
        this._listener(topicMessage);
      } else {
        throw new Error("(BUG) listener is unexpectedly not set");
      }
    } catch (error) {
      this._errorHandler(topicMessage, error);
    }
  }

}

exports.default = TopicMessageQuery;

/***/ }),

/***/ 6929:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var utf8 = _interopRequireWildcard(__nccwpck_require__(3251));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusSubmitMessageTransactionBody} proto.IConsensusSubmitMessageTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IConsensusMessageChunkInfo} proto.IConsensusMessageChunkInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 */
class TopicMessageSubmitTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Uint8Array | string} [props.message]
   * @param {number} [props.maxChunks]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TopicId}
     */

    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    /**
     * @private
     * @type {?Uint8Array}
     */


    this._message = null;

    if (props.message != null) {
      this.setMessage(props.message);
    }
    /**
     * @private
     * @type {number}
     */


    this._maxChunks = 20;

    if (props.maxChunks != null) {
      this.setMaxChunks(props.maxChunks);
    }
    /** @type {proto.IConsensusMessageChunkInfo | null} */


    this._chunkInfo = null;
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TopicMessageSubmitTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const message =
    /** @type {proto.IConsensusSubmitMessageTransactionBody} */
    body.consensusSubmitMessage;
    return _Transaction.default._fromProtobufTransactions(new TopicMessageSubmitTransaction({
      topicId: message.topicID != null ? _TopicId.default._fromProtobuf(message.topicID) : undefined,
      message: message.message != null ? message.message : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @param {TransactionId} transactionId
   * @returns {this}
   */


  setTransactionId(transactionId) {
    this._requireNotFrozen();

    if (transactionId.accountId == null || transactionId.validStart == null) {
      throw new Error("`TopicMessageSubmitTransaction` does not support `TransactionId` built from `nonce`");
    }

    this._transactionIds = [transactionId];
    return this;
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {this}
   */


  setTopicId(topicId) {
    this._requireNotFrozen();

    this._topicId = typeof topicId === "string" ? _TopicId.default.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @returns {?Uint8Array}
   */


  get message() {
    return this._message;
  }
  /**
   * @param {string | Uint8Array} message
   * @returns {this}
   */


  setMessage(message) {
    this._requireNotFrozen();

    this._message = typeof message === "string" ? utf8.encode(message) : message;
    return this;
  }
  /**
   * @returns {?number}
   */


  get maxChunks() {
    return this._maxChunks;
  }
  /**
   * @param {number} maxChunks
   * @returns {this}
   */


  setMaxChunks(maxChunks) {
    this._requireNotFrozen();

    this._maxChunks = maxChunks;
    return this;
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */


  freezeWith(client) {
    super.freezeWith(client);

    if (this._message == null) {
      return this;
    }

    const chunks = Math.floor((this._message.length + (_Transaction.CHUNK_SIZE - 1)) / _Transaction.CHUNK_SIZE);

    if (chunks > this._maxChunks) {
      throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);
    }

    const initialTransactionId = this.transactionId._toProtobuf();

    let nextTransactionId = this.transactionId;
    super._transactions = [];
    super._transactionIds = [];
    super._signedTransactions = [];
    super._nextTransactionIndex = 0;

    for (let chunk = 0; chunk < chunks; chunk++) {
      this._chunkInfo = {
        initialTransactionID: initialTransactionId,
        total: chunks,
        number: chunk + 1
      };

      this._transactionIds.push(nextTransactionId);

      for (const nodeAccountId of this._nodeIds) {
        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));
      }

      nextTransactionId = new _TransactionId.default(
      /** @type {AccountId} */
      nextTransactionId.accountId, new _Timestamp.default(
      /** @type {Timestamp} */
      nextTransactionId.validStart.seconds,
      /** @type {Timestamp} */
      nextTransactionId.validStart.nanos.add(1)));
      super._nextTransactionIndex = this._nextTransactionIndex + 1;
    }

    this._chunkInfo = null;
    super._nextTransactionIndex = 0;
    return this;
  }
  /**
   * @returns {ScheduleCreateTransaction}
   */


  schedule() {
    this._requireNotFrozen();

    if (this._message != null && this._message.length > _Transaction.CHUNK_SIZE) {
      throw new Error(`cannot scheduled \`TopicMessageSubmitTransaction\` with message over ${_Transaction.CHUNK_SIZE} bytes`);
    }

    return super.schedule();
  }
  /**
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<TransactionResponse>}
   */


  async execute(client) {
    return (await this.executeAll(client))[0];
  }
  /**
   * @param {import("../client/Client.js").default<*, *>} client
   * @returns {Promise<TransactionResponse[]>}
   */


  async executeAll(client) {
    if (!super._isFrozen()) {
      this.freezeWith(client);
    } // on execute, sign each transaction with the operator, if present
    // and we are signing a transaction that used the default transaction ID


    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;

    if (operatorAccountId != null && operatorAccountId.equals(
    /** @type {AccountId} */
    transactionId.accountId)) {
      await super.signWithOperator(client);
    }

    const responses = [];

    for (let i = 0; i < this._transactionIds.length; i++) {
      responses.push(await super.execute(client));
    }

    return responses;
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.consensus.submitMessage(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "consensusSubmitMessage";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IConsensusSubmitMessageTransactionBody}
   */


  _makeTransactionData() {
    if (this._chunkInfo != null && this._message != null) {
      const num =
      /** @type {number} */
      this._chunkInfo.number;
      const startIndex = (num - 1) * _Transaction.CHUNK_SIZE;
      let endIndex = startIndex + _Transaction.CHUNK_SIZE;

      if (endIndex > this._message.length) {
        endIndex = this._message.length;
      }

      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message.slice(startIndex, endIndex),
        chunkInfo: this._chunkInfo
      };
    } else {
      return {
        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        message: this._message
      };
    }
  }

}

exports.default = TopicMessageSubmitTransaction;

_Transaction.TRANSACTION_REGISTRY.set("consensusSubmitMessage", // eslint-disable-next-line @typescript-eslint/unbound-method
TopicMessageSubmitTransaction._fromProtobuf);

/***/ }),

/***/ 5211:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Transaction = _interopRequireWildcard(__nccwpck_require__(3972));

var _protobuf = __nccwpck_require__(223);

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _Duration = _interopRequireDefault(__nccwpck_require__(7479));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusUpdateTopicTransactionBody} proto.IConsensusUpdateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a topic.
 *
 * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
 * Otherwise transaction must be signed by the adminKey.
 *
 * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
 *
 * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
 */
class TopicUpdateTransaction extends _Transaction.default {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Key} [props.adminKey]
   * @param {Key} [props.submitKey]
   * @param {Duration | Long | number} [props.autoRenewPeriod]
   * @param {AccountId | string} [props.autoRenewAccountId]
   * @param {string} [props.topicMemo]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TopicId}
     */

    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    /**
     * @private
     * @type {?string}
     */


    this._topicMemo = null;

    if (props.topicMemo != null) {
      this.setTopicMemo(props.topicMemo);
    }
    /**
     * @private
     * @type {?Key}
     */


    this._submitKey = null;

    if (props.submitKey != null) {
      this.setSubmitKey(props.submitKey);
    }
    /**
     * @private
     * @type {?Key}
     */


    this._adminKey = null;

    if (props.adminKey != null) {
      this.setAdminKey(props.adminKey);
    }
    /**
     * @private
     * @type {?AccountId}
     */


    this._autoRenewAccountId = null;

    if (props.autoRenewAccountId != null) {
      this.setAutoRenewAccountId(props.autoRenewAccountId);
    }
    /**
     * @private
     * @type {?Duration}
     */


    this._autoRenewPeriod = null;

    if (props.autoRenewPeriod != null) {
      this.setAutoRenewPeriod(props.autoRenewPeriod);
    }
  }
  /**
   * @internal
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TopicUpdateTransaction}
   */


  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const update =
    /** @type {proto.IConsensusUpdateTopicTransactionBody} */
    body.consensusUpdateTopic;
    return _Transaction.default._fromProtobufTransactions(new TopicUpdateTransaction({
      topicId: update.topicID != null ? _TopicId.default._fromProtobuf(update.topicID) : undefined,
      adminKey: update.adminKey != null ? (0, _protobuf.keyFromProtobuf)(update.adminKey) : undefined,
      submitKey: update.submitKey != null ? (0, _protobuf.keyFromProtobuf)(update.submitKey) : undefined,
      autoRenewAccountId: update.autoRenewAccount != null ? _AccountId.default._fromProtobuf(update.autoRenewAccount) : undefined,
      autoRenewPeriod: update.autoRenewPeriod != null ? update.autoRenewPeriod.seconds != null ? update.autoRenewPeriod.seconds : undefined : undefined,
      topicMemo: update.memo != null ? update.memo.value != null ? update.memo.value : undefined : undefined
    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {TopicUpdateTransaction}
   */


  setTopicId(topicId) {
    this._requireNotFrozen();

    this._topicId = typeof topicId === "string" ? _TopicId.default.fromString(topicId) : topicId.clone();
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */


  clearTopicId() {
    this._requireNotFrozen();

    this._topicId = null;
    return this;
  }
  /**
   * @returns {?string}
   */


  get topicMemo() {
    return this._topicMemo;
  }
  /**
   * @param {string} topicMemo
   * @returns {TopicUpdateTransaction}
   */


  setTopicMemo(topicMemo) {
    this._requireNotFrozen();

    this._topicMemo = topicMemo;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */


  clearTopicMemo() {
    this._requireNotFrozen();

    this._topicMemo = null;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get adminKey() {
    return this._adminKey;
  }
  /**
   * @param {Key} adminKey
   * @returns {TopicUpdateTransaction}
   */


  setAdminKey(adminKey) {
    this._requireNotFrozen();

    this._adminKey = adminKey;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */


  clearAdminKey() {
    this._requireNotFrozen();

    this._adminKey = null;
    return this;
  }
  /**
   * @returns {?Key}
   */


  get submitKey() {
    return this._submitKey;
  }
  /**
   * @param {Key} submitKey
   * @returns {TopicUpdateTransaction}
   */


  setSubmitKey(submitKey) {
    this._requireNotFrozen();

    this._submitKey = submitKey;
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */


  clearSubmitKey() {
    this._requireNotFrozen();

    this._submitKey = null;
    return this;
  }
  /**
   * @returns {?AccountId}
   */


  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  /**
   * @param {AccountId | string} autoRenewAccountId
   * @returns {TopicUpdateTransaction}
   */


  setAutoRenewAccountId(autoRenewAccountId) {
    this._requireNotFrozen();

    this._autoRenewAccountId = autoRenewAccountId instanceof _AccountId.default ? autoRenewAccountId : _AccountId.default.fromString(autoRenewAccountId);
    return this;
  }
  /**
   * @returns {TopicUpdateTransaction}
   */


  clearAutoRenewAccountId() {
    this._requireNotFrozen();

    this._autoRenewAccountId = null;
    return this;
  }
  /**
   * @returns {?Duration}
   */


  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  /**
   * Set the auto renew period for this account.
   *
   * @param {Duration | Long | number} autoRenewPeriod
   * @returns {TopicUpdateTransaction}
   */


  setAutoRenewPeriod(autoRenewPeriod) {
    this._requireNotFrozen();

    this._autoRenewPeriod = autoRenewPeriod instanceof _Duration.default ? autoRenewPeriod : new _Duration.default(autoRenewPeriod);
    return this;
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._topicId != null) {
      this._topicId.validate(client);
    }

    if (this._autoRenewAccountId != null) {
      this._autoRenewAccountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.ITransaction} request
   * @returns {Promise<proto.ITransactionResponse>}
   */


  _execute(channel, request) {
    return channel.consensus.updateTopic(request);
  }
  /**
   * @override
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    return "consensusUpdateTopic";
  }
  /**
   * @override
   * @protected
   * @returns {proto.IConsensusUpdateTopicTransactionBody}
   */


  _makeTransactionData() {
    return {
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      adminKey: this._adminKey != null ? (0, _protobuf.keyToProtobuf)(this._adminKey) : null,
      submitKey: this._submitKey != null ? (0, _protobuf.keyToProtobuf)(this._submitKey) : null,
      memo: this._topicMemo != null ? {
        value: this._topicMemo
      } : null,
      autoRenewAccount: this._autoRenewAccountId != null ? this._autoRenewAccountId._toProtobuf() : null,
      autoRenewPeriod: this._autoRenewPeriod != null ? this._autoRenewPeriod._toProtobuf() : null
    };
  }

}

exports.default = TopicUpdateTransaction;

_Transaction.TRANSACTION_REGISTRY.set("consensusUpdateTopic", // eslint-disable-next-line @typescript-eslint/unbound-method
TopicUpdateTransaction._fromProtobuf);

/***/ }),

/***/ 9782:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _cryptography = __nccwpck_require__(7410);

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @augments {ObjectMap<PublicKey, Uint8Array>}
 */
class NodeAccountIdSignatureMap extends _ObjectMap.default {
  constructor() {
    super(s => _cryptography.PublicKey.fromString(s));
  }
  /**
   * @param {import("@hashgraph/proto").ISignatureMap} sigMap
   * @returns {NodeAccountIdSignatureMap}
   */


  static _fromTransactionSigMap(sigMap) {
    const signatures = new NodeAccountIdSignatureMap();
    const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];

    for (const sigPair of sigPairs) {
      if (sigPair.pubKeyPrefix != null && sigPair.ed25519 != null) {
        signatures._set(_cryptography.PublicKey.fromBytes(sigPair.pubKeyPrefix), sigPair.ed25519);
      }
    }

    return signatures;
  }

}

exports.default = NodeAccountIdSignatureMap;

/***/ }),

/***/ 1813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _NodeAccountIdSignatureMap = _interopRequireDefault(__nccwpck_require__(9782));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @augments {ObjectMap<AccountId, NodeAccountIdSignatureMap>}
 */
class SignatureMap extends _ObjectMap.default {
  constructor() {
    super(s => _AccountId.default.fromString(s));
  }
  /**
   * @param {import("./Transaction.js").default} transaction
   * @returns {SignatureMap}
   */


  static _fromTransaction(transaction) {
    const signatures = new SignatureMap();

    for (let i = 0; i < transaction._nodeIds.length; i++) {
      const sigMap = transaction._signedTransactions[i].sigMap;

      if (sigMap != null) {
        signatures._set(transaction._nodeIds[i], _NodeAccountIdSignatureMap.default._fromTransactionSigMap(sigMap));
      }
    }

    return signatures;
  }

}

exports.default = SignatureMap;

/***/ }),

/***/ 3972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SCHEDULE_CREATE_TRANSACTION = exports.default = exports.TRANSACTION_REGISTRY = exports.CHUNK_SIZE = exports.DEFAULT_RECORD_THRESHOLD = exports.DEFAULT_AUTO_RENEW_PERIOD = void 0;

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _TransactionResponse = _interopRequireDefault(__nccwpck_require__(198));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _TransactionHashMap = _interopRequireDefault(__nccwpck_require__(8411));

var _SignatureMap = _interopRequireDefault(__nccwpck_require__(1813));

var _Executable = _interopRequireWildcard(__nccwpck_require__(1128));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _long = _interopRequireDefault(__nccwpck_require__(492));

var sha384 = _interopRequireWildcard(__nccwpck_require__(8141));

var hex = _interopRequireWildcard(__nccwpck_require__(819));

var _proto = __nccwpck_require__(973);

var _PrecheckStatusError = _interopRequireDefault(__nccwpck_require__(3553));

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _array = __nccwpck_require__(9280);

var _cryptography = __nccwpck_require__(7410);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").ITransactionList} proto.ITransactionList
 * @typedef {import("@hashgraph/proto").ITransactionID} proto.ITransactionID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ISchedulableTransactionBody} proto.ISchedulableTransactionBody
 */

/**
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 * @typedef {import("@hashgraph/cryptography").PrivateKey} PrivateKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */
// 90 days (in seconds)
const DEFAULT_AUTO_RENEW_PERIOD = _long.default.fromValue(7776000); // maximum value of i64 (so there is never a record generated)


exports.DEFAULT_AUTO_RENEW_PERIOD = DEFAULT_AUTO_RENEW_PERIOD;

const DEFAULT_RECORD_THRESHOLD = _Hbar.default.fromTinybars(_long.default.fromString("9223372036854775807")); // 120 seconds


exports.DEFAULT_RECORD_THRESHOLD = DEFAULT_RECORD_THRESHOLD;
const DEFAULT_TRANSACTION_VALID_DURATION = 120;
const CHUNK_SIZE = 1024;
/**
 * @type {Map<NonNullable<proto.TransactionBody["data"]>, (transactions: proto.ITransaction[], signedTransactions: proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: proto.TransactionBody[]) => Transaction>}
 */

exports.CHUNK_SIZE = CHUNK_SIZE;
const TRANSACTION_REGISTRY = new Map();
/**
 * Base class for all transactions that may be submitted to Hedera.
 *
 * @abstract
 * @augments {Executable<proto.ITransaction, proto.ITransactionResponse, TransactionResponse>}
 */

exports.TRANSACTION_REGISTRY = TRANSACTION_REGISTRY;

class Transaction extends _Executable.default {
  // A SDK transaction is composed of multiple, raw protobuf transactions.
  // These should be functionally identicasl, with the exception of pointing to
  // different nodes.
  // When retrying a transaction after a network error or retry-able
  // status response, we try a different transaction and thus a different node.
  constructor() {
    super();
    /**
     * List of proto transactions that have been built from this SDK
     * transaction. Each one should share the same transaction ID.
     *
     * @internal
     * @type {(proto.ITransaction | null)[]}
     */

    this._transactions = [];
    /**
     * List of proto transactions that have been built from this SDK
     * transaction. Each one should share the same transaction ID.
     *
     * @internal
     * @type {proto.ISignedTransaction[]}
     */

    this._signedTransactions = [];
    /**
     * Set of public keys (as string) who have signed this transaction so
     * we do not allow them to sign it again.
     *
     * @private
     * @type {Set<string>}
     */

    this._signerPublicKeys = new Set();
    /**
     * @protected
     * @type {number}
     */

    this._nextTransactionIndex = 0;
    /**
     * @private
     * @type {number}
     */

    this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;
    /**
     * @private
     * @type {Hbar}
     */

    this._maxTransactionFee = new _Hbar.default(2);
    /**
     * @private
     * @type {string}
     */

    this._transactionMemo = "";
    /**
     * @protected
     * @type {TransactionId[]}
     */

    this._transactionIds = [];
    this._signOnDemand = false;
    /**
     * @private
     * @type {PublicKey[]}
     */

    this._publicKeys = [];
    /**
     * @private
     * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}
     */

    this._transactionSigners = [];
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */


  static fromBytes(bytes) {
    const signedTransactions = [];
    const transactionIds = [];
    const nodeIds = [];
    /** @type {string[]} */

    const transactionIdStrings = [];
    /** @type {string[]} */

    const nodeIdStrings = [];
    const bodies = [];

    const list = _proto.TransactionList.decode(bytes).transactionList;

    if (list.length == 0) {
      const transaction = _proto.Transaction.decode(bytes);

      if (transaction.signedTransactionBytes.length != 0) {
        list.push(transaction);
      } else {
        list.push({
          signedTransactionBytes: _proto.SignedTransaction.encode({
            bodyBytes: transaction.bodyBytes,
            sigMap: transaction.sigMap
          }).finish()
        });
      }
    }

    for (const transaction of list) {
      if (transaction.signedTransactionBytes == null) {
        throw new Error("Transaction.signedTransactionBytes are null");
      }

      const signedTransaction = _proto.SignedTransaction.decode(transaction.signedTransactionBytes);

      signedTransactions.push(signedTransaction);

      const body = _proto.TransactionBody.decode(signedTransaction.bodyBytes);

      if (body.data == null) {
        throw new Error("(BUG) body.data was not set in the protobuf");
      }

      bodies.push(body);

      if (body.transactionID != null) {
        const transactionId = _TransactionId.default._fromProtobuf(
        /** @type {proto.ITransactionID} */
        body.transactionID);

        if (!transactionIdStrings.includes(transactionId.toString())) {
          transactionIds.push(transactionId);
          transactionIdStrings.push(transactionId.toString());
        }
      }

      if (body.nodeAccountID != null) {
        const nodeAccountId = _AccountId.default._fromProtobuf(
        /** @type {proto.IAccountID} */
        body.nodeAccountID);

        if (!nodeIdStrings.includes(nodeAccountId.toString())) {
          nodeIds.push(nodeAccountId);
          nodeIdStrings.push(nodeAccountId.toString());
        }
      }
    }

    const body = bodies[0];

    if (body == null || body.data == null) {
      throw new Error("No transaction found in bytes or failed to decode TransactionBody");
    }

    const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);

    if (fromProtobuf == null) {
      throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${body.data}`);
    }

    return fromProtobuf(list, signedTransactions, transactionIds, nodeIds, bodies);
  }
  /**
   * @returns {ScheduleCreateTransaction}
   */


  schedule() {
    this._requireNotFrozen();

    if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
      throw new Error("ScheduleCreateTransaction has not been loaded yet");
    }

    return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
  }
  /**
   * @template {Transaction} TransactionT
   * @param {TransactionT} transaction
   * @param {proto.ITransaction[]} transactions
   * @param {proto.ISignedTransaction[]} signedTransactions
   * @param {TransactionId[]} transactionIds
   * @param {AccountId[]} nodeIds
   * @param {proto.ITransactionBody[]} bodies
   * @returns {TransactionT}
   */


  static _fromProtobufTransactions(transaction, transactions, signedTransactions, transactionIds, nodeIds, bodies) {
    const body = bodies[0];
    const zero = new _AccountId.default(0);

    for (let i = 0; i < nodeIds.length; i++) {
      if (nodeIds[i].equals(zero)) {
        nodeIds.splice(i--, 1);
      }
    }

    transaction._transactions = transactions;
    transaction._signedTransactions = signedTransactions;
    transaction._transactionIds = transactionIds;
    transaction._nodeIds = nodeIds;
    transaction._nextNodeIndex = 0;
    transaction._nextTransactionIndex = 0;
    transaction._transactionValidDuration = body.transactionValidDuration != null && body.transactionValidDuration.seconds != null ? _long.default.fromValue(body.transactionValidDuration.seconds).toInt() : DEFAULT_TRANSACTION_VALID_DURATION;
    transaction._maxTransactionFee = body.transactionFee != null ? _Hbar.default.fromTinybars(body.transactionFee) : new _Hbar.default(0);
    transaction._transactionMemo = body.memo != null ? body.memo : "";

    for (let i = 0; i < nodeIds.length; i++) {
      const signedTransaction = signedTransactions[i];

      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          transaction._signerPublicKeys.add(hex.encode(
          /** @type {Uint8Array} */
          sigPair.pubKeyPrefix));

          transaction._publicKeys.push(_cryptography.PublicKey.fromBytes(
          /** @type {Uint8Array} */
          sigPair.pubKeyPrefix));

          transaction._transactionSigners.push(null);
        }
      }
    }

    return transaction;
  }
  /**
   * @override
   * @param {AccountId[]} nodeIds
   * @returns {this}
   */


  setNodeAccountIds(nodeIds) {
    this._requireNotFrozen();

    super.setNodeAccountIds(nodeIds);
    return this;
  }
  /**
   * @returns {number}
   */


  get transactionValidDuration() {
    return this._transactionValidDuration;
  }
  /**
   * Sets the duration (in seconds) that this transaction is valid for.
   *
   * This is defaulted to 120 seconds (from the time its executed).
   *
   * @param {number} validDuration
   * @returns {this}
   */


  setTransactionValidDuration(validDuration) {
    this._requireNotFrozen();

    this._transactionValidDuration = validDuration;
    return this;
  }
  /**
   * @returns {?Hbar}
   */


  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  /**
   * Set the maximum transaction fee the operator (paying account)
   * is willing to pay.
   *
   * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
   * @returns {this}
   */


  setMaxTransactionFee(maxTransactionFee) {
    this._requireNotFrozen();

    this._maxTransactionFee = maxTransactionFee instanceof _Hbar.default ? maxTransactionFee : new _Hbar.default(maxTransactionFee);
    return this;
  }
  /**
   * @returns {string}
   */


  get transactionMemo() {
    return this._transactionMemo;
  }
  /**
   * Set a note or description to be recorded in the transaction
   * record (maximum length of 100 bytes).
   *
   * @param {string} transactionMemo
   * @returns {this}
   */


  setTransactionMemo(transactionMemo) {
    this._requireNotFrozen();

    this._transactionMemo = transactionMemo;
    return this;
  }
  /**
   * @returns {TransactionId}
   */


  get transactionId() {
    if (this._transactionIds.length === 0) {
      throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");
    }

    return this._transactionIds[this._nextTransactionIndex];
  }
  /**
   * Set the ID for this transaction.
   *
   * The transaction ID includes the operator's account ( the account paying the transaction
   * fee). If two transactions have the same transaction ID, they won't both have an effect. One
   * will complete normally and the other will fail with a duplicate transaction status.
   *
   * Normally, you should not use this method. Just before a transaction is executed, a
   * transaction ID will be generated from the operator on the client.
   *
   * @param {TransactionId} transactionId
   * @returns {this}
   */


  setTransactionId(transactionId) {
    this._requireNotFrozen();

    this._transactionIds = [transactionId];
    return this;
  }
  /**
   * @param {PrivateKey} privateKey
   * @returns {Promise<this>}
   */


  sign(privateKey) {
    return this.signWith(privateKey.publicKey, message => Promise.resolve(privateKey.sign(message)));
  }
  /**
   * @param {PublicKey} publicKey
   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
   * @returns {Promise<this>}
   */


  async signWith(publicKey, transactionSigner) {
    this._requireFrozen();

    const publicKeyData = publicKey.toBytes(); // note: this omits the DER prefix on purpose because Hedera doesn't
    // support that in the protobuf. this means that we would fail
    // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER
    // prefixes here

    const publicKeyHex = hex.encode(publicKeyData);

    if (this._signerPublicKeys.has(publicKeyHex)) {
      // this public key has already signed this transaction
      return this;
    }

    this._transactions = [];

    this._signerPublicKeys.add(publicKeyHex);

    if (this._signOnDemand) {
      this._publicKeys.push(publicKey);

      this._transactionSigners.push(transactionSigner);

      return this;
    }

    for (const signedTransaction of this._signedTransactions) {
      const bodyBytes =
      /** @type {Uint8Array} */
      signedTransaction.bodyBytes;
      const signature = await transactionSigner(bodyBytes);

      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }

      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }

      signedTransaction.sigMap.sigPair.push({
        pubKeyPrefix: publicKeyData,
        ed25519: signature
      });
    }

    return this;
  }
  /**
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<this>}
   */


  signWithOperator(client) {
    const operator = client._operator;

    if (operator == null) {
      throw new Error("`client` must have an operator to sign with the operator");
    }

    if (!this._isFrozen()) {
      this.freezeWith(client);
    }

    return this.signWith(operator.publicKey, operator.transactionSigner);
  }
  /**
   * @internal
   * @protected
   */


  _requireOneNodeAccountId() {
    if (this._nodeIds.length != 1) {
      throw "transaction did not have exactly one node ID set";
    }
  }
  /**
   * @param {PublicKey} publicKey
   * @param {Uint8Array} signature
   * @returns {this}
   */


  addSignature(publicKey, signature) {
    this._requireOneNodeAccountId();

    if (!this.isFrozen()) {
      this.freeze();
    }

    const publicKeyData = publicKey.toBytes();
    const publicKeyHex = hex.encode(publicKeyData);

    if (this._signerPublicKeys.has(publicKeyHex)) {
      // this public key has already signed this transaction
      return this;
    }

    this._transactions = [];

    for (const transaction of this._signedTransactions) {
      if (transaction.sigMap == null) {
        transaction.sigMap = {};
      }

      if (transaction.sigMap.sigPair == null) {
        transaction.sigMap.sigPair = [];
      }

      transaction.sigMap.sigPair.push({
        pubKeyPrefix: publicKeyData,
        ed25519: signature
      });
    }

    this._signerPublicKeys.add(publicKeyHex);

    this._publicKeys.push(publicKey);

    this._transactionSigners.push(null);

    return this;
  }
  /**
   * @returns {SignatureMap}
   */


  getSignatures() {
    if (this._signOnDemand) {
      throw new Error("Please use `getSignaturesAsync()` if `signOnDemand` is enabled");
    }

    this._buildAllTransactions();

    return _SignatureMap.default._fromTransaction(this);
  }
  /**
   * @returns {Promise<SignatureMap>}
   */


  async getSignaturesAsync() {
    await this._buildAllTransactionsAsync();
    return _SignatureMap.default._fromTransaction(this);
  }
  /**
   * Freeze this transaction from future modification to prepare for
   * signing or serialization.
   *
   * @returns {this}
   */


  freeze() {
    return this.freezeWith(null);
  }
  /**
   * Freeze this transaction from further modification to prepare for
   * signing or serialization.
   *
   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
   * nodes to prepare this transaction for.
   *
   * @param {?import("../client/Client.js").default<Channel, *>} client
   * @returns {this}
   */


  freezeWith(client) {
    if (client != null) {
      this._signOnDemand = client._signOnDemand;
    }

    if (client != null && this._maxTransactionFee == null) {
      this._maxTransactionFee = client.maxTransactionFee;
    }

    if (client != null && this._transactionIds.length === 0) {
      const operator = client._operator;

      if (operator == null) {
        throw new Error("`client` must have an `operator` or `transactionId` must be set");
      }

      this.setTransactionId(_TransactionId.default.generate(operator.accountId));
    }

    if (this._transactionIds.length === 0) {
      throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`");
    }

    if (client != null && this._transactionIds[0].accountId != null) {
      this._transactionIds[0].accountId.validate(client);
    }

    if (this._nodeIds.length > 0) {// Do nothing
    } else if (client != null) {
      this._nodeIds = client._network.getNodeAccountIdsForExecute();
    } else {
      throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");
    }

    this._signedTransactions = this._nodeIds.map(nodeId => this._makeSignedTransaction(nodeId));
    return this;
  }
  /**
   * Will error if sign-on-demand is enabled
   *
   * @returns {Uint8Array}
   */


  toBytes() {
    this._requireFrozen();

    if (this._signOnDemand) {
      throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled");
    }

    this._buildAllTransactions();

    return _proto.TransactionList.encode({
      transactionList:
      /** @type {proto.ITransaction[]} */
      this._transactions
    }).finish();
  }
  /**
   * @returns {Promise<Uint8Array>}
   */


  async toBytesAsync() {
    this._requireFrozen();

    await this._buildAllTransactionsAsync();
    return _proto.TransactionList.encode({
      transactionList:
      /** @type {proto.ITransaction[]} */
      this._transactions
    }).finish();
  }
  /**
   * @returns {Promise<Uint8Array>}
   */


  async getTransactionHash() {
    this._requireFrozen();

    await this._buildAllTransactionsAsync();
    return sha384.digest(
    /** @type {Uint8Array} */

    /** @type {proto.ITransaction} */
    this._transactions[0].signedTransactionBytes);
  }
  /**
   * @returns {Promise<TransactionHashMap>}
   */


  async getTransactionHashPerNode() {
    this._requireFrozen();

    await this._buildAllTransactionsAsync();
    return await _TransactionHashMap.default._fromTransaction(this);
  }

  isFrozen() {
    return this._signedTransactions.length > 0;
  }
  /**
   * @returns {TransactionId}
   */


  _getTransactionId() {
    return this.transactionId;
  }
  /**
   * @param {Client} client
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function


  _validateIdNetworks(client) {// Do nothing
  }
  /**
   * @override
   * @protected
   * @param {import("../client/Client.js").default<Channel, *>} client
   * @returns {Promise<void>}
   */


  async _beforeExecute(client) {
    if (!this._isFrozen()) {
      this.freezeWith(client);
    }

    if (client._operator != null) {
      this._validateIdNetworks(client);
    } // on execute, sign each transaction with the operator, if present
    // and we are signing a transaction that used the default transaction ID


    const transactionId = this.transactionId;
    const operatorAccountId = client.operatorAccountId;

    if (operatorAccountId != null && transactionId.accountId != null && operatorAccountId.equals(transactionId.accountId)) {
      await this.signWithOperator(client);
    }
  }
  /**
   * @override
   * @internal
   * @returns {Promise<proto.ITransaction>}
   */


  async _makeRequestAsync() {
    const index = this._nextTransactionIndex * this._nodeIds.length + this._nextNodeIndex;
    await this._buildTransactionAsync(index);
    return (
      /** @type {proto.ITransaction} */
      this._transactions[index]
    );
  }
  /**
   * @param {number} index
   * @internal
   */


  async _signTranscation(index) {
    const signedTransaction = this._signedTransactions[index];
    const bodyBytes =
    /** @type {Uint8Array} */
    signedTransaction.bodyBytes;

    if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null && signedTransaction.sigMap.sigPair.length > 0) {
      for (let i = 0; i < this._publicKeys.length; i++) {
        const publicKey = this._publicKeys[i];
        const signer = this._transactionSigners[i];

        if (signedTransaction.sigMap.sigPair[0].pubKeyPrefix != null && signer != null && (0, _array.arrayEqual)(signedTransaction.sigMap.sigPair[0].pubKeyPrefix, publicKey.toBytes())) {
          return;
        }
      }
    }

    for (let j = 0; j < this._publicKeys.length; j++) {
      const publicKey = this._publicKeys[j];
      const transactionSigner = this._transactionSigners[j];

      if (transactionSigner == null) {
        continue;
      }

      const signature = await transactionSigner(bodyBytes);

      if (signedTransaction.sigMap == null) {
        signedTransaction.sigMap = {};
      }

      if (signedTransaction.sigMap.sigPair == null) {
        signedTransaction.sigMap.sigPair = [];
      }

      signedTransaction.sigMap.sigPair.push({
        pubKeyPrefix: publicKey.toBytes(),
        ed25519: signature
      });
    }
  }

  _buildAllTransactions() {
    for (let i = 0; i < this._signedTransactions.length; i++) {
      this._buildTransaction(i);
    }
  }

  async _buildAllTransactionsAsync() {
    for (let i = 0; i < this._signedTransactions.length; i++) {
      await this._buildTransactionAsync(i);
    }
  }
  /**
   * @param {number} index
   * @internal
   */


  _buildTransaction(index) {
    if (this._transactions.length < index) {
      for (let i = this._transactions.length; i < index; i++) {
        this._transactions.push(null);
      }
    } else if (this._transactions.length > index && this._transactions[index] != null &&
    /** @type {proto.ITransaction} */
    this._transactions[index].signedTransactionBytes != null) {
      return;
    }

    this._transactions.push({
      signedTransactionBytes: _proto.SignedTransaction.encode(this._signedTransactions[index]).finish()
    });
  }
  /**
   * @param {number} index
   * @internal
   */


  async _buildTransactionAsync(index) {
    if (this._transactions.length < index) {
      for (let i = this._transactions.length; i < index; i++) {
        this._transactions.push(null);
      }
    } else if (this._transactions.length > index && this._transactions[index] != null &&
    /** @type {proto.ITransaction} */
    this._transactions[index].signedTransactionBytes != null) {
      return;
    }

    await this._signTranscation(index);

    this._transactions.push({
      signedTransactionBytes: _proto.SignedTransaction.encode(this._signedTransactions[index]).finish()
    });
  }
  /**
   * @override
   * @internal
   * @param {proto.ITransaction} request
   * @param {proto.ITransactionResponse} response
   * @returns {ExecutionState}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _shouldRetry(request, response) {
    const {
      nodeTransactionPrecheckCode
    } = response;

    const status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.PlatformTransactionNotCreated:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Ok:
        return _Executable.ExecutionState.Finished;

      default:
        return _Executable.ExecutionState.Error;
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.ITransaction} request
   * @param {proto.ITransactionResponse} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    const {
      nodeTransactionPrecheckCode
    } = response;

    const status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    return new _PrecheckStatusError.default({
      status,
      transactionId: this._getTransactionId()
    });
  }
  /**
   * @override
   * @protected
   * @param {proto.ITransactionResponse} response
   * @param {AccountId} nodeId
   * @param {proto.ITransaction} request
   * @returns {Promise<TransactionResponse>}
   */


  async _mapResponse(response, nodeId, request) {
    const transactionHash = await sha384.digest(
    /** @type {Uint8Array} */
    request.signedTransactionBytes);
    const transactionId = this.transactionId;
    this._nextTransactionIndex = (this._nextTransactionIndex + 1) % this._transactionIds.length;
    return new _TransactionResponse.default({
      nodeId,
      transactionHash,
      transactionId
    });
  }
  /**
   * @override
   * @returns {AccountId}
   */


  _getNodeAccountId() {
    if (this._nodeIds.length === 0) {
      throw new Error("(BUG) Transaction::_getNodeAccountId called before transaction has been frozen");
    }

    return this._nodeIds[this._nextNodeIndex % this._nodeIds.length];
  }
  /**
   * @internal
   * @param {?AccountId} nodeId
   * @returns {proto.ISignedTransaction}
   */


  _makeSignedTransaction(nodeId) {
    const body = this._makeTransactionBody(nodeId);

    const bodyBytes = _proto.TransactionBody.encode(body).finish();

    return {
      bodyBytes,
      sigMap: {
        sigPair: []
      }
    };
  }
  /**
   * @private
   * @param {?AccountId} nodeId
   * @returns {proto.ITransactionBody}
   */


  _makeTransactionBody(nodeId) {
    return {
      [this._getTransactionDataCase()]: this._makeTransactionData(),
      transactionFee: this._maxTransactionFee != null ? this._maxTransactionFee.toTinybars() : null,
      memo: this._transactionMemo,
      transactionID: this._transactionIds[this._nextTransactionIndex] != null ? this._transactionIds[this._nextTransactionIndex]._toProtobuf() : null,
      nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
      transactionValidDuration: {
        seconds: _long.default.fromNumber(this._transactionValidDuration)
      }
    };
  }
  /**
   * @abstract
   * @protected
   * @returns {NonNullable<proto.TransactionBody["data"]>}
   */


  _getTransactionDataCase() {
    throw new Error("not implemented");
  }
  /**
   * @internal
   * @returns {proto.ISchedulableTransactionBody}
   */


  _getScheduledTransactionBody() {
    return {
      memo: this.transactionMemo,
      transactionFee: this.maxTransactionFee != null ? this.maxTransactionFee.toTinybars() : null,
      [this._getTransactionDataCase()]: this._makeTransactionData()
    };
  }
  /**
   * @abstract
   * @protected
   * @returns {object}
   */


  _makeTransactionData() {
    throw new Error("not implemented");
  }
  /**
   * @protected
   * @returns {boolean}
   */


  _isFrozen() {
    return this._signedTransactions.length > 0;
  }
  /**
   * @internal
   */


  _requireNotFrozen() {
    if (this._isFrozen()) {
      throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen");
    }
  }
  /**
   * @private
   */


  _requireFrozen() {
    if (!this._isFrozen()) {
      throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
    }
  }

}
/**
 * @type {(() => ScheduleCreateTransaction)[]}
 */


exports.default = Transaction;
const SCHEDULE_CREATE_TRANSACTION = [];
exports.SCHEDULE_CREATE_TRANSACTION = SCHEDULE_CREATE_TRANSACTION;

/***/ }),

/***/ 8411:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var sha384 = _interopRequireWildcard(__nccwpck_require__(8141));

var _ObjectMap = _interopRequireDefault(__nccwpck_require__(5835));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 */

/**
 * @augments {ObjectMap<AccountId, Uint8Array>}
 */
class TransactionHashMap extends _ObjectMap.default {
  constructor() {
    super(s => _AccountId.default.fromString(s));
  }
  /**
   * @param {import("./Transaction.js").default} transaction
   * @returns {Promise<TransactionHashMap>}
   */


  static async _fromTransaction(transaction) {
    const hashes = new TransactionHashMap();

    for (let i = 0; i < transaction._nodeIds.length; i++) {
      const nodeAccountId = transaction._nodeIds[i];
      const tx =
      /** @type {proto.ITransaction} */
      transaction._transactions[i];
      const hash = await sha384.digest(
      /** @type {Uint8Array} */
      tx.signedTransactionBytes);

      hashes._set(nodeAccountId, hash);
    }

    return hashes;
  }

}

exports.default = TransactionHashMap;

/***/ }),

/***/ 4730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _long = _interopRequireDefault(__nccwpck_require__(492));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The client-generated ID for a transaction.
 *
 * This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created,
 * and internally by the network for detecting when duplicate transactions are submitted.
 */
class TransactionId {
  /**
   * Don't use this method directly.
   * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
   *
   * @param {?AccountId} accountId
   * @param {?Timestamp} validStart
   * @param {?boolean} scheduled
   */
  constructor(accountId, validStart, scheduled = false) {
    /**
     * The Account ID that paid for this transaction.
     *
     * @readonly
     */
    this.accountId = accountId;
    /**
     * The time from when this transaction is valid.
     *
     * When a transaction is submitted there is additionally a validDuration (defaults to 120s)
     * and together they define a time window that a transaction may be processed in.
     *
     * @readonly
     */

    this.validStart = validStart;
    this.scheduled = scheduled;
    Object.freeze(this);
  }
  /**
   * @param {AccountId} accountId
   * @param {Timestamp} validStart
   * @returns {TransactionId}
   */


  static withValidStart(accountId, validStart) {
    return new TransactionId(accountId, validStart, null);
  }
  /**
   * Generates a new transaction ID for the given account ID.
   *
   * Note that transaction IDs are made of the valid start of the transaction and the account
   * that will be charged the transaction fees for the transaction.
   *
   * @param {AccountId | string} id
   * @returns {TransactionId}
   */


  static generate(id) {
    return new TransactionId(typeof id === "string" ? _AccountId.default.fromString(id) : new _AccountId.default(id), _Timestamp.default.generate());
  }
  /**
   * @param {string} wholeId
   * @returns {TransactionId}
   */


  static fromString(wholeId) {
    let [id, scheduled] = wholeId.split("?");
    const [account, time] = id.split("@");
    const [seconds, nanos] = time.split(".").map(value => _long.default.fromValue(value));
    return new TransactionId(_AccountId.default.fromString(account), new _Timestamp.default(seconds, nanos), scheduled === "scheduled");
  }
  /**
   * @param {boolean} scheduled
   * @returns {this}
   */


  setScheduled(scheduled) {
    this.scheduled = scheduled;
    return this;
  }
  /**
   * @returns {string}
   */


  toString() {
    if (this.accountId != null && this.validStart != null) {
      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${this.scheduled ? "?scheduled" : ""}`;
    } else {
      throw new Error("Neither `nonce` or `accountId` and `validStart` are set");
    }
  }
  /**
   * @internal
   * @param {proto.ITransactionID} id
   * @param {(string | null)=} networkName
   * @returns {TransactionId}
   */


  static _fromProtobuf(id, networkName) {
    if (id.accountID != null && id.transactionValidStart != null) {
      return new TransactionId(_AccountId.default._fromProtobuf(id.accountID, networkName), _Timestamp.default._fromProtobuf(id.transactionValidStart), id.scheduled);
    } else {
      throw new Error("Neither `nonce` or `accountID` and `transactionValidStart` are set");
    }
  }
  /**
   * @internal
   * @returns {proto.ITransactionID}
   */


  _toProtobuf() {
    return {
      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
      transactionValidStart: this.validStart != null ? this.validStart._toProtobuf() : null,
      scheduled: this.scheduled
    };
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionId}
   */


  static fromBytes(bytes) {
    return TransactionId._fromProtobuf(proto.TransactionID.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.TransactionID.encode(this._toProtobuf()).finish();
  }
  /**
   * @returns {TransactionId}
   */


  clone() {
    return new TransactionId(this.accountId, this.validStart, this.scheduled);
  }

}

exports.default = TransactionId;

/***/ }),

/***/ 7214:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _AccountId = _interopRequireDefault(__nccwpck_require__(7776));

var _ContractId = _interopRequireDefault(__nccwpck_require__(9954));

var _FileId = _interopRequireDefault(__nccwpck_require__(3842));

var _TopicId = _interopRequireDefault(__nccwpck_require__(3545));

var _TokenId = _interopRequireDefault(__nccwpck_require__(6297));

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

var _ExchangeRate = _interopRequireDefault(__nccwpck_require__(7344));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _long = _interopRequireDefault(__nccwpck_require__(492));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The consensus result for a transaction, which might not be currently known,
 * or may succeed or fail.
 */
class TransactionReceipt {
  /**
   * @private
   * @param {object} props
   * @param {Status} props.status
   * @param {?AccountId} props.accountId
   * @param {?FileId} props.fileId
   * @param {?ContractId} props.contractId
   * @param {?TopicId} props.topicId
   * @param {?TokenId} props.tokenId
   * @param {?ScheduleId} props.scheduleId
   * @param {?ExchangeRate} props.exchangeRate
   * @param {?Long} props.topicSequenceNumber
   * @param {?Uint8Array} props.topicRunningHash
   * @param {?Long} props.totalSupply
   * @param {?TransactionId} props.scheduledTransactionId
   */
  constructor(props) {
    /**
     * Whether the transaction succeeded or failed (or is unknown).
     *
     * @readonly
     */
    this.status = props.status;
    /**
     * The account ID, if a new account was created.
     *
     * @readonly
     */

    this.accountId = props.accountId;
    /**
     * The file ID, if a new file was created.
     *
     * @readonly
     */

    this.fileId = props.fileId;
    /**
     * The contract ID, if a new contract was created.
     *
     * @readonly
     */

    this.contractId = props.contractId;
    /**
     * The topic ID, if a new topic was created.
     *
     * @readonly
     */

    this.topicId = props.topicId;
    /**
     * The token ID, if a new token was created.
     *
     * @readonly
     */

    this.tokenId = props.tokenId;
    /**
     * The schedule ID, if a new schedule was created.
     *
     * @readonly
     */

    this.scheduleId = props.scheduleId;
    /**
     * The exchange rate of Hbars to cents (USD).
     *
     * @readonly
     */

    this.exchangeRate = props.exchangeRate;
    /**
     * Updated sequence number for a consensus service topic.
     *
     * @readonly
     */

    this.topicSequenceNumber = props.topicSequenceNumber;
    /**
     * Updated running hash for a consensus service topic.
     *
     * @readonly
     */

    this.topicRunningHash = props.topicRunningHash;
    /**
     * Updated total supply for a token
     *
     * @readonly
     */

    this.totalSupply = props.totalSupply;
    this.scheduledTransactionId = props.scheduledTransactionId;
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {proto.ITransactionReceipt}
   */


  _toProtobuf() {
    return {
      status: this.status.valueOf(),
      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,
      fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
      contractID: this.contractId != null ? this.contractId._toProtobuf() : null,
      topicID: this.topicId != null ? this.topicId._toProtobuf() : null,
      tokenID: this.topicId != null ? this.topicId._toProtobuf() : null,
      scheduleID: this.topicId != null ? this.topicId._toProtobuf() : null,
      topicRunningHash: this.topicRunningHash == null ? null : this.topicRunningHash,
      topicSequenceNumber: this.topicSequenceNumber,
      exchangeRate: {
        nextRate: null,
        currentRate: this.exchangeRate != null ? this.exchangeRate._toProtobuf() : null
      },
      scheduledTransactionID: this.scheduledTransactionId != null ? this.scheduledTransactionId._toProtobuf() : null
    };
  }
  /**
   * @internal
   * @param {proto.ITransactionReceipt} receipt
   * @param {(string | null)=} ledgerId
   * @returns {TransactionReceipt}
   */


  static _fromProtobuf(receipt, ledgerId) {
    const exchangeRateSet =
    /** @type {proto.IExchangeRateSet} */
    receipt.exchangeRate;
    return new TransactionReceipt({
      status: _Status.default._fromCode(receipt.status != null ? receipt.status : 0),
      accountId: receipt.accountID != null ? _AccountId.default._fromProtobuf(receipt.accountID, ledgerId) : null,
      fileId: receipt.fileID != null ? _FileId.default._fromProtobuf(receipt.fileID, ledgerId) : null,
      contractId: receipt.contractID != null ? _ContractId.default._fromProtobuf(receipt.contractID, ledgerId) : null,
      topicId: receipt.topicID != null ? _TopicId.default._fromProtobuf(receipt.topicID, ledgerId) : null,
      tokenId: receipt.tokenID != null ? _TokenId.default._fromProtobuf(receipt.tokenID, ledgerId) : null,
      scheduleId: receipt.scheduleID != null ? _ScheduleId.default._fromProtobuf(receipt.scheduleID, ledgerId) : null,
      exchangeRate: receipt.exchangeRate != null ? _ExchangeRate.default._fromProtobuf(
      /** @type {proto.IExchangeRate} */
      exchangeRateSet.currentRate) : null,
      topicSequenceNumber: receipt.topicSequenceNumber == null ? null : _long.default.fromValue(receipt.topicSequenceNumber),
      topicRunningHash: receipt.topicRunningHash != null ? receipt.topicRunningHash : null,
      totalSupply: receipt.newTotalSupply != null ? receipt.newTotalSupply : null,
      scheduledTransactionId: receipt.scheduledTransactionID != null ? _TransactionId.default._fromProtobuf(receipt.scheduledTransactionID, ledgerId) : null
    });
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionReceipt}
   */


  static fromBytes(bytes) {
    return TransactionReceipt._fromProtobuf(proto.TransactionReceipt.decode(bytes), null);
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.TransactionReceipt.encode(this._toProtobuf()).finish();
  }

}

exports.default = TransactionReceipt;

/***/ }),

/***/ 5230:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _TransactionReceipt = _interopRequireDefault(__nccwpck_require__(7214));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _PrecheckStatusError = _interopRequireDefault(__nccwpck_require__(3553));

var _ReceiptStatusError = _interopRequireDefault(__nccwpck_require__(7852));

var _Executable = __nccwpck_require__(1128);

var _proto = __nccwpck_require__(973);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITransactionReceipt} proto.ITransactionReceipt
 * @typedef {import("@hashgraph/proto").ITransactionGetReceiptQuery} proto.ITransactionGetReceiptQuery
 * @typedef {import("@hashgraph/proto").ITransactionGetReceiptResponse} proto.ITransactionGetReceiptResponse
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<TransactionReceipt>}
 */
class TransactionReceiptQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {TransactionId | string} [props.transactionId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TransactionId}
     */

    this._transactionId = null;

    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {TransactionReceiptQuery}
   */


  static _fromProtobuf(query) {
    const receipt =
    /** @type {proto.ITransactionGetReceiptQuery} */
    query.transactionGetReceipt;
    return new TransactionReceiptQuery({
      transactionId: receipt.transactionID ? _TransactionId.default._fromProtobuf(receipt.transactionID) : undefined
    });
  }
  /**
   * @returns {?TransactionId}
   */


  get transactionId() {
    return this._transactionId;
  }
  /**
   * Set the transaction ID for which the receipt is being requested.
   *
   * @param {TransactionId | string} transactionId
   * @returns {this}
   */


  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? _TransactionId.default.fromString(transactionId) : transactionId.clone();
    return this;
  }
  /**
   * @override
   * @protected
   * @returns {boolean}
   */


  _isPaymentRequired() {
    return false;
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @returns {ExecutionState}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _shouldRetry(request, response) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    let status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.ReceiptNotFound:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Ok:
        break;

      default:
        return _Executable.ExecutionState.Error;
    }

    const transactionGetReceipt =
    /** @type {proto.ITransactionGetReceiptResponse} */
    response.transactionGetReceipt;
    const receipt =
    /** @type {proto.ITransactionReceipt} */
    transactionGetReceipt.receipt;
    const receiptStatusCode =
    /** @type {proto.ResponseCodeEnum} */
    receipt.status;
    status = _Status.default._fromCode(receiptStatusCode);

    switch (status) {
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.ReceiptNotFound:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Success:
        return _Executable.ExecutionState.Finished;

      default:
        return _Executable.ExecutionState.Error;
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    let status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Ok:
        // Do nothing
        break;

      default:
        return new _PrecheckStatusError.default({
          status,
          transactionId: this._getTransactionId()
        });
    }

    const transactionGetReceipt =
    /** @type {proto.ITransactionGetReceiptResponse} */
    response.transactionGetReceipt;
    const receipt =
    /** @type {proto.ITransactionReceipt} */
    transactionGetReceipt.receipt;
    const receiptStatusCode =
    /** @type {proto.ResponseCodeEnum} */
    receipt.status;
    status = _Status.default._fromCode(receiptStatusCode);
    return new _ReceiptStatusError.default({
      status,
      transactionId: this._getTransactionId(),
      transactionReceipt: _TransactionReceipt.default._fromProtobuf(
      /** @type {proto.ITransactionReceipt} */
      response.transactionGetReceipt, ledgerId)
    });
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getTransactionReceipts(request);
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const transactionGetReceipt =
    /** @type {proto.ITransactionGetReceiptResponse} */
    response.transactionGetReceipt;
    return (
      /** @type {proto.IResponseHeader} */
      transactionGetReceipt.header
    );
  }
  /**
   * @protected
   * @override
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<TransactionReceipt>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const transactionGetReceipt =
    /** @type {proto.ITransactionGetReceiptResponse} */
    response.transactionGetReceipt;
    const receipt =
    /** @type {proto.ITransactionReceipt} */
    transactionGetReceipt.receipt;
    return Promise.resolve(_TransactionReceipt.default._fromProtobuf(receipt, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      transactionGetReceipt: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null
      }
    };
  }

}

exports.default = TransactionReceiptQuery;

_Query.QUERY_REGISTRY.set("transactionGetReceipt", // eslint-disable-next-line @typescript-eslint/unbound-method
TransactionReceiptQuery._fromProtobuf);

/***/ }),

/***/ 1155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _TransactionReceipt = _interopRequireDefault(__nccwpck_require__(7214));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _Timestamp = _interopRequireDefault(__nccwpck_require__(351));

var _Hbar = _interopRequireDefault(__nccwpck_require__(3826));

var _Transfer = _interopRequireDefault(__nccwpck_require__(5199));

var _ContractFunctionResult = _interopRequireDefault(__nccwpck_require__(5971));

var _TokenTransferMap = _interopRequireDefault(__nccwpck_require__(4363));

var proto = _interopRequireWildcard(__nccwpck_require__(973));

var _ScheduleId = _interopRequireDefault(__nccwpck_require__(9032));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Response when the client sends the node TransactionGetRecordResponse.
 */
class TransactionRecord {
  /**
   * @private
   * @param {object} props
   * @param {ContractFunctionResult} [props.contractFunctionResult]
   * @param {TransactionReceipt} props.receipt
   * @param {Uint8Array} props.transactionHash
   * @param {Timestamp} props.consensusTimestampstamp
   * @param {TransactionId} props.transactionId
   * @param {string} props.transactionMemo
   * @param {Hbar} props.transactionFee
   * @param {Transfer[]} props.transfers
   * @param {TokenTransferMap} props.tokenTransfers
   * @param {?ScheduleId} props.scheduleRef
   */
  constructor(props) {
    /**
     * The status (reach consensus, or failed, or is unknown) and the ID of
     * any new account/file/instance created.
     *
     * @readonly
     */
    this.receipt = props.receipt;
    /**
     * The hash of the Transaction that executed (not the hash of any Transaction that failed
     * for having a duplicate TransactionID).
     *
     * @readonly
     */

    this.transactionHash = props.transactionHash;
    /**
     * The consensus timestamp (or null if didn't reach consensus yet).
     *
     * @readonly
     */

    this.consensusTimestampstamp = props.consensusTimestampstamp;
    /**
     * The ID of the transaction this record represents.
     *
     * @readonly
     */

    this.transactionId = props.transactionId;
    /**
     * The memo that was submitted as part of the transaction (max 100 bytes).
     *
     * @readonly
     */

    this.transactionMemo = props.transactionMemo;
    /**
     * The actual transaction fee charged,
     * not the original transactionFee value from TransactionBody.
     *
     * @readonly
     */

    this.transactionFee = props.transactionFee;
    /**
     * All hbar transfers as a result of this transaction, such as fees, or transfers performed
     * by the transaction, or by a smart contract it calls, or by the creation of threshold
     * records that it triggers.
     *
     * @readonly
     */

    this.transfers = props.transfers;
    /**
     * Record of the value returned by the smart contract function or constructor.
     *
     * @readonly
     */

    this.contractFunctionResult = props.contractFunctionResult != null ? props.contractFunctionResult : null;
    /**
     * All the token transfers from this account
     *
     * @readonly
     */

    this.tokenTransfers = props.tokenTransfers;
    this.scheduleRef = props.scheduleRef;
    Object.freeze(this);
  }
  /**
   * @internal
   * @returns {proto.ITransactionRecord}
   */


  _toProtobuf() {
    return {
      receipt: this.receipt._toProtobuf(),
      transactionHash: this.transactionHash != null ? this.transactionHash : null,
      consensusTimestamp: this.consensusTimestampstamp != null ? this.consensusTimestampstamp._toProtobuf() : null,
      transactionID: this.transactionId != null ? this.transactionId._toProtobuf() : null,
      memo: this.transactionMemo != null ? this.transactionMemo : null,
      transactionFee: this.transactionFee != null ? this.transactionFee.toTinybars() : null,
      contractCallResult: this.contractFunctionResult != null ? this.contractFunctionResult : null,
      contractCreateResult: this.contractFunctionResult != null ? this.contractFunctionResult : null,
      transferList: this.transfers != null ? {
        accountAmounts: this.transfers.map(transfer => transfer._toProtobuf())
      } : null,
      tokenTransferLists: this.tokenTransfers._toProtobuf(),
      scheduleRef: this.scheduleRef != null ? this.scheduleRef._toProtobuf() : null
    };
  }
  /**
   * @internal
   * @param {proto.ITransactionRecord} record
   * @param {(string | null)=} ledgerId
   * @returns {TransactionRecord}
   */


  static _fromProtobuf(record, ledgerId) {
    const contractFunctionResult = record.contractCallResult != null ? _ContractFunctionResult.default._fromProtobuf(record.contractCallResult) : record.contractCreateResult != null ? _ContractFunctionResult.default._fromProtobuf(record.contractCreateResult) : undefined;
    return new TransactionRecord({
      receipt: _TransactionReceipt.default._fromProtobuf(
      /** @type {proto.ITransactionReceipt} */
      record.receipt, ledgerId),
      transactionHash: record.transactionHash != null ? record.transactionHash : new Uint8Array(),
      consensusTimestampstamp: _Timestamp.default._fromProtobuf(
      /** @type {proto.ITimestamp} */
      record.consensusTimestamp),
      transactionId: _TransactionId.default._fromProtobuf(
      /** @type {proto.ITransactionID} */
      record.transactionID, ledgerId),
      transactionMemo: record.memo != null ? record.memo : "",
      transactionFee: _Hbar.default.fromTinybars(record.transactionFee != null ? record.transactionFee : 0),
      transfers: (record.transferList != null ? record.transferList.accountAmounts != null ? record.transferList.accountAmounts : [] : []).map(aa => _Transfer.default._fromProtobuf(aa, ledgerId)),
      contractFunctionResult,
      tokenTransfers: _TokenTransferMap.default._fromProtobuf(record.tokenTransferLists != null ? record.tokenTransferLists : [], ledgerId),
      scheduleRef: record.scheduleRef != null ? _ScheduleId.default._fromProtobuf(record.scheduleRef, ledgerId) : null
    });
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionRecord}
   */


  static fromBytes(bytes) {
    return TransactionRecord._fromProtobuf(proto.TransactionRecord.decode(bytes));
  }
  /**
   * @returns {Uint8Array}
   */


  toBytes() {
    return proto.TransactionRecord.encode(this._toProtobuf()).finish();
  }

}

exports.default = TransactionRecord;

/***/ }),

/***/ 8529:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _Query = _interopRequireWildcard(__nccwpck_require__(8678));

var _TransactionRecord = _interopRequireDefault(__nccwpck_require__(1155));

var _TransactionReceipt = _interopRequireDefault(__nccwpck_require__(7214));

var _TransactionId = _interopRequireDefault(__nccwpck_require__(4730));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _PrecheckStatusError = _interopRequireDefault(__nccwpck_require__(3553));

var _ReceiptStatusError = _interopRequireDefault(__nccwpck_require__(7852));

var _Executable = __nccwpck_require__(1128);

var _proto = __nccwpck_require__(973);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").ITransactionRecord} proto.ITransactionRecord
 * @typedef {import("@hashgraph/proto").ITransactionReceipt} proto.ITransactionReceipt
 * @typedef {import("@hashgraph/proto").ITransactionGetRecordResponse} proto.ITransactionGetRecordResponse
 * @typedef {import("@hashgraph/proto").ITransactionGetRecordQuery} proto.ITransactionGetRecordQuery
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<TransactionRecord>}
 */
class TransactionRecordQuery extends _Query.default {
  /**
   * @param {object} [props]
   * @param {TransactionId} [props.transactionId]
   */
  constructor(props = {}) {
    super();
    /**
     * @private
     * @type {?TransactionId}
     */

    this._transactionId = null;

    if (props.transactionId != null) {
      this.setTransactionId(props.transactionId);
    }
  }
  /**
   * @returns {?TransactionId}
   */


  get transactionId() {
    return this._transactionId;
  }
  /**
   * @internal
   * @param {proto.IQuery} query
   * @returns {TransactionRecordQuery}
   */


  static _fromProtobuf(query) {
    const record =
    /** @type {proto.ITransactionGetRecordQuery} */
    query.transactionGetRecord;
    return new TransactionRecordQuery({
      transactionId: record.transactionID ? _TransactionId.default._fromProtobuf(record.transactionID) : undefined
    });
  }
  /**
   * Set the transaction ID for which the record is being requested.
   *
   * @param {TransactionId | string} transactionId
   * @returns {TransactionRecordQuery}
   */


  setTransactionId(transactionId) {
    this._transactionId = typeof transactionId === "string" ? _TransactionId.default.fromString(transactionId) : transactionId.clone();
    return this;
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @returns {ExecutionState}
   */


  _shouldRetry(request, response) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    let status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.ReceiptNotFound:
      case _Status.default.RecordNotFound:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Ok:
        break;

      default:
        return _Executable.ExecutionState.Error;
    }

    const transactionGetRecord =
    /** @type {proto.ITransactionGetRecordResponse} */
    response.transactionGetRecord;
    const header =
    /** @type {proto.IResponseHeader} */
    transactionGetRecord.header;

    if (header.responseType === _proto.ResponseType.COST_ANSWER) {
      return _Executable.ExecutionState.Finished;
    }

    const record =
    /** @type {proto.ITransactionRecord} */
    transactionGetRecord.transactionRecord;
    const receipt =
    /** @type {proto.ITransactionReceipt} */
    record.receipt;
    const receiptStatusCode =
    /** @type {proto.ResponseCodeEnum} */
    receipt.status;
    status = _Status.default._fromCode(receiptStatusCode);

    switch (status) {
      case _Status.default.Ok:
      case _Status.default.Busy:
      case _Status.default.Unknown:
      case _Status.default.ReceiptNotFound:
      case _Status.default.RecordNotFound:
        return _Executable.ExecutionState.Retry;

      case _Status.default.Success:
        return _Executable.ExecutionState.Finished;

      default:
        return _Executable.ExecutionState.Error;
    }
  }
  /**
   * @override
   * @internal
   * @param {proto.IQuery} request
   * @param {proto.IResponse} response
   * @param {string | null} ledgerId
   * @returns {Error}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapStatusError(request, response, ledgerId) {
    const {
      nodeTransactionPrecheckCode
    } = this._mapResponseHeader(response);

    let status = _Status.default._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : _proto.ResponseCodeEnum.OK);

    switch (status) {
      case _Status.default.Ok:
        // Do nothing
        break;

      default:
        return new _PrecheckStatusError.default({
          status,
          transactionId: this._getTransactionId()
        });
    }

    const transactionGetRecord =
    /** @type {proto.ITransactionGetRecordResponse} */
    response.transactionGetRecord;
    const record =
    /** @type {proto.ITransactionRecord} */
    transactionGetRecord.transactionRecord;
    const receipt =
    /** @type {proto.ITransactionReceipt} */
    record.receipt;
    const receiptStatusError =
    /** @type {proto.ResponseCodeEnum} */
    receipt.status;
    status = _Status.default._fromCode(receiptStatusError);
    return new _ReceiptStatusError.default({
      status,
      transactionId: this._getTransactionId(),
      transactionReceipt: _TransactionReceipt.default._fromProtobuf(receipt, ledgerId)
    });
  }
  /**
   * @param {Client} client
   */


  _validateIdNetworks(client) {
    if (this._transactionId != null && this._transactionId.accountId != null) {
      this._transactionId.accountId.validate(client);
    }
  }
  /**
   * @override
   * @internal
   * @param {Channel} channel
   * @param {proto.IQuery} request
   * @returns {Promise<proto.IResponse>}
   */


  _execute(channel, request) {
    return channel.crypto.getTxRecordByTxID(request);
  }
  /**
   * @override
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @returns {proto.IResponseHeader}
   */


  _mapResponseHeader(response) {
    const transactionGetRecord =
    /** @type {proto.ITransactionGetRecordResponse} */
    response.transactionGetRecord;
    return (
      /** @type {proto.IResponseHeader} */
      transactionGetRecord.header
    );
  }
  /**
   * @override
   * @internal
   * @param {proto.IResponse} response
   * @param {AccountId} nodeAccountId
   * @param {proto.IQuery} request
   * @param {string | null} ledgerId
   * @returns {Promise<TransactionRecord>}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _mapResponse(response, nodeAccountId, request, ledgerId) {
    const record =
    /** @type {proto.ITransactionGetRecordResponse} */
    response.transactionGetRecord;
    return Promise.resolve(_TransactionRecord.default._fromProtobuf(
    /** @type {proto.ITransactionRecord} */
    record.transactionRecord, ledgerId));
  }
  /**
   * @override
   * @internal
   * @param {proto.IQueryHeader} header
   * @returns {proto.IQuery}
   */


  _onMakeRequest(header) {
    return {
      transactionGetRecord: {
        header,
        transactionID: this._transactionId != null ? this._transactionId._toProtobuf() : null
      }
    };
  }

}

exports.default = TransactionRecordQuery;

_Query.QUERY_REGISTRY.set("transactionGetRecord", // eslint-disable-next-line @typescript-eslint/unbound-method
TransactionRecordQuery._fromProtobuf);

/***/ }),

/***/ 198:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _ReceiptStatusError = _interopRequireDefault(__nccwpck_require__(7852));

var _Status = _interopRequireDefault(__nccwpck_require__(1108));

var _TransactionReceiptQuery = _interopRequireDefault(__nccwpck_require__(5230));

var _TransactionRecordQuery = _interopRequireDefault(__nccwpck_require__(8529));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("./TransactionId.js").default} TransactionId
 * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./TransactionRecord.js").default} TransactionRecord
 */
class TransactionResponse {
  /**
   * @internal
   * @param {object} props
   * @param {AccountId} props.nodeId
   * @param {Uint8Array} props.transactionHash
   * @param {TransactionId} props.transactionId
   */
  constructor(props) {
    /** @readonly */
    this.nodeId = props.nodeId;
    /** @readonly */

    this.transactionHash = props.transactionHash;
    /** @readonly */

    this.transactionId = props.transactionId;
    Object.freeze(this);
  }
  /**
   * @param {Client} client
   * @returns {Promise<TransactionReceipt>}
   */


  async getReceipt(client) {
    const receipt = await new _TransactionReceiptQuery.default().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]).execute(client);

    if (receipt.status !== _Status.default.Success) {
      throw new _ReceiptStatusError.default({
        transactionReceipt: receipt,
        status: receipt.status,
        transactionId: this.transactionId
      });
    }

    return receipt;
  }
  /**
   * @param {Client} client
   * @returns {Promise<TransactionRecord>}
   */


  async getRecord(client) {
    await this.getReceipt(client);
    return new _TransactionRecordQuery.default().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]).execute(client);
  }

}

exports.default = TransactionResponse;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 881:
/***/ ((module) => {

"use strict";
module.exports = require("dns");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7565:
/***/ ((module) => {

"use strict";
module.exports = require("http2");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 5794:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
const core = __nccwpck_require__(694);
const { Client, AccountBalanceQuery, HbarUnit } = __nccwpck_require__(9868);

async function main() {
  try {
    const hederaNetwork = core.getInput("hedera-network").toLowerCase();
    const operatorId = core.getInput("operator-id");
    const operatorKey = core.getInput("operator-key");
    const failAction = core.getInput("fail-action").toLowerCase() !== "false";

    let accountId = core.getInput("account-id");
    if (accountId.length === 0) {
      accountId = operatorId;
    }

    const minimumBalance = core.getInput("minimum-balance");
    if (isNaN(minimumBalance) || isNaN(parseFloat(minimumBalance))) {
      core.setFailed(`minimum-balance ${minimumBalance} should be a number`);
      return;
    }
    const minimumHbars = Number(minimumBalance);
    // Alternative to integer if smaller hbar units are needed?
    //const minimumHbars = Hbar(minimumBalance, HbarUnit.Hbar);

    console.log(
      `Checking account ${accountId} balance on ${hederaNetwork} using operator ${operatorId}`
    );

    let client;

    switch (hederaNetwork) {
      case "mainnet":
        client = Client.forMainnet();
        break;
      case "previewnet":
        client = Client.forPreviewnet();
        break;
      default:
        client = Client.forTestnet();
    }

    client.setOperator(operatorId, operatorKey);

    const balance = await new AccountBalanceQuery()
      .setAccountId(accountId)
      .execute(client);

    const hbars = balance.hbars.to(HbarUnit.Hbar).integerValue();

    core.setOutput("account-balance", hbars);

    var result = hbars < minimumHbars ? "below" : "above or equal to";
    var msg = `Balance of ${hbars} is ${result} minimum ${minimumHbars}`;
    console.log(msg);

    if (failAction && hbars < minimumHbars) {
      core.setFailed(msg);
    }
  } catch (error) {
    core.setFailed(error.message);
  }
}

void main();

})();

module.exports = __webpack_exports__;
/******/ })()
;